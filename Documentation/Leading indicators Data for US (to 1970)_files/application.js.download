/*! BUILD-b902f48f0725eb2261895a1f04235710c0cc0eab-dirty */
require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],2:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],3:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayLikeToArray.js":1}],4:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],5:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],6:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeReflectConstruct = require("./isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./isNativeReflectConstruct.js":13,"./setPrototypeOf.js":19}],7:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],8:[function(require,module,exports){
var superPropBase = require("./superPropBase.js");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./superPropBase.js":21}],9:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],10:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./setPrototypeOf.js":19}],11:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],12:[function(require,module,exports){
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],13:[function(require,module,exports){
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],14:[function(require,module,exports){
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],15:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],16:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],17:[function(require,module,exports){
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],18:[function(require,module,exports){
var _typeof = require("@babel/runtime/helpers/typeof")["default"];

var assertThisInitialized = require("./assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./assertThisInitialized.js":4,"@babel/runtime/helpers/typeof":24}],19:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],20:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles.js");

var iterableToArrayLimit = require("./iterableToArrayLimit.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableRest = require("./nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayWithHoles.js":2,"./iterableToArrayLimit.js":15,"./nonIterableRest.js":16,"./unsupportedIterableToArray.js":25}],21:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./getPrototypeOf.js":9}],22:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles.js");

var iterableToArray = require("./iterableToArray.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableRest = require("./nonIterableRest.js");

function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
}

module.exports = _toArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayWithHoles.js":2,"./iterableToArray.js":14,"./nonIterableRest.js":16,"./unsupportedIterableToArray.js":25}],23:[function(require,module,exports){
var arrayWithoutHoles = require("./arrayWithoutHoles.js");

var iterableToArray = require("./iterableToArray.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableSpread = require("./nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayWithoutHoles.js":3,"./iterableToArray.js":14,"./nonIterableSpread.js":17,"./unsupportedIterableToArray.js":25}],24:[function(require,module,exports){
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],25:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayLikeToArray.js":1}],26:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf.js");

var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeFunction = require("./isNativeFunction.js");

var construct = require("./construct.js");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./construct.js":6,"./getPrototypeOf.js":9,"./isNativeFunction.js":12,"./setPrototypeOf.js":19}],27:[function(require,module,exports){
!function() {
  var d3 = {
    version: "3.5.17"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.transpose = function(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  };
  function d3_transposeLength(d) {
    return d.length;
  }
  d3.zip = function() {
    return d3.transpose(arguments);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: d3_nsXhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = d3_array(nodes);
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var  = 1e-6, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ?  : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? half : x < -1 ? -half : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var  = Math.SQRT2, 2 = 2, 4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < 2) {
      S = Math.log(w1 / w0) / ;
      i = function(t) {
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp( * t * S) ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4 * d2) / (2 * w0 * 2 * d1), b1 = (w1 * w1 - w0 * w0 - 4 * d2) / (2 * w1 * 2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / ;
      i = function(t) {
        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (2 * d1) * (coshr0 * d3_tanh( * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh( * s + r0) ];
      };
    }
    i.duration = S * 1e3;
    return i;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: null
      };
      scaleTo(+_);
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function() {
    d3_timer.apply(this, arguments);
  };
  function d3_timer(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
    return timer;
  }
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now(), timer = d3_timer_queueHead;
    while (timer) {
      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
      timer = timer.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.c) {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      } else {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value = +value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * ;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 *  + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var 00, 00, 0, cos0, sin0;
    d3_geo_area.point = function(, ) {
      d3_geo_area.point = nextPoint;
      0 = (00 = ) * d3_radians, cos0 = Math.cos( = (00 = ) * d3_radians / 2 +  / 4), 
      sin0 = Math.sin();
    };
    function nextPoint(, ) {
       *= d3_radians;
       =  * d3_radians / 2 +  / 4;
      var d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(), sin = Math.sin(), k = sin0 * sin, u = cos0 * cos + k * Math.cos(ad), v = k * sd * Math.sin(ad);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      0 = , cos0 = cos, sin0 = sin;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(00, 00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var  = spherical[0],  = spherical[1], cos = Math.cos();
    return [ cos * Math.cos(), cos * Math.sin(), Math.sin() ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) <  && abs(a[1] - b[1]) < ;
  }
  d3.geo.bounds = function() {
    var 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) 0 = -(1 = 180), 0 = -(1 = 90); else if (dSum > ) 1 = 90; else if (dSum < -) 0 = -90;
        range[0] = 0, range[1] = 1;
      }
    };
    function point(, ) {
      ranges.push(range = [ 0 = , 1 =  ]);
      if ( < 0) 0 = ;
      if ( > 1) 1 = ;
    }
    function linePoint(, ) {
      var p = d3_geo_cartesian([  * d3_radians,  * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs(d) > 180;
        if (antimeridian ^ (s * _ < i && i < s * )) {
          var i = inflection[1] * d3_degrees;
          if (i > 1) 1 = i;
        } else if (i = (i + 360) % 360 - 180, antimeridian ^ (s * _ < i && i < s * )) {
          var i = -inflection[1] * d3_degrees;
          if (i < 0) 0 = i;
        } else {
          if ( < 0) 0 = ;
          if ( > 1) 1 = ;
        }
        if (antimeridian) {
          if ( < _) {
            if (angle(0, ) > angle(0, 1)) 1 = ;
          } else {
            if (angle(, 1) > angle(0, 1)) 0 = ;
          }
        } else {
          if (1 >= 0) {
            if ( < 0) 0 = ;
            if ( > 1) 1 = ;
          } else {
            if ( > _) {
              if (angle(0, ) > angle(0, 1)) 1 = ;
            } else {
              if (angle(, 1) > angle(0, 1)) 0 = ;
            }
          }
        }
      } else {
        point(, );
      }
      p0 = p, _ = ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = 0, range[1] = 1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(, ) {
      if (p0) {
        var d =  - _;
        dSum += abs(d) > 180 ? d + (d > 0 ? 360 : -360) : d;
      } else __ = , __ = ;
      d3_geo_area.point(, );
      linePoint(, );
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(__, __);
      d3_geo_area.lineEnd();
      if (abs(dSum) > ) 0 = -(1 = 180);
      range[0] = 0, range[1] = 1;
      p0 = null;
    }
    function angle(0, 1) {
      return (1 -= 0) < 0 ? 1 + 360 : 1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      1 = 1 = -(0 = 0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, d;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((d = angle(a[1], b[0])) > best) best = d, 0 = b[0], 1 = a[1];
        }
      }
      ranges = range = null;
      return 0 === Infinity || 0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ 0, 0 ], [ 1, 1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < 2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < 2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(, ) {
     *= d3_radians;
    var cos = Math.cos( *= d3_radians);
    d3_geo_centroidPointXYZ(cos * Math.cos(), cos * Math.sin(), Math.sin());
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians);
      x0 = cos * Math.cos();
      y0 = cos * Math.sin();
      z0 = Math.sin();
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var 00, 00, x0, y0, z0;
    d3_geo_centroid.point = function(, ) {
      00 = , 00 = ;
      d3_geo_centroid.point = nextPoint;
       *= d3_radians;
      var cos = Math.cos( *= d3_radians);
      x0 = cos * Math.cos();
      y0 = cos * Math.sin();
      z0 = Math.sin();
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(00, 00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(, ) {
        var point = rotate(, );
        if (pointVisible( = point[0],  = point[1])) listener.point(, );
      }
      function pointLine(, ) {
        var point = rotate(, );
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(, ) {
        ring.push([ ,  ]);
        var point = rotate(, );
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(, ) {
        line.push([ ,  ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - half -  : half - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half -  : half - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -, - / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var 0 = NaN, 0 = NaN, s0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(1, 1) {
        var s1 = 1 > 0 ?  : -, d = abs(1 - 0);
        if (abs(d - ) < ) {
          listener.point(0, 0 = (0 + 1) / 2 > 0 ? half : -half);
          listener.point(s0, 0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(s1, 0);
          listener.point(1, 0);
          clean = 0;
        } else if (s0 !== s1 && d >= ) {
          if (abs(0 - s0) < ) 0 -= s0 * ;
          if (abs(1 - s1) < ) 1 -= s1 * ;
          0 = d3_geo_clipAntimeridianIntersect(0, 0, 1, 1);
          listener.point(s0, 0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(s1, 0);
          clean = 0;
        }
        listener.point(0 = 1, 0 = 1);
        s0 = s1;
      },
      lineEnd: function() {
        listener.lineEnd();
        0 = 0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(0, 0, 1, 1) {
    var cos0, cos1, sin0_1 = Math.sin(0 - 1);
    return abs(sin0_1) >  ? Math.atan((Math.sin(0) * (cos1 = Math.cos(1)) * Math.sin(1) - Math.sin(1) * (cos0 = Math.cos(0)) * Math.sin(0)) / (cos0 * cos1 * sin0_1)) : (0 + 1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var ;
    if (from == null) {
       = direction * half;
      listener.point(-, );
      listener.point(0, );
      listener.point(, );
      listener.point(, 0);
      listener.point(, -);
      listener.point(0, -);
      listener.point(-, -);
      listener.point(-, 0);
      listener.point(-, );
    } else if (abs(from[0] - to[0]) > ) {
      var s = from[0] < to[0] ?  : -;
       = direction * s / 2;
      listener.point(-s, );
      listener.point(0, );
      listener.point(s, );
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin(0), cos0 = Math.cos(0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(), cos = Math.cos(), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;
        d3_geo_areaRingSum.add(Math.atan2(k * sd * Math.sin(ad), cos0 * cos + k * Math.cos(ad)));
        polarAngle += antimeridian ? d + sd *  : d;
        if (antimeridian ^ 0 >= meridian ^  >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var arc = (antimeridian ^ d >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > arc || parallel === arc && (arc[0] || arc[1])) {
            winding += antimeridian ^ d >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        0 = , sin0 = sin, cos0 = cos, point0 = point;
      }
    }
    return (polarAngle < - || polarAngle <  && d3_geo_areaRingSum < -) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -, radius -  ]);
    function visible(, ) {
      return Math.cos() * Math.cos() > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(, ) {
          var point1 = [ ,  ], point2, v = visible(, ), c = smallRadius ? v ? 0 : code(, ) : v ? code( + ( < 0 ?  : -), ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ;
              point1[1] += ;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;
      if (1 < 0) z = 0, 0 = 1, 1 = z;
      var  = 1 - 0, polar = abs( - ) < , meridian = polar ||  < ;
      if (!polar && 1 < 0) z = 0, 0 = 1, 1 = z;
      if (meridian ? polar ? 0 + 1 > 0 ^ q[1] < (abs(q[0] - 0) <  ? 0 : 1) : 0 <= q[1] && q[1] <= 1 :  >  ^ (0 <= q[0] && q[0] <= 1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(, ) {
      var r = smallRadius ? radius :  - radius, code = 0;
      if ( < -r) code |= 1; else if ( > r) code |= 2;
      if ( < -r) code |= 4; else if ( > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) <  ? direction > 0 ? 0 : 3 : abs(p[0] - x1) <  ? direction > 0 ? 2 : 1 : abs(p[1] - y0) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator(projectAt), p = m(0, 1);
    p.parallels = function(_) {
      if (!arguments.length) return [ 0 /  * 180, 1 /  * 180 ];
      return m(0 = _[0] *  / 180, 1 = _[1] *  / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(0, 1) {
    var sin0 = Math.sin(0), n = (sin0 + Math.sin(1)) / 2, C = 1 + sin0 * (2 * n - sin0), 0 = Math.sqrt(C) / n;
    function forward(, ) {
      var  = Math.sqrt(C - 2 * n * Math.sin()) / n;
      return [  * Math.sin( *= n), 0 -  * Math.cos() ];
    }
    forward.invert = function(x, y) {
      var 0_y = 0 - y;
      return [ Math.atan2(x, 0_y) / n, d3_asin((C - (x * x + 0_y * 0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + , y + .12 * k +  ], [ x - .214 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + , y + .166 * k +  ], [ x - .115 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, );
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var 2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(, ) {
        var c = d3_geo_cartesian([ ,  ]), p = project(, );
        resampleLineTo(x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(, ) {
        linePoint(00 = , 00 = ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * 2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), 2 = Math.asin(c /= m), 2 = abs(abs(c) - 1) <  || abs(0 - 1) <  ? (0 + 1) / 2 : Math.atan2(b, a), p = project(2, 2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > 2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(2);
      maxDepth = (2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + x, y - x[1] * k ];
    }), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + x, y - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - x) / k, (y - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [  * d3_degrees,  * d3_degrees ];
       = _[0] % 360 * d3_radians;
       = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [  * d3_degrees,  * d3_degrees,  * d3_degrees ];
       = _[0] % 360 * d3_radians;
       = _[1] % 360 * d3_radians;
       = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(, , ), project);
      var center = project(, );
      x = x - center[0] * k;
      y = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(, ) {
    return [ ,  ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(, ) {
    return [  >  ?  -  :  < - ?  +  : ,  ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(, , ) {
    return  ?  ||  ? d3_geo_compose(d3_geo_rotation(), d3_geo_rotation(, )) : d3_geo_rotation() :  ||  ? d3_geo_rotation(, ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotation() {
    return function(, ) {
      return  += , [  >  ?  -  :  < - ?  +  : ,  ];
    };
  }
  function d3_geo_rotation() {
    var rotation = d3_geo_forwardRotation();
    rotation.invert = d3_geo_forwardRotation(-);
    return rotation;
  }
  function d3_geo_rotation(, ) {
    var cos = Math.cos(), sin = Math.sin(), cos = Math.cos(), sin = Math.sin();
    function rotation(, ) {
      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos + x * sin;
      return [ Math.atan2(y * cos - k * sin, x * cos - z * sin), d3_asin(k * cos + y * sin) ];
    }
    rotation.invert = function(, ) {
      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos - y * sin;
      return [ Math.atan2(y * cos + z * sin, x * cos + k * sin), d3_asin(k * cos - x * sin) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * ;
      } else {
        from = radius + direction * ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var  = (b[0] - a[0]) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(), cos = Math.cos(), sin0 = Math.sin(0), cos0 = Math.cos(0), sin1 = Math.sin(1), cos1 = Math.cos(1), t;
    return Math.atan2(Math.sqrt((t = cos1 * sin) * t + (t = cos0 * sin1 - sin0 * cos1 * cos) * t), sin0 * sin1 + cos0 * cos1 * cos);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 +  ], [ 180, 90 -  ] ]).minorExtent([ [ -180, -80 -  ], [ 180, 80 +  ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - , dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - , dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var 0, sin0, cos0;
    d3_geo_length.point = function(, ) {
      0 =  * d3_radians, sin0 = Math.sin( *= d3_radians), cos0 = Math.cos();
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(, ) {
      var sin = Math.sin( *= d3_radians), cos = Math.cos(), t = abs(( *= d3_radians) - 0), cos = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos * Math.sin(t)) * t + (t = cos0 * sin - sin0 * cos * cos) * t), sin0 * sin + cos0 * cos * cos);
      0 = , sin0 = sin, cos0 = cos;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(, ) {
      var cos = Math.cos(), cos = Math.cos(), k = scale(cos * cos);
      return [ k * cos * Math.sin(), k * Math.sin() ];
    }
    azimuthal.invert = function(x, y) {
      var  = Math.sqrt(x * x + y * y), c = angle(), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc,  * cosc), Math.asin( && y * sinc / ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(coscos) {
    return Math.sqrt(2 / (1 + coscos));
  }, function() {
    return 2 * Math.asin( / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(coscos) {
    var c = Math.acos(coscos);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(0, 1) {
    var cos0 = Math.cos(0), t = function() {
      return Math.tan( / 4 +  / 2);
    }, n = 0 === 1 ? Math.sin(0) : Math.log(cos0 / Math.cos(1)) / Math.log(t(1) / t(0)), F = cos0 * Math.pow(t(0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(, ) {
      if (F > 0) {
        if ( < -half + )  = -half + ;
      } else {
        if ( > half - )  = half - ;
      }
      var  = F / Math.pow(t(), n);
      return [  * Math.sin(n * ), F -  * Math.cos(n * ) ];
    }
    forward.invert = function(x, y) {
      var 0_y = F - y,  = d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y);
      return [ Math.atan2(x, 0_y) / n, 2 * Math.atan(Math.pow(F / , 1 / n)) - half ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(0, 1) {
    var cos0 = Math.cos(0), n = 0 === 1 ? Math.sin(0) : (cos0 - Math.cos(1)) / (1 - 0), G = cos0 / n + 0;
    if (abs(n) < ) return d3_geo_equirectangular;
    function forward(, ) {
      var  = G - ;
      return [  * Math.sin(n * ), G -  * Math.cos(n * ) ];
    }
    forward.invert = function(x, y) {
      var 0_y = G - y;
      return [ Math.atan2(x, 0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(coscos) {
    return 1 / coscos;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(, ) {
    return [ , Math.log(Math.tan( / 4 +  / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - half ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k =  * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(coscos) {
    return 1 / (1 + coscos);
  }, function() {
    return 2 * Math.atan();
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(, ) {
    return [ Math.log(Math.tan( / 4 +  / 2)), - ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - half ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) <  && abs(y - lArc.circle.cy) < ) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) <  && abs(y - rArc.circle.cy) < ) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) >  || abs(y3 - y2) > ) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) <  && y1 - y3 >  ? {
            x: x0,
            y: abs(x2 - x0) <  ? y2 : y1
          } : abs(y3 - y1) <  && x1 - x3 >  ? {
            x: abs(y2 - y1) <  ? x2 : x1,
            y: y1
          } : abs(x3 - x1) <  && y3 - y0 >  ? {
            x: x1,
            y: abs(x2 - x1) <  ? y2 : y0
          } : abs(y3 - y0) <  && x3 - x0 >  ? {
            x: abs(y2 - y0) <  ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) <  && abs(e.a.y - e.b.y) < ) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ) * ,
          y: Math.round(fy(d, i) / ) * ,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * half);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p /  * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransformPop(s) {
    return s.length ? s.pop() + "," : "";
  }
  function d3_interpolateTranslate(ta, tb, s, q) {
    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
      var i = s.push("translate(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    }
  }
  function d3_interpolateRotate(ra, rb, s, q) {
    if (ra !== rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
  }
  function d3_interpolateSkew(wa, wb, s, q) {
    if (wa !== wb) {
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
  }
  function d3_interpolateScale(ka, kb, s, q) {
    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] !== 1 || kb[1] !== 1) {
      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
  }
  function d3_interpolateTransform(a, b) {
    var s = [], q = [];
    a = d3.transform(a), b = d3.transform(b);
    d3_interpolateTranslate(a.translate, b.translate, s, q);
    d3_interpolateRotate(a.rotate, b.rotate, s, q);
    d3_interpolateSkew(a.skew, b.skew, s, q);
    d3_interpolateScale(a.scale, b.scale, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = ( - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        timer = null;
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) {
          alpha = x;
        } else {
          timer.c = null, timer.t = NaN, timer = null;
          event.end({
            type: "end",
            alpha: alpha = 0
          });
        }
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        timer = d3_timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = root.y = 0;
      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(, ) {
      var n = arguments.length;
      if (n < 2)  = 1;
      if (n < 1)  = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return  +  * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    return domain;
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(1, base * n / scale.ticks().length);
      return function(d) {
        var i = d / pow(Math.round(log(d)));
        if (i * base < base - .5) i *= base;
        return i <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= ) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if (da >  && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var rc1 = rc, rc0 = rc;
        if (da < ) {
          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
        if (x1 != null) {
          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.length > 1 ? points.join("L") : points + "Z";
  }
  function d3_svg_lineLinearClosed(points) {
    return points.join("L") + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - half;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half, a1 = endAngle.call(self, subgroup, i) - half;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > ) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - half;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / );
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, activeId, active;
      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
        active.timer.c = null;
        active.timer.t = NaN;
        if (--lock.count) delete lock[activeId]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id], time, timer, duration, ease, tweens;
    function schedule(elapsed) {
      var delay = transition.delay;
      timer.t = delay + time;
      if (delay <= elapsed) return start(elapsed - delay);
      timer.c = start;
    }
    function start(elapsed) {
      var activeId = lock.active, active = lock[activeId];
      if (active) {
        active.timer.c = null;
        active.timer.t = NaN;
        --lock.count;
        delete lock[activeId];
        active.event && active.event.interrupt.call(node, node.__data__, active.index);
      }
      for (var cancelId in lock) {
        if (+cancelId < id) {
          var cancel = lock[cancelId];
          cancel.timer.c = null;
          cancel.timer.t = NaN;
          --lock.count;
          delete lock[cancelId];
        }
      }
      timer.c = tick;
      d3_timer(function() {
        if (timer.c && tick(elapsed || 1)) {
          timer.c = null;
          timer.t = NaN;
        }
        return 1;
      }, 0, time);
      lock.active = id;
      transition.event && transition.event.start.call(node, node.__data__, i);
      tweens = [];
      transition.tween.forEach(function(key, value) {
        if (value = value.call(node, node.__data__, i)) {
          tweens.push(value);
        }
      });
      ease = transition.ease;
      duration = transition.duration;
    }
    function tick(elapsed) {
      var t = elapsed / duration, e = ease(t), n = tweens.length;
      while (n > 0) {
        tweens[--n].call(node, e);
      }
      if (t >= 1) {
        transition.event && transition.event.end.call(node, node.__data__, i);
        if (--lock.count) delete lock[id]; else delete node[ns];
        return 1;
      }
    }
    if (!transition) {
      time = inherit.time;
      timer = d3_timer(schedule, 0, time);
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        timer: timer,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ), tickExit = d3.transition(tick.exit()).style("opacity", ).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = d3_array(arguments);
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (typeof define === "function" && define.amd) this.d3 = d3, define(d3); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
}();
},{}],28:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2020 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
; // eslint-disable-line no-extra-semi

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory(); // eslint-disable-line no-param-reassign
    }
}(this, function () {
    /**
     * Brings an environment as close to ECMAScript 5 compliance
     * as is possible with the facilities of erstwhile engines.
     *
     * Annotated ES5: http://es5.github.com/ (specific links below)
     * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
     * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
     */

    // Shortcut to an often accessed properties, in order to avoid multiple
    // dereference that costs universally. This also holds a reference to known-good
    // functions.
    var $Array = Array;
    var ArrayPrototype = $Array.prototype;
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    var $Function = Function;
    var FunctionPrototype = $Function.prototype;
    var $String = String;
    var StringPrototype = $String.prototype;
    var $Number = Number;
    var NumberPrototype = $Number.prototype;
    var array_slice = ArrayPrototype.slice;
    var array_splice = ArrayPrototype.splice;
    var array_push = ArrayPrototype.push;
    var array_unshift = ArrayPrototype.unshift;
    var array_concat = ArrayPrototype.concat;
    var array_join = ArrayPrototype.join;
    var call = FunctionPrototype.call;
    var apply = FunctionPrototype.apply;
    var max = Math.max;
    var min = Math.min;
    var floor = Math.floor;
    var abs = Math.abs;
    var pow = Math.pow;
    var round = Math.round;
    var log = Math.log;
    var LOG10E = Math.LOG10E;
    var log10 = Math.log10 || function log10(value) {
        return log(value) * LOG10E;
    };

    // Having a toString local variable name breaks in Opera so use to_string.
    var to_string = ObjectPrototype.toString;

    /* eslint-disable one-var-declaration-per-line, no-redeclare, max-statements-per-line */
    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn(value) { try { var fnStr = fnToStr.call(value); var singleStripped = fnStr.replace(/\/\/.*\n/g, ''); var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, ''); var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' '); return constructorRegex.test(spaceStripped); } catch (e) { return false; /* not a function */ } }, tryFunctionObject = function tryFunctionObject(value) { try { if (isES6ClassFn(value)) { return false; } fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', isCallable = function isCallable(value) { if (!value) { return false; } if (typeof value !== 'function' && typeof value !== 'object') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } if (isES6ClassFn(value)) { return false; } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };

    var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
    var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
    /* eslint-enable one-var-declaration-per-line, no-redeclare, max-statements-per-line */

    /* inlined from http://npmjs.com/define-properties */
    var supportsDescriptors = $Object.defineProperty && (function () {
        try {
            var obj = {};
            $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
            // eslint-disable-next-line no-unreachable-loop, max-statements-per-line
            for (var _ in obj) { return false; } // jscs:ignore disallowUnusedVariables
            return obj.x === obj;
        } catch (e) { /* this is ES3 */
            return false;
        }
    }());
    var defineProperties = (function (has) {
        // Define configurable, writable, and non-enumerable props
        // if they don't exist.
        var defineProperty;
        if (supportsDescriptors) {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                $Object.defineProperty(object, name, {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: method
                });
            };
        } else {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                object[name] = method; // eslint-disable-line no-param-reassign
            };
        }
        return function defineProperties(object, map, forceAssign) {
            for (var name in map) {
                if (has.call(map, name)) {
                    defineProperty(object, name, map[name], forceAssign);
                }
            }
        };
    }(ObjectPrototype.hasOwnProperty));

    //
    // Util
    // ======
    //

    /* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
    var isPrimitive = function isPrimitive(input) {
        var type = typeof input;
        return input === null || (type !== 'object' && type !== 'function');
    };

    var isActualNaN = $Number.isNaN || function isActualNaN(x) {
        return x !== x;
    };

    var ES = {
        // ES5 9.4
        // http://es5.github.com/#x9.4
        // http://jsperf.com/to-integer
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
        ToInteger: function ToInteger(num) {
            var n = +num;
            if (isActualNaN(n)) {
                n = 0;
            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
                n = (n > 0 || -1) * floor(abs(n));
            }
            return n;
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
        ToPrimitive: function ToPrimitive(input) {
            var val, valueOf, toStr;
            if (isPrimitive(input)) {
                return input;
            }
            valueOf = input.valueOf;
            if (isCallable(valueOf)) {
                val = valueOf.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            toStr = input.toString;
            if (isCallable(toStr)) {
                val = toStr.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            throw new TypeError();
        },

        // ES5 9.9
        // http://es5.github.com/#x9.9
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
        ToObject: function (o) {
            if (o == null) { // this matches both null and undefined
                throw new TypeError("can't convert " + o + ' to object');
            }
            return $Object(o);
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
        ToUint32: function ToUint32(x) {
            return x >>> 0;
        }
    };

    //
    // Function
    // ========
    //

    // ES-5 15.3.4.5
    // http://es5.github.com/#x15.3.4.5

    var Empty = function Empty() {};

    defineProperties(FunctionPrototype, {
        bind: function bind(that) { // .length is 1
            // 1. Let Target be the this value.
            var target = this;
            // 2. If IsCallable(Target) is false, throw a TypeError exception.
            if (!isCallable(target)) {
                throw new TypeError('Function.prototype.bind called on incompatible ' + target);
            }
            // 3. Let A be a new (possibly empty) internal list of all of the
            //   argument values provided after thisArg (arg1, arg2 etc), in order.
            // XXX slicedArgs will stand in for "A" if used
            var args = array_slice.call(arguments, 1); // for normal call
            // 4. Let F be a new native ECMAScript object.
            // 11. Set the [[Prototype]] internal property of F to the standard
            //   built-in Function prototype object as specified in 15.3.3.1.
            // 12. Set the [[Call]] internal property of F as described in
            //   15.3.4.5.1.
            // 13. Set the [[Construct]] internal property of F as described in
            //   15.3.4.5.2.
            // 14. Set the [[HasInstance]] internal property of F as described in
            //   15.3.4.5.3.
            var bound;
            var binder = function () {

                if (this instanceof bound) {
                    // 15.3.4.5.2 [[Construct]]
                    // When the [[Construct]] internal method of a function object,
                    // F that was created using the bind function is called with a
                    // list of arguments ExtraArgs, the following steps are taken:
                    // 1. Let target be the value of F's [[TargetFunction]]
                    //   internal property.
                    // 2. If target has no [[Construct]] internal method, a
                    //   TypeError exception is thrown.
                    // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Construct]] internal
                    //   method of target providing args as the arguments.

                    var result = apply.call(
                        target,
                        this,
                        array_concat.call(args, array_slice.call(arguments))
                    );
                    if ($Object(result) === result) {
                        return result;
                    }
                    return this;

                }
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return apply.call(
                    target,
                    that,
                    array_concat.call(args, array_slice.call(arguments))
                );

            };

            // 15. If the [[Class]] internal property of Target is "Function", then
            //     a. Let L be the length property of Target minus the length of A.
            //     b. Set the length own property of F to either 0 or L, whichever is
            //       larger.
            // 16. Else set the length own property of F to 0.

            var boundLength = max(0, target.length - args.length);

            // 17. Set the attributes of the length own property of F to the values
            //   specified in 15.3.5.1.
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                array_push.call(boundArgs, '$' + i);
            }

            // XXX Build a dynamic function with desired amount of arguments is the only
            // way to set the length property of a function.
            // In environments where Content Security Policies enabled (Chrome extensions,
            // for ex.) all use of eval or Function costructor throws an exception.
            // However in all of these environments Function.prototype.bind exists
            // and so this code will never be executed.
            bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                // Clean up dangling references.
                Empty.prototype = null;
            }

            // TODO
            // 18. Set the [[Extensible]] internal property of F to true.

            // TODO
            // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
            // 20. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
            //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
            //   false.
            // 21. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
            //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
            //   and false.

            // TODO
            // NOTE Function objects created using Function.prototype.bind do not
            // have a prototype property or the [[Code]], [[FormalParameters]], and
            // [[Scope]] internal properties.
            // XXX can't delete prototype in pure-js.

            // 22. Return F.
            return bound;
        }
    });

    // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
    // use it in defining shortcuts.
    var owns = call.bind(ObjectPrototype.hasOwnProperty);
    var toStr = call.bind(ObjectPrototype.toString);
    var arraySlice = call.bind(array_slice);
    var arraySliceApply = apply.bind(array_slice);
    /* globals document */
    if (typeof document === 'object' && document && document.documentElement) {
        try {
            arraySlice(document.documentElement.childNodes);
        } catch (e) {
            var origArraySlice = arraySlice;
            var origArraySliceApply = arraySliceApply;
            arraySlice = function arraySliceIE(arr) {
                var r = [];
                var i = arr.length;
                while (i-- > 0) {
                    r[i] = arr[i];
                }
                return origArraySliceApply(r, origArraySlice(arguments, 1));
            };
            arraySliceApply = function arraySliceApplyIE(arr, args) {
                return origArraySliceApply(arraySlice(arr), args);
            };
        }
    }
    var strSlice = call.bind(StringPrototype.slice);
    var strSplit = call.bind(StringPrototype.split);
    var strIndexOf = call.bind(StringPrototype.indexOf);
    var pushCall = call.bind(array_push);
    var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
    var arraySort = call.bind(ArrayPrototype.sort);

    //
    // Array
    // =====
    //

    var isArray = $Array.isArray || function isArray(obj) {
        return toStr(obj) === '[object Array]';
    };

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.13
    // Return len+argCount.
    // [bugfix, ielt8]
    // IE < 8 bug: [].unshift(0) === undefined but should be "1"
    var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
    defineProperties(ArrayPrototype, {
        unshift: function () {
            array_unshift.apply(this, arguments);
            return this.length;
        }
    }, hasUnshiftReturnValueBug);

    // ES5 15.4.3.2
    // http://es5.github.com/#x15.4.3.2
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
    defineProperties($Array, { isArray: isArray });

    // The IsCallable() check in the Array functions
    // has been replaced with a strict check on the
    // internal class of the object to trap cases where
    // the provided function was actually a regular
    // expression literal, which in V8 and
    // JavaScriptCore is a typeof "function".  Only in
    // V8 are regular expression literals permitted as
    // reduce parameters, so it is desirable in the
    // general case for the shim to match the more
    // strict and common behavior of rejecting regular
    // expressions.

    // ES5 15.4.4.18
    // http://es5.github.com/#x15.4.4.18
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

    // Check failure of by-index access of string characters (IE < 9)
    // and failure of `0 in boxedString` (Rhino)
    var boxedString = $Object('a');
    var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

    var properlyBoxesContext = function properlyBoxed(method) {
        // Check node 0.6.21 bug where third parameter is not boxed
        var properlyBoxesNonStrict = true;
        var properlyBoxesStrict = true;
        var threwException = false;
        if (method) {
            try {
                method.call('foo', function (_, __, context) {
                    if (typeof context !== 'object') {
                        properlyBoxesNonStrict = false;
                    }
                });

                method.call([1], function () {
                    'use strict';

                    properlyBoxesStrict = typeof this === 'string';
                }, 'x');
            } catch (e) {
                threwException = true;
            }
        }
        return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
    };

    defineProperties(ArrayPrototype, {
        forEach: function forEach(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var i = -1;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.forEach callback must be a function');
            }

            while (++i < length) {
                if (i in self) {
                    // Invoke the callback function with call, passing arguments:
                    // context, property value, property key, thisArg object
                    if (typeof T === 'undefined') {
                        callbackfn(self[i], i, object);
                    } else {
                        callbackfn.call(T, self[i], i, object);
                    }
                }
            }
        }
    }, !properlyBoxesContext(ArrayPrototype.forEach));

    // ES5 15.4.4.19
    // http://es5.github.com/#x15.4.4.19
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
    defineProperties(ArrayPrototype, {
        map: function map(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = $Array(length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.map callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    if (typeof T === 'undefined') {
                        result[i] = callbackfn(self[i], i, object);
                    } else {
                        result[i] = callbackfn.call(T, self[i], i, object);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.map));

    // ES5 15.4.4.20
    // http://es5.github.com/#x15.4.4.20
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
    defineProperties(ArrayPrototype, {
        filter: function filter(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = [];
            var value;
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.filter callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    value = self[i];
                    if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
                        pushCall(result, value);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.filter));

    // ES5 15.4.4.16
    // http://es5.github.com/#x15.4.4.16
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
    defineProperties(ArrayPrototype, {
        every: function every(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.every callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return false;
                }
            }
            return true;
        }
    }, !properlyBoxesContext(ArrayPrototype.every));

    // ES5 15.4.4.17
    // http://es5.github.com/#x15.4.4.17
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
    defineProperties(ArrayPrototype, {
        some: function some(callbackfn/*, thisArg */) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.some callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return true;
                }
            }
            return false;
        }
    }, !properlyBoxesContext(ArrayPrototype.some));

    // ES5 15.4.4.21
    // http://es5.github.com/#x15.4.4.21
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
    var reduceCoercesToObject = false;
    if (ArrayPrototype.reduce) {
        reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduce: function reduce(callbackfn/*, initialValue*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduce callback must be a function');
            }

            // no value to return if no initial value and an empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduce of empty array with no initial value');
            }

            var i = 0;
            var result;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i++];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (++i >= length) {
                        throw new TypeError('reduce of empty array with no initial value');
                    }
                } while (true);
            }

            for (; i < length; i++) {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            }

            return result;
        }
    }, !reduceCoercesToObject);

    // ES5 15.4.4.22
    // http://es5.github.com/#x15.4.4.22
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
    var reduceRightCoercesToObject = false;
    if (ArrayPrototype.reduceRight) {
        reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduceRight: function reduceRight(callbackfn/*, initial*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduceRight callback must be a function');
            }

            // no value to return if no initial value, empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduceRight of empty array with no initial value');
            }

            var result;
            var i = length - 1;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i--];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (--i < 0) {
                        throw new TypeError('reduceRight of empty array with no initial value');
                    }
                } while (true);
            }

            if (i < 0) {
                return result;
            }

            do {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            } while (i--);

            return result;
        }
    }, !reduceRightCoercesToObject);

    // ES5 15.4.4.14
    // http://es5.github.com/#x15.4.4.14
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
    var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
    defineProperties(ArrayPrototype, {
        indexOf: function indexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }

            var i = 0;
            if (arguments.length > 1) {
                i = ES.ToInteger(arguments[1]);
            }

            // handle negative indices
            i = i >= 0 ? i : max(0, length + i);
            for (; i < length; i++) {
                if (i in self && self[i] === searchElement) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2IndexOfBug);

    // ES5 15.4.4.15
    // http://es5.github.com/#x15.4.4.15
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
    var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
    defineProperties(ArrayPrototype, {
        lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }
            var i = length - 1;
            if (arguments.length > 1) {
                i = min(i, ES.ToInteger(arguments[1]));
            }
            // handle negative indices
            i = i >= 0 ? i : length - abs(i);
            for (; i >= 0; i--) {
                if (i in self && searchElement === self[i]) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2LastIndexOfBug);

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.12
    var spliceNoopReturnsEmptyArray = (function () {
        var a = [1, 2];
        var result = a.splice();
        return a.length === 2 && isArray(result) && result.length === 0;
    }());
    defineProperties(ArrayPrototype, {
        // Safari 5.0 bug where .splice() returns undefined
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            }
            return array_splice.apply(this, arguments);

        }
    }, !spliceNoopReturnsEmptyArray);

    var spliceWorksWithEmptyObject = (function () {
        var obj = {};
        ArrayPrototype.splice.call(obj, 0, 0, 1);
        return obj.length === 1;
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            }
            var args = arguments;
            this.length = max(ES.ToInteger(this.length), 0);
            if (arguments.length > 0 && typeof deleteCount !== 'number') {
                args = arraySlice(arguments);
                if (args.length < 2) {
                    pushCall(args, this.length - start);
                } else {
                    args[1] = ES.ToInteger(deleteCount);
                }
            }
            return array_splice.apply(this, args);
        }
    }, !spliceWorksWithEmptyObject);
    var spliceWorksWithLargeSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
        var arr = new $Array(1e5);
        // note: the index MUST be 8 or larger or the test will false pass
        arr[8] = 'x';
        arr.splice(1, 1);
        // note: this test must be defined *after* the indexOf shim
        // per https://github.com/es-shims/es5-shim/issues/313
        return arr.indexOf('x') === 7;
    }());
    var spliceWorksWithSmallSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Opera 12.15 breaks on this, no idea why.
        var n = 256;
        var arr = [];
        arr[n] = 'a';
        arr.splice(n + 1, 0, 'b');
        return arr[n] === 'a';
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            var O = ES.ToObject(this);
            var A = [];
            var len = ES.ToUint32(O.length);
            var relativeStart = ES.ToInteger(start);
            var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
            var actualDeleteCount = arguments.length === 0
                ? 0
                : arguments.length === 1
                    ? len - actualStart
                    : min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

            var k = 0;
            var from;
            while (k < actualDeleteCount) {
                from = $String(actualStart + k);
                if (owns(O, from)) {
                    A[k] = O[from];
                }
                k += 1;
            }

            var items = arraySlice(arguments, 2);
            var itemCount = items.length;
            var to;
            if (itemCount < actualDeleteCount) {
                k = actualStart;
                var maxK = len - actualDeleteCount;
                while (k < maxK) {
                    from = $String(k + actualDeleteCount);
                    to = $String(k + itemCount);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k += 1;
                }
                k = len;
                var minK = len - actualDeleteCount + itemCount;
                while (k > minK) {
                    delete O[k - 1];
                    k -= 1;
                }
            } else if (itemCount > actualDeleteCount) {
                k = len - actualDeleteCount;
                while (k > actualStart) {
                    from = $String(k + actualDeleteCount - 1);
                    to = $String(k + itemCount - 1);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k -= 1;
                }
            }
            k = actualStart;
            for (var i = 0; i < items.length; ++i) {
                O[k] = items[i];
                k += 1;
            }
            O.length = len - actualDeleteCount + itemCount;

            return A;
        }
    }, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

    var originalJoin = ArrayPrototype.join;
    var hasStringJoinBug;
    try {
        hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
    } catch (e) {
        hasStringJoinBug = true;
    }
    if (hasStringJoinBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
            }
        }, hasStringJoinBug);
    }

    var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
    if (hasJoinUndefinedBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(this, sep);
            }
        }, hasJoinUndefinedBug);
    }

    var pushShim = function push(item) {
        var O = ES.ToObject(this);
        var n = ES.ToUint32(O.length);
        var i = 0;
        while (i < arguments.length) {
            O[n + i] = arguments[i];
            i += 1;
        }
        O.length = n + i;
        return n + i;
    };

    var pushIsNotGeneric = (function () {
        var obj = {};
        var result = Array.prototype.push.call(obj, undefined);
        return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
    }());
    defineProperties(ArrayPrototype, {
        push: function push(item) {
            if (isArray(this)) {
                return array_push.apply(this, arguments);
            }
            return pushShim.apply(this, arguments);
        }
    }, pushIsNotGeneric);

    // This fixes a very weird bug in Opera 10.6 when pushing `undefined
    var pushUndefinedIsWeird = (function () {
        var arr = [];
        var result = arr.push(undefined);
        return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
    }());
    defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);

    // ES5 15.2.3.14
    // http://es5.github.io/#x15.4.4.10
    // Fix boxed string bug
    defineProperties(ArrayPrototype, {
        slice: function (start, end) {
            var arr = isString(this) ? strSplit(this, '') : this;
            return arraySliceApply(arr, arguments);
        }
    }, splitString);

    var sortIgnoresNonFunctions = (function () {
        try {
            [1, 2].sort(null);
        } catch (e) {
            try {
                [1, 2].sort({});
            } catch (e2) {
                return false;
            }
        }
        return true;
    }());
    var sortThrowsOnRegex = (function () {
        // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
        try {
            [1, 2].sort(/a/);
            return false;
        } catch (e) {}
        return true;
    }());
    var sortIgnoresUndefined = (function () {
        // applies in IE 8, for one.
        try {
            [1, 2].sort(undefined);
            return true;
        } catch (e) {}
        return false;
    }());
    defineProperties(ArrayPrototype, {
        sort: function sort(compareFn) {
            if (typeof compareFn === 'undefined') {
                return arraySort(this);
            }
            if (!isCallable(compareFn)) {
                throw new TypeError('Array.prototype.sort callback must be a function');
            }
            return arraySort(this, compareFn);
        }
    }, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);

    //
    // Object
    // ======
    //

    // ES5 15.2.3.14
    // http://es5.github.com/#x15.2.3.14

    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    // eslint-disable-next-line quote-props
    var hasDontEnumBug = !isEnum({ 'toString': null }, 'toString'); // jscs:ignore disallowQuotedKeysInObjects
    var hasProtoEnumBug = isEnum(function () {}, 'prototype');
    var hasStringEnumBug = !owns('x', '0');
    var equalsConstructorPrototype = function (o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true,

        $width: true,
        $height: true,
        $top: true,
        $localStorage: true
    };
    var hasAutomationEqualityBug = (function () {
        /* globals window */
        if (typeof window === 'undefined') {
            return false;
        }
        for (var k in window) {
            try {
                if (!excludedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
                    equalsConstructorPrototype(window[k]);
                }
            } catch (e) {
                return true;
            }
        }
        return false;
    }());
    var equalsConstructorPrototypeIfNotBuggy = function (object) {
        if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(object);
        }
        try {
            return equalsConstructorPrototype(object);
        } catch (e) {
            return false;
        }
    };
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var dontEnumsLength = dontEnums.length;

    // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
    // can be replaced with require('is-arguments') if we ever use a build process instead
    var isStandardArguments = function isArguments(value) {
        return toStr(value) === '[object Arguments]';
    };
    var isLegacyArguments = function isArguments(value) {
        return value !== null
            && typeof value === 'object'
            && typeof value.length === 'number'
            && value.length >= 0
            && !isArray(value)
            && isCallable(value.callee);
    };
    var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

    defineProperties($Object, {
        keys: function keys(object) {
            var isFn = isCallable(object);
            var isArgs = isArguments(object);
            var isObject = object !== null && typeof object === 'object';
            var isStr = isObject && isString(object);

            if (!isObject && !isFn && !isArgs) {
                throw new TypeError('Object.keys called on a non-object');
            }

            var theKeys = [];
            var skipProto = hasProtoEnumBug && isFn;
            if ((isStr && hasStringEnumBug) || isArgs) {
                for (var i = 0; i < object.length; ++i) {
                    pushCall(theKeys, $String(i));
                }
            }

            if (!isArgs) {
                for (var name in object) {
                    if (!(skipProto && name === 'prototype') && owns(object, name)) {
                        pushCall(theKeys, $String(name));
                    }
                }
            }

            if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                for (var j = 0; j < dontEnumsLength; j++) {
                    var dontEnum = dontEnums[j];
                    if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
                        pushCall(theKeys, dontEnum);
                    }
                }
            }
            return theKeys;
        }
    });

    var keysWorksWithArguments = $Object.keys && (function () {
        // Safari 5.0 bug
        return $Object.keys(arguments).length === 2;
    }(1, 2));
    var keysHasArgumentsLengthBug = $Object.keys && (function () {
        var argKeys = $Object.keys(arguments);
        return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
    }(1));
    var originalKeys = $Object.keys;
    defineProperties($Object, {
        keys: function keys(object) {
            if (isArguments(object)) {
                return originalKeys(arraySlice(object));
            }
            return originalKeys(object);

        }
    }, !keysWorksWithArguments || keysHasArgumentsLengthBug);

    //
    // Date
    // ====
    //

    var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
    var aNegativeTestDate = new Date(-1509842289600292);
    var aPositiveTestDate = new Date(1449662400000);
    var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
    var hasToDateStringFormatBug;
    var hasToStringFormatBug;
    var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
    if (timeZoneOffset < -720) {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
        hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/).test(String(aPositiveTestDate));
    } else {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
        hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/).test(String(aPositiveTestDate));
    }

    var originalGetFullYear = call.bind(Date.prototype.getFullYear);
    var originalGetMonth = call.bind(Date.prototype.getMonth);
    var originalGetDate = call.bind(Date.prototype.getDate);
    var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
    var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
    var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
    var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
    var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
    var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
    var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
    var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
    var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var daysInMonth = function daysInMonth(month, year) {
        return originalGetDate(new Date(year, month, 0));
    };

    defineProperties(Date.prototype, {
        getFullYear: function getFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            if (year < 0 && originalGetMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getMonth: function getMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getDate: function getDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            var date = originalGetDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        },
        getUTCFullYear: function getUTCFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            if (year < 0 && originalGetUTCMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getUTCMonth: function getUTCMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getUTCDate: function getUTCDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            var date = originalGetUTCDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        }
    }, hasNegativeMonthYearBug);

    defineProperties(Date.prototype, {
        toUTCString: function toUTCString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = originalGetUTCDay(this);
            var date = originalGetUTCDate(this);
            var month = originalGetUTCMonth(this);
            var year = originalGetUTCFullYear(this);
            var hour = originalGetUTCHours(this);
            var minute = originalGetUTCMinutes(this);
            var second = originalGetUTCSeconds(this);
            return dayName[day] + ', '
                + (date < 10 ? '0' + date : date) + ' '
                + monthName[month] + ' '
                + year + ' '
                + (hour < 10 ? '0' + hour : hour) + ':'
                + (minute < 10 ? '0' + minute : minute) + ':'
                + (second < 10 ? '0' + second : second) + ' GMT';
        }
    }, hasNegativeMonthYearBug || hasToUTCStringFormatBug);

    // Opera 12 has `,`
    defineProperties(Date.prototype, {
        toDateString: function toDateString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            return dayName[day] + ' '
                + monthName[month] + ' '
                + (date < 10 ? '0' + date : date) + ' '
                + year;
        }
    }, hasNegativeMonthYearBug || hasToDateStringFormatBug);

    // can't use defineProperties here because of toString enumeration issue in IE <= 8
    if (hasNegativeMonthYearBug || hasToStringFormatBug) {
        Date.prototype.toString = function toString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            var hour = this.getHours();
            var minute = this.getMinutes();
            var second = this.getSeconds();
            var timezoneOffset = this.getTimezoneOffset();
            var hoursOffset = floor(abs(timezoneOffset) / 60);
            var minutesOffset = floor(abs(timezoneOffset) % 60);
            return dayName[day] + ' '
                + monthName[month] + ' '
                + (date < 10 ? '0' + date : date) + ' '
                + year + ' '
                + (hour < 10 ? '0' + hour : hour) + ':'
                + (minute < 10 ? '0' + minute : minute) + ':'
                + (second < 10 ? '0' + second : second) + ' GMT'
                + (timezoneOffset > 0 ? '-' : '+')
                + (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset)
                + (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
        };
        if (supportsDescriptors) {
            $Object.defineProperty(Date.prototype, 'toString', {
                configurable: true,
                enumerable: false,
                writable: true
            });
        }
    }

    // ES5 15.9.5.43
    // http://es5.github.com/#x15.9.5.43
    // This function returns a String value represent the instance in time
    // represented by this Date object. The format of the String is the Date Time
    // string format defined in 15.9.1.15. All fields are present in the String.
    // The time zone is always UTC, denoted by the suffix Z. If the time value of
    // this object is not a finite Number a RangeError exception is thrown.
    var negativeDate = -62198755200000;
    var negativeYearString = '-000001';
    var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1; // eslint-disable-line max-len
    var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

    var getTime = call.bind(Date.prototype.getTime);

    defineProperties(Date.prototype, {
        toISOString: function toISOString() {
            if (!isFinite(this) || !isFinite(getTime(this))) {
                // Adope Photoshop requires the second check.
                throw new RangeError('Date.prototype.toISOString called on non-finite value.');
            }

            var year = originalGetUTCFullYear(this);

            var month = originalGetUTCMonth(this);
            // see https://github.com/es-shims/es5-shim/issues/111
            year += floor(month / 12);
            month = ((month % 12) + 12) % 12;

            // the date time string format is specified in 15.9.1.15.
            var result = [
                month + 1,
                originalGetUTCDate(this),
                originalGetUTCHours(this),
                originalGetUTCMinutes(this),
                originalGetUTCSeconds(this)
            ];
            year = (
                (year < 0 ? '-' : (year > 9999 ? '+' : ''))
                + strSlice('00000' + abs(year), (0 <= year && year <= 9999) ? -4 : -6)
            );

            for (var i = 0; i < result.length; ++i) {
                // pad months, days, hours, minutes, and seconds to have two digits.
                result[i] = strSlice('00' + result[i], -2);
            }
            // pad milliseconds to have three digits.
            return (
                year + '-' + arraySlice(result, 0, 2).join('-')
                + 'T' + arraySlice(result, 2).join(':') + '.'
                + strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
            );
        }
    }, hasNegativeDateBug || hasSafari51DateBug);

    // ES5 15.9.5.44
    // http://es5.github.com/#x15.9.5.44
    // This function provides a String representation of a Date object for use by
    // JSON.stringify (15.12.3).
    var dateToJSONIsSupported = (function () {
        try {
            return Date.prototype.toJSON
                && new Date(NaN).toJSON() === null
                && new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1
                && Date.prototype.toJSON.call({ // generic
                    toISOString: function () { return true; }
                });
        } catch (e) {
            return false;
        }
    }());
    if (!dateToJSONIsSupported) {
        Date.prototype.toJSON = function toJSON(key) {
            // When the toJSON method is called with argument key, the following
            // steps are taken:

            // 1.  Let O be the result of calling ToObject, giving it the this
            // value as its argument.
            // 2. Let tv be ES.ToPrimitive(O, hint Number).
            var O = $Object(this);
            var tv = ES.ToPrimitive(O);
            // 3. If tv is a Number and is not finite, return null.
            if (typeof tv === 'number' && !isFinite(tv)) {
                return null;
            }
            // 4. Let toISO be the result of calling the [[Get]] internal method of
            // O with argument "toISOString".
            var toISO = O.toISOString;
            // 5. If IsCallable(toISO) is false, throw a TypeError exception.
            if (!isCallable(toISO)) {
                throw new TypeError('toISOString property is not callable');
            }
            // 6. Return the result of calling the [[Call]] internal method of
            //  toISO with O as the this value and an empty argument list.
            return toISO.call(O);

            // NOTE 1 The argument is ignored.

            // NOTE 2 The toJSON function is intentionally generic; it does not
            // require that its this value be a Date object. Therefore, it can be
            // transferred to other kinds of objects for use as a method. However,
            // it does require that any such object have a toISOString method. An
            // object is free to use the argument key to filter its
            // stringification.
        };
    }

    // ES5 15.9.4.2
    // http://es5.github.com/#x15.9.4.2
    // based on work shared by Daniel Friesen (dantman)
    // http://gist.github.com/303249
    var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
    var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
    var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
    if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
        // XXX global assignment won't work in embeddings that use
        // an alternate object for the context.
        var maxSafeUnsigned32Bit = pow(2, 31) - 1;
        var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
        // eslint-disable-next-line no-implicit-globals, no-global-assign
        Date = (function (NativeDate) {
            // Date.length === 7
            var DateShim = function Date(Y, M, D, h, m, s, ms) {
                var length = arguments.length;
                var date;
                if (this instanceof NativeDate) {
                    var seconds = s;
                    var millis = ms;
                    if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
                        // work around a Safari 8/9 bug where it treats the seconds as signed
                        var msToShift = floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                        var sToShift = floor(msToShift / 1e3);
                        seconds += sToShift;
                        millis -= sToShift * 1e3;
                    }
                    date = length === 1 && $String(Y) === Y // isString(Y)
                        // We explicitly pass it through parse:
                        ? new NativeDate(DateShim.parse(Y))
                        // We have to manually make calls depending on argument
                        // length here
                        : length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis)
                            : length >= 6 ? new NativeDate(Y, M, D, h, m, seconds)
                                : length >= 5 ? new NativeDate(Y, M, D, h, m)
                                    : length >= 4 ? new NativeDate(Y, M, D, h)
                                        : length >= 3 ? new NativeDate(Y, M, D)
                                            : length >= 2 ? new NativeDate(Y, M)
                                                : length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y)
                                                    : new NativeDate();
                } else {
                    date = NativeDate.apply(this, arguments);
                }
                if (!isPrimitive(date)) {
                    // Prevent mixups with unfixed Date object
                    defineProperties(date, { constructor: DateShim }, true);
                }
                return date;
            };

            // 15.9.1.15 Date Time String Format.
            var isoDateExpression = new RegExp('^'
                + '(\\d{4}|[+-]\\d{6})' // four-digit year capture or sign + 6-digit extended year
                + '(?:-(\\d{2})' // optional month capture
                + '(?:-(\\d{2})' // optional day capture
                + '(?:' // capture hours:minutes:seconds.milliseconds
                    + 'T(\\d{2})' // hours capture
                    + ':(\\d{2})' // minutes capture
                    + '(?:' // optional :seconds.milliseconds
                        + ':(\\d{2})' // seconds capture
                        + '(?:(\\.\\d{1,}))?' // milliseconds capture
                    + ')?'
                + '(' // capture UTC offset component
                    + 'Z|' // UTC capture
                    + '(?:' // offset specifier +/-hours:minutes
                        + '([-+])' // sign capture
                        + '(\\d{2})' // hours offset capture
                        + ':(\\d{2})' // minutes offset capture
                    + ')'
                + ')?)?)?)?'
            + '$');

            var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

            var dayFromMonth = function dayFromMonth(year, month) {
                var t = month > 1 ? 1 : 0;
                return (
                    months[month]
                    + floor((year - 1969 + t) / 4)
                    - floor((year - 1901 + t) / 100)
                    + floor((year - 1601 + t) / 400)
                    + (365 * (year - 1970))
                );
            };

            var toUTC = function toUTC(t) {
                var s = 0;
                var ms = t;
                if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
                    // work around a Safari 8/9 bug where it treats the seconds as signed
                    var msToShift = floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                    var sToShift = floor(msToShift / 1e3);
                    s += sToShift;
                    ms -= sToShift * 1e3;
                }
                return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
            };

            // Copy any custom methods a 3rd party library may have added
            for (var key in NativeDate) {
                if (owns(NativeDate, key)) {
                    DateShim[key] = NativeDate[key];
                }
            }

            // Copy "native" methods explicitly; they may be non-enumerable
            defineProperties(DateShim, {
                now: NativeDate.now,
                UTC: NativeDate.UTC
            }, true);
            DateShim.prototype = NativeDate.prototype;
            defineProperties(DateShim.prototype, { constructor: DateShim }, true);

            // Upgrade Date.parse to handle simplified ISO 8601 strings
            var parseShim = function parse(string) {
                var match = isoDateExpression.exec(string);
                if (match) {
                    // parse months, days, hours, minutes, seconds, and milliseconds
                    // provide default values if necessary
                    // parse the UTC offset component
                    var year = $Number(match[1]),
                        month = $Number(match[2] || 1) - 1,
                        day = $Number(match[3] || 1) - 1,
                        hour = $Number(match[4] || 0),
                        minute = $Number(match[5] || 0),
                        second = $Number(match[6] || 0),
                        millisecond = floor($Number(match[7] || 0) * 1000),
                        // When time zone is missed, local offset should be used
                        // (ES 5.1 bug)
                        // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                        isLocalTime = Boolean(match[4] && !match[8]),
                        signOffset = match[9] === '-' ? 1 : -1,
                        hourOffset = $Number(match[10] || 0),
                        minuteOffset = $Number(match[11] || 0),
                        result;
                    var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
                    if (
                        hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25)
                        && minute < 60 && second < 60 && millisecond < 1000
                        && month > -1 && month < 12 && hourOffset < 24
                        && minuteOffset < 60 // detect invalid offsets
                        && day > -1
                        && day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
                    ) {
                        result = (
                            ((dayFromMonth(year, month) + day) * 24)
                            + hour
                            + (hourOffset * signOffset)
                        ) * 60;
                        result = ((
                            ((result + minute + (minuteOffset * signOffset)) * 60)
                            + second
                        ) * 1000) + millisecond;
                        if (isLocalTime) {
                            result = toUTC(result);
                        }
                        if (-8.64e15 <= result && result <= 8.64e15) {
                            return result;
                        }
                    }
                    return NaN;
                }
                return NativeDate.parse.apply(this, arguments);
            };
            defineProperties(DateShim, { parse: parseShim });

            return DateShim;
        }(Date));
    }

    // ES5 15.9.4.4
    // http://es5.github.com/#x15.9.4.4
    if (!Date.now) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }

    //
    // Number
    // ======
    //

    // ES5.1 15.7.4.5
    // http://es5.github.com/#x15.7.4.5
    var hasToFixedBugs = NumberPrototype.toFixed && (
        (0.00008).toFixed(3) !== '0.000'
        || (0.9).toFixed(0) !== '1'
        || (1.255).toFixed(2) !== '1.25'
        || (1000000000000000128).toFixed(0) !== '1000000000000000128'
    );

    var toFixedHelpers = {
        base: 1e7,
        size: 6,
        data: [0, 0, 0, 0, 0, 0],
        multiply: function multiply(n, c) {
            var i = -1;
            var c2 = c;
            while (++i < toFixedHelpers.size) {
                c2 += n * toFixedHelpers.data[i];
                toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
                c2 = floor(c2 / toFixedHelpers.base);
            }
        },
        divide: function divide(n) {
            var i = toFixedHelpers.size;
            var c = 0;
            while (--i >= 0) {
                c += toFixedHelpers.data[i];
                toFixedHelpers.data[i] = floor(c / n);
                c = (c % n) * toFixedHelpers.base;
            }
        },
        numToString: function numToString() {
            var i = toFixedHelpers.size;
            var s = '';
            while (--i >= 0) {
                if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
                    var t = $String(toFixedHelpers.data[i]);
                    if (s === '') {
                        s = t;
                    } else {
                        s += strSlice('0000000', 0, 7 - t.length) + t;
                    }
                }
            }
            return s;
        },
        pow: function pow(x, n, acc) {
            return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
        },
        log: function log(x) {
            var n = 0;
            var x2 = x;
            while (x2 >= 4096) {
                n += 12;
                x2 /= 4096;
            }
            while (x2 >= 2) {
                n += 1;
                x2 /= 2;
            }
            return n;
        }
    };

    var toFixedShim = function toFixed(fractionDigits) {
        var f, x, s, m, e, z, j, k;

        // Test for NaN and round fractionDigits down
        f = $Number(fractionDigits);
        f = isActualNaN(f) ? 0 : floor(f);

        if (f < 0 || f > 20) {
            throw new RangeError('Number.toFixed called with invalid number of decimals');
        }

        x = $Number(this);

        if (isActualNaN(x)) {
            return 'NaN';
        }

        // If it is too big or small, return the string value of the number
        if (x <= -1e21 || x >= 1e21) {
            return $String(x);
        }

        s = '';

        if (x < 0) {
            s = '-';
            x = -x;
        }

        m = '0';

        if (x > 1e-21) {
            // 1e-21 < x < 1e21
            // -70 < log2(x) < 70
            e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
            z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
            z *= 0x10000000000000; // pow(2, 52);
            e = 52 - e;

            // -18 < e < 122
            // x = z / 2 ^ e
            if (e > 0) {
                toFixedHelpers.multiply(0, z);
                j = f;

                while (j >= 7) {
                    toFixedHelpers.multiply(1e7, 0);
                    j -= 7;
                }

                toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
                j = e - 1;

                while (j >= 23) {
                    toFixedHelpers.divide(1 << 23);
                    j -= 23;
                }

                toFixedHelpers.divide(1 << j);
                toFixedHelpers.multiply(1, 1);
                toFixedHelpers.divide(2);
                m = toFixedHelpers.numToString();
            } else {
                toFixedHelpers.multiply(0, z);
                toFixedHelpers.multiply(1 << (-e), 0);
                m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
            }
        }

        if (f > 0) {
            k = m.length;

            if (k <= f) {
                m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
            } else {
                m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
            }
        } else {
            m = s + m;
        }

        return m;
    };
    defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

    var hasToExponentialRoundingBug = (function () {
        try {
            return (-6.9e-11).toExponential(4) !== '-6.9000e-11';
        } catch (e) {
            return false;
        }
    }());
    var toExponentialAllowsInfiniteDigits = (function () {
        try {
            (1).toExponential(Infinity);
            (1).toExponential(-Infinity);
            return true;
        } catch (e) {
            return false;
        }
    }());
    var originalToExponential = call.bind(NumberPrototype.toExponential);
    var numberToString = call.bind(NumberPrototype.toString);
    defineProperties(NumberPrototype, {
        toExponential: function toExponential(fractionDigits) {
            // 1: Let x be this Number value.
            var x = $Number(this);

            if (typeof fractionDigits === 'undefined') {
                return originalToExponential(x);
            }
            var f = ES.ToInteger(fractionDigits);
            if (isActualNaN(x)) {
                return 'NaN';
            }

            if (f < 0 || f > 20) {
                // this will probably have thrown already
                return originalToExponential(x, f);
            }

            // only cases left are a finite receiver + in-range fractionDigits

            // implementation adapted from https://gist.github.com/SheetJSDev/1100ad56b9f856c95299ed0e068eea08

            // 4: Let s be the empty string
            var s = '';

            // 5: If x < 0
            if (x < 0) {
                s = '-';
                x = -x;
            }

            // 6: If x = +Infinity
            if (x === Infinity) {
                return s + 'Infinity';
            }

            // 7: If fractionDigits is not undefined and (f < 0 or f > 20), throw a RangeError exception.
            if (typeof fractionDigits !== 'undefined' && (f < 0 || f > 20)) {
                throw new RangeError('Fraction digits ' + fractionDigits + ' out of range');
            }

            var m = '';
            var e = 0;
            var c = '';
            var d = '';

            // 8: If x = 0 then
            if (x === 0) {
                e = 0;
                f = 0;
                m = '0';
            } else { // 9: Else, x != 0
                var L = log10(x);
                e = floor(L); // 10 ** e <= x and x < 10 ** (e+1)
                var n = 0;
                if (typeof fractionDigits !== 'undefined') { // eslint-disable-line no-negated-condition
                    var w = pow(10, e - f); // x / 10 ** (f+1) < w and w <= x / 10 ** f
                    n = round(x / w); // 10 ** f <= n and n < 10 ** (f+1)
                    if (2 * x >= (((2 * n) + 1) * w)) {
                        n += 1; // pick larger value
                    }
                    if (n >= pow(10, f + 1)) { // 10e-1 = 1e0
                        n /= 10;
                        e += 1;
                    }
                } else {
                    f = 16; // start from Math.ceil(Math.log10(Number.MAX_SAFE_INTEGER)) and loop down
                    var guess_n = round(pow(10, L - e + f));
                    var target_f = f;
                    while (f-- > 0) {
                        guess_n = round(pow(10, L - e + f));
                        if (
                            abs((guess_n * pow(10, e - f)) - x)
                            <= abs((n * pow(10, e - target_f)) - x)
                        ) {
                            target_f = f;
                            n = guess_n;
                        }
                    }
                }
                m = numberToString(n, 10);
                if (typeof fractionDigits === 'undefined') {
                    while (strSlice(m, -1) === '0') {
                        m = strSlice(m, 0, -1);
                        d += 1;
                    }
                }
            }

            // 10: If f != 0, then
            if (f !== 0) {
                m = strSlice(m, 0, 1) + '.' + strSlice(m, 1);
            }

            // 11: If e = 0, then
            if (e === 0) {
                c = '+';
                d = '0';
            } else { // 12: Else
                c = e > 0 ? '+' : '-';
                d = numberToString(abs(e), 10);
            }

            // 13: Let m be the concatenation of the four Strings m, "e", c, and d.
            m += 'e' + c + d;

            // 14: Return the concatenation of the Strings s and m.
            return s + m;
        }
    }, hasToExponentialRoundingBug || toExponentialAllowsInfiniteDigits);

    var hasToPrecisionUndefinedBug = (function () {
        try {
            return 1.0.toPrecision(undefined) === '1';
        } catch (e) {
            return true;
        }
    }());
    var originalToPrecision = call.bind(NumberPrototype.toPrecision);
    defineProperties(NumberPrototype, {
        toPrecision: function toPrecision(precision) {
            return typeof precision === 'undefined' ? originalToPrecision(this) : originalToPrecision(this, precision);
        }
    }, hasToPrecisionUndefinedBug);

    //
    // String
    // ======
    //

    // ES5 15.5.4.14
    // http://es5.github.com/#x15.5.4.14

    // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
    // Many browsers do not split properly with regular expressions or they
    // do not perform the split correctly under obscure conditions.
    // See http://blog.stevenlevithan.com/archives/cross-browser-split
    // I've tested in many browsers and this seems to cover the deviant ones:
    //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
    //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
    //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
    //       [undefined, "t", undefined, "e", ...]
    //    ''.split(/.?/) should be [], not [""]
    //    '.'.split(/()()/) should be ["."], not ["", "", "."]

    if (
        'ab'.split(/(?:ab)*/).length !== 2
        || '.'.split(/(.?)(.?)/).length !== 4
        || 'tesst'.split(/(s)*/)[1] === 't'
        || 'test'.split(/(?:)/, -1).length !== 4
        || ''.split(/.?/).length
        || '.'.split(/()()/).length > 1
    ) {
        (function () {
            var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
            var maxSafe32BitInt = pow(2, 32) - 1;

            StringPrototype.split = function split(separator, limit) {
                var string = String(this);
                if (typeof separator === 'undefined' && limit === 0) {
                    return [];
                }

                // If `separator` is not a regex, use native split
                if (!isRegex(separator)) {
                    return strSplit(this, separator, limit);
                }

                var output = [];
                var flags = (separator.ignoreCase ? 'i' : '')
                            + (separator.multiline ? 'm' : '')
                            + (separator.unicode ? 'u' : '') // in ES6
                            + (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
                    lastLastIndex = 0,
                    // Make `global` and avoid `lastIndex` issues by working with a copy
                    separator2, match, lastIndex, lastLength;
                var separatorCopy = new RegExp(separator.source, flags + 'g');
                if (!compliantExecNpcg) {
                    // Doesn't need flags gy, but they don't hurt
                    separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
                }
                /* Values for `limit`, per the spec:
                 * If undefined: 4294967295 // maxSafe32BitInt
                 * If 0, Infinity, or NaN: 0
                 * If positive number: limit = floor(limit); if (limit > 4294967295) limit -= 4294967296;
                 * If negative number: 4294967296 - floor(abs(limit))
                 * If other: Type-convert, then use the above rules
                 */
                var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
                match = separatorCopy.exec(string);
                while (match) {
                    // `separatorCopy.lastIndex` is not reliable cross-browser
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        pushCall(output, strSlice(string, lastLastIndex, match.index));
                        // Fix browsers whose `exec` methods don't consistently return `undefined` for
                        // nonparticipating capturing groups
                        if (!compliantExecNpcg && match.length > 1) {
                            /* eslint-disable no-loop-func */
                            match[0].replace(separator2, function () {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (typeof arguments[i] === 'undefined') {
                                        match[i] = void 0;
                                    }
                                }
                            });
                            /* eslint-enable no-loop-func */
                        }
                        if (match.length > 1 && match.index < string.length) {
                            array_push.apply(output, arraySlice(match, 1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= splitLimit) {
                            break;
                        }
                    }
                    if (separatorCopy.lastIndex === match.index) {
                        separatorCopy.lastIndex++; // Avoid an infinite loop
                    }
                    match = separatorCopy.exec(string);
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separatorCopy.test('')) {
                        pushCall(output, '');
                    }
                } else {
                    pushCall(output, strSlice(string, lastLastIndex));
                }
                return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
            };
        }());

    // [bugfix, chrome]
    // If separator is undefined, then the result array contains just one String,
    // which is the this value (converted to a String). If limit is not undefined,
    // then the output array is truncated so that it contains no more than limit
    // elements.
    // "0".split(undefined, 0) -> []
    } else if ('0'.split(void 0, 0).length) {
        StringPrototype.split = function split(separator, limit) {
            if (typeof separator === 'undefined' && limit === 0) {
                return [];
            }
            return strSplit(this, separator, limit);
        };
    }

    var str_replace = StringPrototype.replace;
    var replaceReportsGroupsCorrectly = (function () {
        var groups = [];
        'x'.replace(/x(.)?/g, function (match, group) {
            pushCall(groups, group);
        });
        return groups.length === 1 && typeof groups[0] === 'undefined';
    }());

    if (!replaceReportsGroupsCorrectly) {
        StringPrototype.replace = function replace(searchValue, replaceValue) {
            var isFn = isCallable(replaceValue);
            var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
            if (!isFn || !hasCapturingGroups) {
                return str_replace.call(this, searchValue, replaceValue);
            }
            var wrappedReplaceValue = function (match) {
                var length = arguments.length;
                var originalLastIndex = searchValue.lastIndex;
                searchValue.lastIndex = 0; // eslint-disable-line no-param-reassign
                var args = searchValue.exec(match) || [];
                searchValue.lastIndex = originalLastIndex; // eslint-disable-line no-param-reassign
                pushCall(args, arguments[length - 2], arguments[length - 1]);
                return replaceValue.apply(this, args);
            };
            return str_replace.call(this, searchValue, wrappedReplaceValue);

        };
    }

    // ECMA-262, 3rd B.2.3
    // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
    // non-normative section suggesting uniform semantics and it should be
    // normalized across all browsers
    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
    var string_substr = StringPrototype.substr;
    var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
    defineProperties(StringPrototype, {
        substr: function substr(start, length) {
            var normalizedStart = start;
            if (start < 0) {
                normalizedStart = max(this.length + start, 0);
            }
            return string_substr.call(this, normalizedStart, length);
        }
    }, hasNegativeSubstrBug);

    // ES5 15.5.4.20
    // whitespace from: http://es5.github.io/#x15.5.4.20
    var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003'
        + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028'
        + '\u2029\uFEFF';
    var zeroWidth = '\u200b';
    var wsRegexChars = '[' + ws + ']';
    var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
    var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
    var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
    defineProperties(StringPrototype, {
        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
        // http://perfectionkills.com/whitespace-deviations/
        trim: function trim() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
        }
    }, hasTrimWhitespaceBug);
    var trim = call.bind(String.prototype.trim);

    var hasLastIndexBug = StringPrototype.lastIndexOf && 'abc'.lastIndexOf('', 2) !== -1;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var S = $String(this);
            var searchStr = $String(searchString);
            var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
            var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
            var start = min(max(pos, 0), S.length);
            var searchLen = searchStr.length;
            var k = start + searchLen;
            while (k > 0) {
                k = max(0, k - searchLen);
                var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
                if (index !== -1) {
                    return k + index;
                }
            }
            return -1;
        }
    }, hasLastIndexBug);

    var originalLastIndexOf = StringPrototype.lastIndexOf;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            return originalLastIndexOf.apply(this, arguments);
        }
    }, StringPrototype.lastIndexOf.length !== 1);

    var hexRegex = /^[-+]?0[xX]/;

    // ES-5 15.1.2.2
    // eslint-disable-next-line radix
    if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
        // eslint-disable-next-line no-global-assign, no-implicit-globals
        parseInt = (function (origParseInt) {
            return function parseInt(str, radix) {
                var string = trim(String(str));
                var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
                return origParseInt(string, defaultedRadix);
            };
        }(parseInt));
    }
    // Edge 15-18
    var parseIntFailsToThrowOnBoxedSymbols = (function () {
        if (typeof Symbol !== 'function') {
            return false;
        }
        try {
            // eslint-disable-next-line radix
            parseInt(Object(Symbol.iterator));
            return true;
        } catch (e) { /**/ }

        try {
            // eslint-disable-next-line radix
            parseInt(Symbol.iterator);
            return true;
        } catch (e) { /**/ }

        return false;
    }());
    if (parseIntFailsToThrowOnBoxedSymbols) {
        var symbolValueOf = Symbol.prototype.valueOf;
        // eslint-disable-next-line no-global-assign, no-implicit-globals
        parseInt = (function (origParseInt) {
            return function parseInt(str, radix) {
                var isSym = typeof str === 'symbol';
                if (!isSym && str && typeof str === 'object') {
                    try {
                        symbolValueOf.call(str);
                        isSym = true;
                    } catch (e) { /**/ }
                }
                if (isSym) {
                    // handle Symbols in node 8.3/8.4
                    // eslint-disable-next-line no-implicit-coercion, no-unused-expressions
                    '' + str; // jscs:ignore disallowImplicitTypeConversion
                }
                var string = trim(String(str));
                var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
                return origParseInt(string, defaultedRadix);
            };
        }(parseInt));
    }

    // https://es5.github.io/#x15.1.2.3
    if (1 / parseFloat('-0') !== -Infinity) {
        // eslint-disable-next-line no-global-assign, no-implicit-globals, no-native-reassign
        parseFloat = (function (origParseFloat) {
            return function parseFloat(string) {
                var inputString = trim(String(string));
                var result = origParseFloat(inputString);
                return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
            };
        }(parseFloat));
    }

    if (String(new RangeError('test')) !== 'RangeError: test') {
        var errorToStringShim = function toString() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var name = this.name;
            if (typeof name === 'undefined') {
                name = 'Error';
            } else if (typeof name !== 'string') {
                name = $String(name);
            }
            var msg = this.message;
            if (typeof msg === 'undefined') {
                msg = '';
            } else if (typeof msg !== 'string') {
                msg = $String(msg);
            }
            if (!name) {
                return msg;
            }
            if (!msg) {
                return name;
            }
            return name + ': ' + msg;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        Error.prototype.toString = errorToStringShim;
    }

    if (supportsDescriptors) {
        var ensureNonEnumerable = function (obj, prop) {
            if (isEnum(obj, prop)) {
                var desc = Object.getOwnPropertyDescriptor(obj, prop);
                if (desc.configurable) {
                    desc.enumerable = false;
                    Object.defineProperty(obj, prop, desc);
                }
            }
        };
        ensureNonEnumerable(Error.prototype, 'message');
        if (Error.prototype.message !== '') {
            Error.prototype.message = '';
        }
        ensureNonEnumerable(Error.prototype, 'name');
    }

    if (String(/a/mig) !== '/a/gim') {
        var regexToString = function toString() {
            var str = '/' + this.source + '/';
            if (this.global) {
                str += 'g';
            }
            if (this.ignoreCase) {
                str += 'i';
            }
            if (this.multiline) {
                str += 'm';
            }
            return str;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        RegExp.prototype.toString = regexToString;
    }
}));

},{}],29:[function(require,module,exports){
/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

(function (Hogan) {
  // Setup regex  assignments
  // remove whitespace according to Mustache spec
  var rIsWhitespace = /\S/,
      rQuot = /\"/g,
      rNewline =  /\n/g,
      rCr = /\r/g,
      rSlash = /\\/g,
      rLineSep = /\u2028/,
      rParagraphSep = /\u2029/;

  Hogan.tags = {
    '#': 1, '^': 2, '<': 3, '$': 4,
    '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,
    '{': 10, '&': 11, '_t': 12
  };

  Hogan.scan = function scan(text, delimiters) {
    var len = text.length,
        IN_TEXT = 0,
        IN_TAG_TYPE = 1,
        IN_TAG = 2,
        state = IN_TEXT,
        tagType = null,
        tag = null,
        buf = '',
        tokens = [],
        seenTag = false,
        i = 0,
        lineStart = 0,
        otag = '{{',
        ctag = '}}';

    function addBuf() {
      if (buf.length > 0) {
        tokens.push({tag: '_t', text: new String(buf)});
        buf = '';
      }
    }

    function lineIsWhitespace() {
      var isAllWhitespace = true;
      for (var j = lineStart; j < tokens.length; j++) {
        isAllWhitespace =
          (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||
          (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);
        if (!isAllWhitespace) {
          return false;
        }
      }

      return isAllWhitespace;
    }

    function filterLine(haveSeenTag, noNewLine) {
      addBuf();

      if (haveSeenTag && lineIsWhitespace()) {
        for (var j = lineStart, next; j < tokens.length; j++) {
          if (tokens[j].text) {
            if ((next = tokens[j+1]) && next.tag == '>') {
              // set indent to token value
              next.indent = tokens[j].text.toString()
            }
            tokens.splice(j, 1);
          }
        }
      } else if (!noNewLine) {
        tokens.push({tag:'\n'});
      }

      seenTag = false;
      lineStart = tokens.length;
    }

    function changeDelimiters(text, index) {
      var close = '=' + ctag,
          closeIndex = text.indexOf(close, index),
          delimiters = trim(
            text.substring(text.indexOf('=', index) + 1, closeIndex)
          ).split(' ');

      otag = delimiters[0];
      ctag = delimiters[delimiters.length - 1];

      return closeIndex + close.length - 1;
    }

    if (delimiters) {
      delimiters = delimiters.split(' ');
      otag = delimiters[0];
      ctag = delimiters[1];
    }

    for (i = 0; i < len; i++) {
      if (state == IN_TEXT) {
        if (tagChange(otag, text, i)) {
          --i;
          addBuf();
          state = IN_TAG_TYPE;
        } else {
          if (text.charAt(i) == '\n') {
            filterLine(seenTag);
          } else {
            buf += text.charAt(i);
          }
        }
      } else if (state == IN_TAG_TYPE) {
        i += otag.length - 1;
        tag = Hogan.tags[text.charAt(i + 1)];
        tagType = tag ? text.charAt(i + 1) : '_v';
        if (tagType == '=') {
          i = changeDelimiters(text, i);
          state = IN_TEXT;
        } else {
          if (tag) {
            i++;
          }
          state = IN_TAG;
        }
        seenTag = i;
      } else {
        if (tagChange(ctag, text, i)) {
          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                       i: (tagType == '/') ? seenTag - otag.length : i + ctag.length});
          buf = '';
          i += ctag.length - 1;
          state = IN_TEXT;
          if (tagType == '{') {
            if (ctag == '}}') {
              i++;
            } else {
              cleanTripleStache(tokens[tokens.length - 1]);
            }
          }
        } else {
          buf += text.charAt(i);
        }
      }
    }

    filterLine(seenTag, true);

    return tokens;
  }

  function cleanTripleStache(token) {
    if (token.n.substr(token.n.length - 1) === '}') {
      token.n = token.n.substring(0, token.n.length - 1);
    }
  }

  function trim(s) {
    if (s.trim) {
      return s.trim();
    }

    return s.replace(/^\s*|\s*$/g, '');
  }

  function tagChange(tag, text, index) {
    if (text.charAt(index) != tag.charAt(0)) {
      return false;
    }

    for (var i = 1, l = tag.length; i < l; i++) {
      if (text.charAt(index + i) != tag.charAt(i)) {
        return false;
      }
    }

    return true;
  }

  // the tags allowed inside super templates
  var allowedInSuper = {'_t': true, '\n': true, '$': true, '/': true};

  function buildTree(tokens, kind, stack, customTags) {
    var instructions = [],
        opener = null,
        tail = null,
        token = null;

    tail = stack[stack.length - 1];

    while (tokens.length > 0) {
      token = tokens.shift();

      if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {
        throw new Error('Illegal content in < super tag.');
      }

      if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {
        stack.push(token);
        token.nodes = buildTree(tokens, token.tag, stack, customTags);
      } else if (token.tag == '/') {
        if (stack.length === 0) {
          throw new Error('Closing tag without opener: /' + token.n);
        }
        opener = stack.pop();
        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
        }
        opener.end = token.i;
        return instructions;
      } else if (token.tag == '\n') {
        token.last = (tokens.length == 0) || (tokens[0].tag == '\n');
      }

      instructions.push(token);
    }

    if (stack.length > 0) {
      throw new Error('missing closing tag: ' + stack.pop().n);
    }

    return instructions;
  }

  function isOpener(token, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].o == token.n) {
        token.tag = '#';
        return true;
      }
    }
  }

  function isCloser(close, open, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].c == close && tags[i].o == open) {
        return true;
      }
    }
  }

  function stringifySubstitutions(obj) {
    var items = [];
    for (var key in obj) {
      items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
    }
    return "{ " + items.join(",") + " }";
  }

  function stringifyPartials(codeObj) {
    var partials = [];
    for (var key in codeObj.partials) {
      partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + "}");
    }
    return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
  }

  Hogan.stringify = function(codeObj, text, options) {
    return "{code: function (c,p,i) { " + Hogan.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) +  "}";
  }

  var serialNo = 0;
  Hogan.generate = function(tree, text, options) {
    serialNo = 0;
    var context = { code: '', subs: {}, partials: {} };
    Hogan.walk(tree, context);

    if (options.asString) {
      return this.stringify(context, text, options);
    }

    return this.makeTemplate(context, text, options);
  }

  Hogan.wrapMain = function(code) {
    return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
  }

  Hogan.template = Hogan.Template;

  Hogan.makeTemplate = function(codeObj, text, options) {
    var template = this.makePartials(codeObj);
    template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));
    return new this.template(template, text, this, options);
  }

  Hogan.makePartials = function(codeObj) {
    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
    for (key in template.partials) {
      template.partials[key] = this.makePartials(template.partials[key]);
    }
    for (key in codeObj.subs) {
      template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);
    }
    return template;
  }

  function esc(s) {
    return s.replace(rSlash, '\\\\')
            .replace(rQuot, '\\\"')
            .replace(rNewline, '\\n')
            .replace(rCr, '\\r')
            .replace(rLineSep, '\\u2028')
            .replace(rParagraphSep, '\\u2029');
  }

  function chooseMethod(s) {
    return (~s.indexOf('.')) ? 'd' : 'f';
  }

  function createPartial(node, context) {
    var prefix = "<" + (context.prefix || "");
    var sym = prefix + node.n + serialNo++;
    context.partials[sym] = {name: node.n, partials: {}};
    context.code += 't.b(t.rp("' +  esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
    return sym;
  }

  Hogan.codegen = {
    '#': function(node, context) {
      context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
                      'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + " " + node.ctag + '")){' +
                      't.rs(c,p,' + 'function(c,p,t){';
      Hogan.walk(node.nodes, context);
      context.code += '});c.pop();}';
    },

    '^': function(node, context) {
      context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
      Hogan.walk(node.nodes, context);
      context.code += '};';
    },

    '>': createPartial,
    '<': function(node, context) {
      var ctx = {partials: {}, code: '', subs: {}, inPartial: true};
      Hogan.walk(node.nodes, ctx);
      var template = context.partials[createPartial(node, context)];
      template.subs = ctx.subs;
      template.partials = ctx.partials;
    },

    '$': function(node, context) {
      var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};
      Hogan.walk(node.nodes, ctx);
      context.subs[node.n] = ctx.code;
      if (!context.inPartial) {
        context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
      }
    },

    '\n': function(node, context) {
      context.code += write('"\\n"' + (node.last ? '' : ' + i'));
    },

    '_v': function(node, context) {
      context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    },

    '_t': function(node, context) {
      context.code += write('"' + esc(node.text) + '"');
    },

    '{': tripleStache,

    '&': tripleStache
  }

  function tripleStache(node, context) {
    context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
  }

  function write(s) {
    return 't.b(' + s + ');';
  }

  Hogan.walk = function(nodelist, context) {
    var func;
    for (var i = 0, l = nodelist.length; i < l; i++) {
      func = Hogan.codegen[nodelist[i].tag];
      func && func(nodelist[i], context);
    }
    return context;
  }

  Hogan.parse = function(tokens, text, options) {
    options = options || {};
    return buildTree(tokens, '', [], options.sectionTags || []);
  }

  Hogan.cache = {};

  Hogan.cacheKey = function(text, options) {
    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
  }

  Hogan.compile = function(text, options) {
    options = options || {};
    var key = Hogan.cacheKey(text, options);
    var template = this.cache[key];

    if (template) {
      var partials = template.partials;
      for (var name in partials) {
        delete partials[name].instance;
      }
      return template;
    }

    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
    return this.cache[key] = template;
  }
})(typeof exports !== 'undefined' ? exports : Hogan);

},{}],30:[function(require,module,exports){
/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// This file is for use with Node.js. See dist/ for browser files.

var Hogan = require('./compiler');
Hogan.Template = require('./template').Template;
Hogan.template = Hogan.Template;
module.exports = Hogan;

},{"./compiler":29,"./template":31}],31:[function(require,module,exports){
/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

var Hogan = {};

(function (Hogan) {
  Hogan.Template = function (codeObj, text, compiler, options) {
    codeObj = codeObj || {};
    this.r = codeObj.code || this.r;
    this.c = compiler;
    this.options = options || {};
    this.text = text || '';
    this.partials = codeObj.partials || {};
    this.subs = codeObj.subs || {};
    this.buf = '';
  }

  Hogan.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; },

    // variable escaping
    v: hoganEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // ensurePartial
    ep: function(symbol, partials) {
      var partial = this.partials[symbol];

      // check to see that if we've instantiated this partial before
      var template = partials[partial.name];
      if (partial.instance && partial.base == template) {
        return partial.instance;
      }

      if (typeof template == 'string') {
        if (!this.c) {
          throw new Error("No compiler available.");
        }
        template = this.c.compile(template, this.options);
      }

      if (!template) {
        return null;
      }

      // We use this to check whether the partials dictionary has changed
      this.partials[symbol].base = template;

      if (partial.subs) {
        // Make sure we consider parent template now
        if (!partials.stackText) partials.stackText = {};
        for (key in partial.subs) {
          if (!partials.stackText[key]) {
            partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
          }
        }
        template = createSpecializedPartial(template, partial.subs, partial.partials,
          this.stackSubs, this.stackPartials, partials.stackText);
      }
      this.partials[symbol].instance = template;

      return template;
    },

    // tries to find a partial in the current scope and render it
    rp: function(symbol, context, partials, indent) {
      var partial = this.ep(symbol, partials);
      if (!partial) {
        return '';
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if (isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val == 'function') {
        val = this.ms(val, ctx, partials, inverted, start, end, tags);
      }

      pass = !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var found,
          names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          doModelGet = this.options.modelGet,
          cx = null;

      if (key === '.' && isArray(ctx[ctx.length - 2])) {
        val = ctx[ctx.length - 1];
      } else {
        for (var i = 1; i < names.length; i++) {
          found = findInScope(names[i], val, doModelGet);
          if (found !== undefined) {
            cx = val;
            val = found;
          } else {
            val = '';
          }
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val == 'function') {
        ctx.push(cx);
        val = this.mv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false,
          doModelGet = this.options.modelGet;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        val = findInScope(key, v, doModelGet);
        if (val !== undefined) {
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : "";
      }

      if (!returnFound && typeof val == 'function') {
        val = this.mv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ls: function(func, cx, partials, text, tags) {
      var oldTags = this.options.delimiters;

      this.options.delimiters = tags;
      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
      this.options.delimiters = oldTags;

      return false;
    },

    // compile text
    ct: function(text, cx, partials) {
      if (this.options.disableLambda) {
        throw new Error('Lambda features disabled.');
      }
      return this.c.compile(text, this.options).render(cx, partials);
    },

    // template result buffering
    b: function(s) { this.buf += s; },

    fl: function() { var r = this.buf; this.buf = ''; return r; },

    // method replace section
    ms: function(func, ctx, partials, inverted, start, end, tags) {
      var textSource,
          cx = ctx[ctx.length - 1],
          result = func.call(cx);

      if (typeof result == 'function') {
        if (inverted) {
          return true;
        } else {
          textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
          return this.ls(result, cx, partials, textSource.substring(start, end), tags);
        }
      }

      return result;
    },

    // method replace variable
    mv: function(func, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = func.call(cx);

      if (typeof result == 'function') {
        return this.ct(coerceToString(result.call(cx)), cx, partials);
      }

      return result;
    },

    sub: function(name, context, partials, indent) {
      var f = this.subs[name];
      if (f) {
        this.activeSub = name;
        f(context, partials, this, indent);
        this.activeSub = false;
      }
    }

  };

  //Find a key in an object
  function findInScope(key, scope, doModelGet) {
    var val;

    if (scope && typeof scope == 'object') {

      if (scope[key] !== undefined) {
        val = scope[key];

      // try lookup with get for backbone or similar model data
      } else if (doModelGet && scope.get && typeof scope.get == 'function') {
        val = scope.get(key);
      }
    }

    return val;
  }

  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
    function PartialTemplate() {};
    PartialTemplate.prototype = instance;
    function Substitutions() {};
    Substitutions.prototype = instance.subs;
    var key;
    var partial = new PartialTemplate();
    partial.subs = new Substitutions();
    partial.subsText = {};  //hehe. substext.
    partial.buf = '';

    stackSubs = stackSubs || {};
    partial.stackSubs = stackSubs;
    partial.subsText = stackText;
    for (key in subs) {
      if (!stackSubs[key]) stackSubs[key] = subs[key];
    }
    for (key in stackSubs) {
      partial.subs[key] = stackSubs[key];
    }

    stackPartials = stackPartials || {};
    partial.stackPartials = stackPartials;
    for (key in partials) {
      if (!stackPartials[key]) stackPartials[key] = partials[key];
    }
    for (key in stackPartials) {
      partial.partials[key] = stackPartials[key];
    }

    return partial;
  }

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos = /\'/g,
      rQuot = /\"/g,
      hChars = /[&<>\"\']/;

  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function hoganEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp, '&amp;')
        .replace(rLt, '&lt;')
        .replace(rGt, '&gt;')
        .replace(rApos, '&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  var isArray = Array.isArray || function(a) {
    return Object.prototype.toString.call(a) === '[object Array]';
  };

})(typeof exports !== 'undefined' ? exports : Hogan);

},{}],32:[function(require,module,exports){
/*!
 * @overview RSVP - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2016 Yehuda Katz, Tom Dale, Stefan Penner and contributors
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
 * @version   4.8.4+ff10049b
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.RSVP = {})));
}(this, (function (exports) { 'use strict';

  function callbacksFor(object) {
    var callbacks = object._promiseCallbacks;

    if (!callbacks) {
      callbacks = object._promiseCallbacks = {};
    }

    return callbacks;
  }

  /**
    @class EventTarget
    @for rsvp
    @public
  */
  var EventTarget = {

    /**
      `EventTarget.mixin` extends an object with EventTarget methods. For
      Example:
       ```javascript
      import EventTarget from 'rsvp';
       let object = {};
       EventTarget.mixin(object);
       object.on('finished', function(event) {
        // handle event
      });
       object.trigger('finished', { detail: value });
      ```
       `EventTarget.mixin` also works with prototypes:
       ```javascript
      import EventTarget from 'rsvp';
       let Person = function() {};
      EventTarget.mixin(Person.prototype);
       let yehuda = new Person();
      let tom = new Person();
       yehuda.on('poke', function(event) {
        console.log('Yehuda says OW');
      });
       tom.on('poke', function(event) {
        console.log('Tom says OW');
      });
       yehuda.trigger('poke');
      tom.trigger('poke');
      ```
       @method mixin
      @for rsvp
      @private
      @param {Object} object object to extend with EventTarget methods
    */
    mixin: function (object) {
      object.on = this.on;
      object.off = this.off;
      object.trigger = this.trigger;
      object._promiseCallbacks = undefined;
      return object;
    },


    /**
      Registers a callback to be executed when `eventName` is triggered
       ```javascript
      object.on('event', function(eventInfo){
        // handle the event
      });
       object.trigger('event');
      ```
       @method on
      @for EventTarget
      @private
      @param {String} eventName name of the event to listen for
      @param {Function} callback function to be called when the event is triggered.
    */
    on: function (eventName, callback) {
      if (typeof callback !== 'function') {
        throw new TypeError('Callback must be a function');
      }

      var allCallbacks = callbacksFor(this);
      var callbacks = allCallbacks[eventName];

      if (!callbacks) {
        callbacks = allCallbacks[eventName] = [];
      }

      if (callbacks.indexOf(callback) === -1) {
        callbacks.push(callback);
      }
    },


    /**
      You can use `off` to stop firing a particular callback for an event:
       ```javascript
      function doStuff() { // do stuff! }
      object.on('stuff', doStuff);
       object.trigger('stuff'); // doStuff will be called
       // Unregister ONLY the doStuff callback
      object.off('stuff', doStuff);
      object.trigger('stuff'); // doStuff will NOT be called
      ```
       If you don't pass a `callback` argument to `off`, ALL callbacks for the
      event will not be executed when the event fires. For example:
       ```javascript
      let callback1 = function(){};
      let callback2 = function(){};
       object.on('stuff', callback1);
      object.on('stuff', callback2);
       object.trigger('stuff'); // callback1 and callback2 will be executed.
       object.off('stuff');
      object.trigger('stuff'); // callback1 and callback2 will not be executed!
      ```
       @method off
      @for rsvp
      @private
      @param {String} eventName event to stop listening to
      @param {Function} [callback] optional argument. If given, only the function
      given will be removed from the event's callback queue. If no `callback`
      argument is given, all callbacks will be removed from the event's callback
      queue.
    */
    off: function (eventName, callback) {
      var allCallbacks = callbacksFor(this);

      if (!callback) {
        allCallbacks[eventName] = [];
        return;
      }

      var callbacks = allCallbacks[eventName];
      var index = callbacks.indexOf(callback);

      if (index !== -1) {
        callbacks.splice(index, 1);
      }
    },


    /**
      Use `trigger` to fire custom events. For example:
       ```javascript
      object.on('foo', function(){
        console.log('foo event happened!');
      });
      object.trigger('foo');
      // 'foo event happened!' logged to the console
      ```
       You can also pass a value as a second argument to `trigger` that will be
      passed as an argument to all event listeners for the event:
       ```javascript
      object.on('foo', function(value){
        console.log(value.name);
      });
       object.trigger('foo', { name: 'bar' });
      // 'bar' logged to the console
      ```
       @method trigger
      @for rsvp
      @private
      @param {String} eventName name of the event to be triggered
      @param {*} [options] optional value to be passed to any event handlers for
      the given `eventName`
    */
    trigger: function (eventName, options, label) {
      var allCallbacks = callbacksFor(this);

      var callbacks = allCallbacks[eventName];
      if (callbacks) {
        // Don't cache the callbacks.length since it may grow
        var callback = void 0;
        for (var i = 0; i < callbacks.length; i++) {
          callback = callbacks[i];
          callback(options, label);
        }
      }
    }
  };

  var config = {
    instrument: false
  };

  EventTarget['mixin'](config);

  function configure(name, value) {
    if (arguments.length === 2) {
      config[name] = value;
    } else {
      return config[name];
    }
  }

  var queue = [];

  function scheduleFlush() {
    setTimeout(function () {
      for (var i = 0; i < queue.length; i++) {
        var entry = queue[i];

        var payload = entry.payload;

        payload.guid = payload.key + payload.id;
        payload.childGuid = payload.key + payload.childId;
        if (payload.error) {
          payload.stack = payload.error.stack;
        }

        config['trigger'](entry.name, entry.payload);
      }
      queue.length = 0;
    }, 50);
  }

  function instrument(eventName, promise, child) {
    if (1 === queue.push({
      name: eventName,
      payload: {
        key: promise._guidKey,
        id: promise._id,
        eventName: eventName,
        detail: promise._result,
        childId: child && child._id,
        label: promise._label,
        timeStamp: Date.now(),
        error: config["instrument-with-stack"] ? new Error(promise._label) : null
      } })) {
      scheduleFlush();
    }
  }

  /**
    `Promise.resolve` returns a promise that will become resolved with the
    passed `value`. It is shorthand for the following:

    ```javascript
    import Promise from 'rsvp';

    let promise = new Promise(function(resolve, reject){
      resolve(1);
    });

    promise.then(function(value){
      // value === 1
    });
    ```

    Instead of writing the above, your code now simply becomes the following:

    ```javascript
    import Promise from 'rsvp';

    let promise = RSVP.Promise.resolve(1);

    promise.then(function(value){
      // value === 1
    });
    ```

    @method resolve
    @for Promise
    @static
    @param {*} object value that the returned promise will be resolved with
    @param {String} [label] optional string for identifying the returned promise.
    Useful for tooling.
    @return {Promise} a promise that will become fulfilled with the given
    `value`
  */
  function resolve$$1(object, label) {
    /*jshint validthis:true */
    var Constructor = this;

    if (object && typeof object === 'object' && object.constructor === Constructor) {
      return object;
    }

    var promise = new Constructor(noop, label);
    resolve$1(promise, object);
    return promise;
  }

  function withOwnPromise() {
    return new TypeError('A promises callback cannot return that same promise.');
  }

  function objectOrFunction(x) {
    var type = typeof x;
    return x !== null && (type === 'object' || type === 'function');
  }

  function noop() {}

  var PENDING = void 0;
  var FULFILLED = 1;
  var REJECTED = 2;

  var TRY_CATCH_ERROR = { error: null };

  function getThen(promise) {
    try {
      return promise.then;
    } catch (error) {
      TRY_CATCH_ERROR.error = error;
      return TRY_CATCH_ERROR;
    }
  }

  var tryCatchCallback = void 0;
  function tryCatcher() {
    try {
      var target = tryCatchCallback;
      tryCatchCallback = null;
      return target.apply(this, arguments);
    } catch (e) {
      TRY_CATCH_ERROR.error = e;
      return TRY_CATCH_ERROR;
    }
  }

  function tryCatch(fn) {
    tryCatchCallback = fn;
    return tryCatcher;
  }

  function handleForeignThenable(promise, thenable, then$$1) {
    config.async(function (promise) {
      var sealed = false;
      var result = tryCatch(then$$1).call(thenable, function (value) {
        if (sealed) {
          return;
        }
        sealed = true;
        if (thenable === value) {
          fulfill(promise, value);
        } else {
          resolve$1(promise, value);
        }
      }, function (reason) {
        if (sealed) {
          return;
        }
        sealed = true;

        reject(promise, reason);
      }, 'Settle: ' + (promise._label || ' unknown promise'));

      if (!sealed && result === TRY_CATCH_ERROR) {
        sealed = true;
        var error = TRY_CATCH_ERROR.error;
        TRY_CATCH_ERROR.error = null;
        reject(promise, error);
      }
    }, promise);
  }

  function handleOwnThenable(promise, thenable) {
    if (thenable._state === FULFILLED) {
      fulfill(promise, thenable._result);
    } else if (thenable._state === REJECTED) {
      thenable._onError = null;
      reject(promise, thenable._result);
    } else {
      subscribe(thenable, undefined, function (value) {
        if (thenable === value) {
          fulfill(promise, value);
        } else {
          resolve$1(promise, value);
        }
      }, function (reason) {
        return reject(promise, reason);
      });
    }
  }

  function handleMaybeThenable(promise, maybeThenable, then$$1) {
    var isOwnThenable = maybeThenable.constructor === promise.constructor && then$$1 === then && promise.constructor.resolve === resolve$$1;

    if (isOwnThenable) {
      handleOwnThenable(promise, maybeThenable);
    } else if (then$$1 === TRY_CATCH_ERROR) {
      var error = TRY_CATCH_ERROR.error;
      TRY_CATCH_ERROR.error = null;
      reject(promise, error);
    } else if (typeof then$$1 === 'function') {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }

  function resolve$1(promise, value) {
    if (promise === value) {
      fulfill(promise, value);
    } else if (objectOrFunction(value)) {
      handleMaybeThenable(promise, value, getThen(value));
    } else {
      fulfill(promise, value);
    }
  }

  function publishRejection(promise) {
    if (promise._onError) {
      promise._onError(promise._result);
    }

    publish(promise);
  }

  function fulfill(promise, value) {
    if (promise._state !== PENDING) {
      return;
    }

    promise._result = value;
    promise._state = FULFILLED;

    if (promise._subscribers.length === 0) {
      if (config.instrument) {
        instrument('fulfilled', promise);
      }
    } else {
      config.async(publish, promise);
    }
  }

  function reject(promise, reason) {
    if (promise._state !== PENDING) {
      return;
    }
    promise._state = REJECTED;
    promise._result = reason;
    config.async(publishRejection, promise);
  }

  function subscribe(parent, child, onFulfillment, onRejection) {
    var subscribers = parent._subscribers;
    var length = subscribers.length;

    parent._onError = null;

    subscribers[length] = child;
    subscribers[length + FULFILLED] = onFulfillment;
    subscribers[length + REJECTED] = onRejection;

    if (length === 0 && parent._state) {
      config.async(publish, parent);
    }
  }

  function publish(promise) {
    var subscribers = promise._subscribers;
    var settled = promise._state;

    if (config.instrument) {
      instrument(settled === FULFILLED ? 'fulfilled' : 'rejected', promise);
    }

    if (subscribers.length === 0) {
      return;
    }

    var child = void 0,
        callback = void 0,
        result = promise._result;

    for (var i = 0; i < subscribers.length; i += 3) {
      child = subscribers[i];
      callback = subscribers[i + settled];

      if (child) {
        invokeCallback(settled, child, callback, result);
      } else {
        callback(result);
      }
    }

    promise._subscribers.length = 0;
  }

  function invokeCallback(state, promise, callback, result) {
    var hasCallback = typeof callback === 'function';
    var value = void 0;

    if (hasCallback) {
      value = tryCatch(callback)(result);
    } else {
      value = result;
    }

    if (promise._state !== PENDING) {
      // noop
    } else if (value === promise) {
      reject(promise, withOwnPromise());
    } else if (value === TRY_CATCH_ERROR) {
      var error = TRY_CATCH_ERROR.error;
      TRY_CATCH_ERROR.error = null; // release
      reject(promise, error);
    } else if (hasCallback) {
      resolve$1(promise, value);
    } else if (state === FULFILLED) {
      fulfill(promise, value);
    } else if (state === REJECTED) {
      reject(promise, value);
    }
  }

  function initializePromise(promise, resolver) {
    var resolved = false;
    try {
      resolver(function (value) {
        if (resolved) {
          return;
        }
        resolved = true;
        resolve$1(promise, value);
      }, function (reason) {
        if (resolved) {
          return;
        }
        resolved = true;
        reject(promise, reason);
      });
    } catch (e) {
      reject(promise, e);
    }
  }

  function then(onFulfillment, onRejection, label) {
    var parent = this;
    var state = parent._state;

    if (state === FULFILLED && !onFulfillment || state === REJECTED && !onRejection) {
      config.instrument && instrument('chained', parent, parent);
      return parent;
    }

    parent._onError = null;

    var child = new parent.constructor(noop, label);
    var result = parent._result;

    config.instrument && instrument('chained', parent, child);

    if (state === PENDING) {
      subscribe(parent, child, onFulfillment, onRejection);
    } else {
      var callback = state === FULFILLED ? onFulfillment : onRejection;
      config.async(function () {
        return invokeCallback(state, child, callback, result);
      });
    }

    return child;
  }

  var Enumerator = function () {
    function Enumerator(Constructor, input, abortOnReject, label) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor(noop, label);
      this._abortOnReject = abortOnReject;
      this._isUsingOwnPromise = Constructor === Promise;
      this._isUsingOwnResolve = Constructor.resolve === resolve$$1;

      this._init.apply(this, arguments);
    }

    Enumerator.prototype._init = function _init(Constructor, input) {
      var len = input.length || 0;
      this.length = len;
      this._remaining = len;
      this._result = new Array(len);

      this._enumerate(input);
    };

    Enumerator.prototype._enumerate = function _enumerate(input) {
      var length = this.length;
      var promise = this.promise;

      for (var i = 0; promise._state === PENDING && i < length; i++) {
        this._eachEntry(input[i], i, true);
      }
      this._checkFullfillment();
    };

    Enumerator.prototype._checkFullfillment = function _checkFullfillment() {
      if (this._remaining === 0) {
        var result = this._result;
        fulfill(this.promise, result);
        this._result = null;
      }
    };

    Enumerator.prototype._settleMaybeThenable = function _settleMaybeThenable(entry, i, firstPass) {
      var c = this._instanceConstructor;

      if (this._isUsingOwnResolve) {
        var then$$1 = getThen(entry);

        if (then$$1 === then && entry._state !== PENDING) {
          entry._onError = null;
          this._settledAt(entry._state, i, entry._result, firstPass);
        } else if (typeof then$$1 !== 'function') {
          this._settledAt(FULFILLED, i, entry, firstPass);
        } else if (this._isUsingOwnPromise) {
          var promise = new c(noop);
          handleMaybeThenable(promise, entry, then$$1);
          this._willSettleAt(promise, i, firstPass);
        } else {
          this._willSettleAt(new c(function (resolve) {
            return resolve(entry);
          }), i, firstPass);
        }
      } else {
        this._willSettleAt(c.resolve(entry), i, firstPass);
      }
    };

    Enumerator.prototype._eachEntry = function _eachEntry(entry, i, firstPass) {
      if (entry !== null && typeof entry === 'object') {
        this._settleMaybeThenable(entry, i, firstPass);
      } else {
        this._setResultAt(FULFILLED, i, entry, firstPass);
      }
    };

    Enumerator.prototype._settledAt = function _settledAt(state, i, value, firstPass) {
      var promise = this.promise;

      if (promise._state === PENDING) {
        if (this._abortOnReject && state === REJECTED) {
          reject(promise, value);
        } else {
          this._setResultAt(state, i, value, firstPass);
          this._checkFullfillment();
        }
      }
    };

    Enumerator.prototype._setResultAt = function _setResultAt(state, i, value, firstPass) {
      this._remaining--;
      this._result[i] = value;
    };

    Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i, firstPass) {
      var _this = this;

      subscribe(promise, undefined, function (value) {
        return _this._settledAt(FULFILLED, i, value, firstPass);
      }, function (reason) {
        return _this._settledAt(REJECTED, i, reason, firstPass);
      });
    };

    return Enumerator;
  }();


  function setSettledResult(state, i, value) {
    this._remaining--;
    if (state === FULFILLED) {
      this._result[i] = {
        state: 'fulfilled',
        value: value
      };
    } else {
      this._result[i] = {
        state: 'rejected',
        reason: value
      };
    }
  }

  /**
    `Promise.all` accepts an array of promises, and returns a new promise which
    is fulfilled with an array of fulfillment values for the passed promises, or
    rejected with the reason of the first passed promise to be rejected. It casts all
    elements of the passed iterable to promises as it runs this algorithm.

    Example:

    ```javascript
    import Promise, { resolve } from 'rsvp';

    let promise1 = resolve(1);
    let promise2 = resolve(2);
    let promise3 = resolve(3);
    let promises = [ promise1, promise2, promise3 ];

    Promise.all(promises).then(function(array){
      // The array here would be [ 1, 2, 3 ];
    });
    ```

    If any of the `promises` given to `RSVP.all` are rejected, the first promise
    that is rejected will be given as an argument to the returned promises's
    rejection handler. For example:

    Example:

    ```javascript
    import Promise, { resolve, reject } from 'rsvp';

    let promise1 = resolve(1);
    let promise2 = reject(new Error("2"));
    let promise3 = reject(new Error("3"));
    let promises = [ promise1, promise2, promise3 ];

    Promise.all(promises).then(function(array){
      // Code here never runs because there are rejected promises!
    }, function(error) {
      // error.message === "2"
    });
    ```

    @method all
    @for Promise
    @param {Array} entries array of promises
    @param {String} [label] optional string for labeling the promise.
    Useful for tooling.
    @return {Promise} promise that is fulfilled when all `promises` have been
    fulfilled, or rejected if any of them become rejected.
    @static
  */
  function all(entries, label) {
    if (!Array.isArray(entries)) {
      return this.reject(new TypeError("Promise.all must be called with an array"), label);
    }
    return new Enumerator(this, entries, true /* abort on reject */, label).promise;
  }

  /**
    `Promise.race` returns a new promise which is settled in the same way as the
    first passed promise to settle.

    Example:

    ```javascript
    import Promise from 'rsvp';

    let promise1 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 1');
      }, 200);
    });

    let promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 2');
      }, 100);
    });

    Promise.race([promise1, promise2]).then(function(result){
      // result === 'promise 2' because it was resolved before promise1
      // was resolved.
    });
    ```

    `Promise.race` is deterministic in that only the state of the first
    settled promise matters. For example, even if other promises given to the
    `promises` array argument are resolved, but the first settled promise has
    become rejected before the other promises became fulfilled, the returned
    promise will become rejected:

    ```javascript
    import Promise from 'rsvp';

    let promise1 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 1');
      }, 200);
    });

    let promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){
        reject(new Error('promise 2'));
      }, 100);
    });

    Promise.race([promise1, promise2]).then(function(result){
      // Code here never runs
    }, function(reason){
      // reason.message === 'promise 2' because promise 2 became rejected before
      // promise 1 became fulfilled
    });
    ```

    An example real-world use case is implementing timeouts:

    ```javascript
    import Promise from 'rsvp';

    Promise.race([ajax('foo.json'), timeout(5000)])
    ```

    @method race
    @for Promise
    @static
    @param {Array} entries array of promises to observe
    @param {String} [label] optional string for describing the promise returned.
    Useful for tooling.
    @return {Promise} a promise which settles in the same way as the first passed
    promise to settle.
  */
  function race(entries, label) {
    /*jshint validthis:true */
    var Constructor = this;

    var promise = new Constructor(noop, label);

    if (!Array.isArray(entries)) {
      reject(promise, new TypeError('Promise.race must be called with an array'));
      return promise;
    }

    for (var i = 0; promise._state === PENDING && i < entries.length; i++) {
      subscribe(Constructor.resolve(entries[i]), undefined, function (value) {
        return resolve$1(promise, value);
      }, function (reason) {
        return reject(promise, reason);
      });
    }

    return promise;
  }

  /**
    `Promise.reject` returns a promise rejected with the passed `reason`.
    It is shorthand for the following:

    ```javascript
    import Promise from 'rsvp';

    let promise = new Promise(function(resolve, reject){
      reject(new Error('WHOOPS'));
    });

    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```

    Instead of writing the above, your code now simply becomes the following:

    ```javascript
    import Promise from 'rsvp';

    let promise = Promise.reject(new Error('WHOOPS'));

    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```

    @method reject
    @for Promise
    @static
    @param {*} reason value that the returned promise will be rejected with.
    @param {String} [label] optional string for identifying the returned promise.
    Useful for tooling.
    @return {Promise} a promise rejected with the given `reason`.
  */
  function reject$1(reason, label) {
    /*jshint validthis:true */
    var Constructor = this;
    var promise = new Constructor(noop, label);
    reject(promise, reason);
    return promise;
  }

  var guidKey = 'rsvp_' + Date.now() + '-';
  var counter = 0;

  function needsResolver() {
    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
  }

  function needsNew() {
    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }

  /**
    Promise objects represent the eventual result of an asynchronous operation. The
    primary way of interacting with a promise is through its `then` method, which
    registers callbacks to receive either a promises eventual value or the reason
    why the promise cannot be fulfilled.

    Terminology
    -----------

    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
    - `thenable` is an object or function that defines a `then` method.
    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
    - `exception` is a value that is thrown using the throw statement.
    - `reason` is a value that indicates why a promise was rejected.
    - `settled` the final resting state of a promise, fulfilled or rejected.

    A promise can be in one of three states: pending, fulfilled, or rejected.

    Promises that are fulfilled have a fulfillment value and are in the fulfilled
    state.  Promises that are rejected have a rejection reason and are in the
    rejected state.  A fulfillment value is never a thenable.

    Promises can also be said to *resolve* a value.  If this value is also a
    promise, then the original promise's settled state will match the value's
    settled state.  So a promise that *resolves* a promise that rejects will
    itself reject, and a promise that *resolves* a promise that fulfills will
    itself fulfill.


    Basic Usage:
    ------------

    ```js
    let promise = new Promise(function(resolve, reject) {
      // on success
      resolve(value);

      // on failure
      reject(reason);
    });

    promise.then(function(value) {
      // on fulfillment
    }, function(reason) {
      // on rejection
    });
    ```

    Advanced Usage:
    ---------------

    Promises shine when abstracting away asynchronous interactions such as
    `XMLHttpRequest`s.

    ```js
    function getJSON(url) {
      return new Promise(function(resolve, reject){
        let xhr = new XMLHttpRequest();

        xhr.open('GET', url);
        xhr.onreadystatechange = handler;
        xhr.responseType = 'json';
        xhr.setRequestHeader('Accept', 'application/json');
        xhr.send();

        function handler() {
          if (this.readyState === this.DONE) {
            if (this.status === 200) {
              resolve(this.response);
            } else {
              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
            }
          }
        };
      });
    }

    getJSON('/posts.json').then(function(json) {
      // on fulfillment
    }, function(reason) {
      // on rejection
    });
    ```

    Unlike callbacks, promises are great composable primitives.

    ```js
    Promise.all([
      getJSON('/posts'),
      getJSON('/comments')
    ]).then(function(values){
      values[0] // => postsJSON
      values[1] // => commentsJSON

      return values;
    });
    ```

    @class Promise
    @public
    @param {function} resolver
    @param {String} [label] optional string for labeling the promise.
    Useful for tooling.
    @constructor
  */

  var Promise = function () {
    function Promise(resolver, label) {
      this._id = counter++;
      this._label = label;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      config.instrument && instrument('created', this);

      if (noop !== resolver) {
        typeof resolver !== 'function' && needsResolver();
        this instanceof Promise ? initializePromise(this, resolver) : needsNew();
      }
    }

    Promise.prototype._onError = function _onError(reason) {
      var _this = this;

      config.after(function () {
        if (_this._onError) {
          config.trigger('error', reason, _this._label);
        }
      });
    };

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.
    
      ```js
      function findAuthor(){
        throw new Error('couldn\'t find that author');
      }
    
      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }
    
      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```
    
      @method catch
      @param {Function} onRejection
      @param {String} [label] optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */


    Promise.prototype.catch = function _catch(onRejection, label) {
      return this.then(undefined, onRejection, label);
    };

    /**
      `finally` will be invoked regardless of the promise's fate just as native
      try/catch/finally behaves
    
      Synchronous example:
    
      ```js
      findAuthor() {
        if (Math.random() > 0.5) {
          throw new Error();
        }
        return new Author();
      }
    
      try {
        return findAuthor(); // succeed or fail
      } catch(error) {
        return findOtherAuthor();
      } finally {
        // always runs
        // doesn't affect the return value
      }
      ```
    
      Asynchronous example:
    
      ```js
      findAuthor().catch(function(reason){
        return findOtherAuthor();
      }).finally(function(){
        // author was either found, or not
      });
      ```
    
      @method finally
      @param {Function} callback
      @param {String} [label] optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */


    Promise.prototype.finally = function _finally(callback, label) {
      var promise = this;
      var constructor = promise.constructor;

      if (typeof callback === 'function') {
        return promise.then(function (value) {
          return constructor.resolve(callback()).then(function () {
            return value;
          });
        }, function (reason) {
          return constructor.resolve(callback()).then(function () {
            throw reason;
          });
        });
      }

      return promise.then(callback, callback);
    };

    return Promise;
  }();

  Promise.cast = resolve$$1; // deprecated
  Promise.all = all;
  Promise.race = race;
  Promise.resolve = resolve$$1;
  Promise.reject = reject$1;

  Promise.prototype._guidKey = guidKey;

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.

    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```

    Chaining
    --------

    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.

    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });

    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we\'re unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we\'re unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```

    Assimilation
    ------------

    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.

    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```

    If the assimliated promise rejects, then the downstream promise will also reject.

    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```

    Simple Example
    --------------

    Synchronous Example

    ```javascript
    let result;

    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```

    Errback Example

    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```

    Promise Example;

    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```

    Advanced Example
    --------------

    Synchronous Example

    ```javascript
    let author, books;

    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```

    Errback Example

    ```js

    function foundBooks(books) {

    }

    function failure(reason) {

    }

    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```

    Promise Example;

    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```

    @method then
    @param {Function} onFulfillment
    @param {Function} onRejection
    @param {String} [label] optional string for labeling the promise.
    Useful for tooling.
    @return {Promise}
  */
  Promise.prototype.then = then;

  function makeObject(_, argumentNames) {
    var obj = {};
    var length = _.length;
    var args = new Array(length);

    for (var x = 0; x < length; x++) {
      args[x] = _[x];
    }

    for (var i = 0; i < argumentNames.length; i++) {
      var name = argumentNames[i];
      obj[name] = args[i + 1];
    }

    return obj;
  }

  function arrayResult(_) {
    var length = _.length;
    var args = new Array(length - 1);

    for (var i = 1; i < length; i++) {
      args[i - 1] = _[i];
    }

    return args;
  }

  function wrapThenable(then, promise) {
    return {
      then: function (onFulFillment, onRejection) {
        return then.call(promise, onFulFillment, onRejection);
      }
    };
  }

  /**
    `denodeify` takes a 'node-style' function and returns a function that
    will return an `Promise`. You can use `denodeify` in Node.js or the
    browser when you'd prefer to use promises over using callbacks. For example,
    `denodeify` transforms the following:

    ```javascript
    let fs = require('fs');

    fs.readFile('myfile.txt', function(err, data){
      if (err) return handleError(err);
      handleData(data);
    });
    ```

    into:

    ```javascript
    let fs = require('fs');
    let readFile = denodeify(fs.readFile);

    readFile('myfile.txt').then(handleData, handleError);
    ```

    If the node function has multiple success parameters, then `denodeify`
    just returns the first one:

    ```javascript
    let request = denodeify(require('request'));

    request('http://example.com').then(function(res) {
      // ...
    });
    ```

    However, if you need all success parameters, setting `denodeify`'s
    second parameter to `true` causes it to return all success parameters
    as an array:

    ```javascript
    let request = denodeify(require('request'), true);

    request('http://example.com').then(function(result) {
      // result[0] -> res
      // result[1] -> body
    });
    ```

    Or if you pass it an array with names it returns the parameters as a hash:

    ```javascript
    let request = denodeify(require('request'), ['res', 'body']);

    request('http://example.com').then(function(result) {
      // result.res
      // result.body
    });
    ```

    Sometimes you need to retain the `this`:

    ```javascript
    let app = require('express')();
    let render = denodeify(app.render.bind(app));
    ```

    The denodified function inherits from the original function. It works in all
    environments, except IE 10 and below. Consequently all properties of the original
    function are available to you. However, any properties you change on the
    denodeified function won't be changed on the original function. Example:

    ```javascript
    let request = denodeify(require('request')),
        cookieJar = request.jar(); // <- Inheritance is used here

    request('http://example.com', {jar: cookieJar}).then(function(res) {
      // cookieJar.cookies holds now the cookies returned by example.com
    });
    ```

    Using `denodeify` makes it easier to compose asynchronous operations instead
    of using callbacks. For example, instead of:

    ```javascript
    let fs = require('fs');

    fs.readFile('myfile.txt', function(err, data){
      if (err) { ... } // Handle error
      fs.writeFile('myfile2.txt', data, function(err){
        if (err) { ... } // Handle error
        console.log('done')
      });
    });
    ```

    you can chain the operations together using `then` from the returned promise:

    ```javascript
    let fs = require('fs');
    let readFile = denodeify(fs.readFile);
    let writeFile = denodeify(fs.writeFile);

    readFile('myfile.txt').then(function(data){
      return writeFile('myfile2.txt', data);
    }).then(function(){
      console.log('done')
    }).catch(function(error){
      // Handle error
    });
    ```

    @method denodeify
    @public
    @static
    @for rsvp
    @param {Function} nodeFunc a 'node-style' function that takes a callback as
    its last argument. The callback expects an error to be passed as its first
    argument (if an error occurred, otherwise null), and the value from the
    operation as its second argument ('function(err, value){ }').
    @param {Boolean|Array} [options] An optional paramter that if set
    to `true` causes the promise to fulfill with the callback's success arguments
    as an array. This is useful if the node function has multiple success
    paramters. If you set this paramter to an array with names, the promise will
    fulfill with a hash with these names as keys and the success parameters as
    values.
    @return {Function} a function that wraps `nodeFunc` to return a `Promise`
  */
  function denodeify(nodeFunc, options) {
    var fn = function () {
      var l = arguments.length;
      var args = new Array(l + 1);
      var promiseInput = false;

      for (var i = 0; i < l; ++i) {
        var arg = arguments[i];

        if (!promiseInput) {
          // TODO: clean this up
          promiseInput = needsPromiseInput(arg);
          if (promiseInput === TRY_CATCH_ERROR) {
            var error = TRY_CATCH_ERROR.error;
            TRY_CATCH_ERROR.error = null;
            var p = new Promise(noop);
            reject(p, error);
            return p;
          } else if (promiseInput && promiseInput !== true) {
            arg = wrapThenable(promiseInput, arg);
          }
        }
        args[i] = arg;
      }

      var promise = new Promise(noop);

      args[l] = function (err, val) {
        if (err) {
          reject(promise, err);
        } else if (options === undefined) {
          resolve$1(promise, val);
        } else if (options === true) {
          resolve$1(promise, arrayResult(arguments));
        } else if (Array.isArray(options)) {
          resolve$1(promise, makeObject(arguments, options));
        } else {
          resolve$1(promise, val);
        }
      };

      if (promiseInput) {
        return handlePromiseInput(promise, args, nodeFunc, this);
      } else {
        return handleValueInput(promise, args, nodeFunc, this);
      }
    };

    fn.__proto__ = nodeFunc;

    return fn;
  }

  function handleValueInput(promise, args, nodeFunc, self) {
    var result = tryCatch(nodeFunc).apply(self, args);
    if (result === TRY_CATCH_ERROR) {
      var error = TRY_CATCH_ERROR.error;
      TRY_CATCH_ERROR.error = null;
      reject(promise, error);
    }
    return promise;
  }

  function handlePromiseInput(promise, args, nodeFunc, self) {
    return Promise.all(args).then(function (args) {
      return handleValueInput(promise, args, nodeFunc, self);
    });
  }

  function needsPromiseInput(arg) {
    if (arg !== null && typeof arg === 'object') {
      if (arg.constructor === Promise) {
        return true;
      } else {
        return getThen(arg);
      }
    } else {
      return false;
    }
  }

  /**
    This is a convenient alias for `Promise.all`.

    @method all
    @public
    @static
    @for rsvp
    @param {Array} array Array of promises.
    @param {String} [label] An optional label. This is useful
    for tooling.
  */
  function all$1(array, label) {
    return Promise.all(array, label);
  }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  /**
  @module rsvp
  @public
  **/

  var AllSettled = function (_Enumerator) {
    _inherits(AllSettled, _Enumerator);

    function AllSettled(Constructor, entries, label) {
      return _possibleConstructorReturn(this, _Enumerator.call(this, Constructor, entries, false /* don't abort on reject */, label));
    }

    return AllSettled;
  }(Enumerator);

  AllSettled.prototype._setResultAt = setSettledResult;

  /**
  `RSVP.allSettled` is similar to `RSVP.all`, but instead of implementing
  a fail-fast method, it waits until all the promises have returned and
  shows you all the results. This is useful if you want to handle multiple
  promises' failure states together as a set.
   Returns a promise that is fulfilled when all the given promises have been
  settled. The return promise is fulfilled with an array of the states of
  the promises passed into the `promises` array argument.
   Each state object will either indicate fulfillment or rejection, and
  provide the corresponding value or reason. The states will take one of
  the following formats:
   ```javascript
  { state: 'fulfilled', value: value }
    or
  { state: 'rejected', reason: reason }
  ```
   Example:
   ```javascript
  let promise1 = RSVP.Promise.resolve(1);
  let promise2 = RSVP.Promise.reject(new Error('2'));
  let promise3 = RSVP.Promise.reject(new Error('3'));
  let promises = [ promise1, promise2, promise3 ];
   RSVP.allSettled(promises).then(function(array){
    // array == [
    //   { state: 'fulfilled', value: 1 },
    //   { state: 'rejected', reason: Error },
    //   { state: 'rejected', reason: Error }
    // ]
    // Note that for the second item, reason.message will be '2', and for the
    // third item, reason.message will be '3'.
  }, function(error) {
    // Not run. (This block would only be called if allSettled had failed,
    // for instance if passed an incorrect argument type.)
  });
  ```
   @method allSettled
  @public
  @static
  @for rsvp
  @param {Array} entries
  @param {String} [label] - optional string that describes the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled with an array of the settled
  states of the constituent promises.
  */

  function allSettled(entries, label) {
    if (!Array.isArray(entries)) {
      return Promise.reject(new TypeError("Promise.allSettled must be called with an array"), label);
    }

    return new AllSettled(Promise, entries, label).promise;
  }

  /**
    This is a convenient alias for `Promise.race`.

    @method race
    @public
    @static
    @for rsvp
    @param {Array} array Array of promises.
    @param {String} [label] An optional label. This is useful
    for tooling.
   */
  function race$1(array, label) {
    return Promise.race(array, label);
  }

  function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var PromiseHash = function (_Enumerator) {
    _inherits$1(PromiseHash, _Enumerator);

    function PromiseHash(Constructor, object) {
      var abortOnReject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var label = arguments[3];
      return _possibleConstructorReturn$1(this, _Enumerator.call(this, Constructor, object, abortOnReject, label));
    }

    PromiseHash.prototype._init = function _init(Constructor, object) {
      this._result = {};
      this._enumerate(object);
    };

    PromiseHash.prototype._enumerate = function _enumerate(input) {
      var keys = Object.keys(input);

      var length = keys.length;
      var promise = this.promise;
      this._remaining = length;

      var key = void 0,
          val = void 0;
      for (var i = 0; promise._state === PENDING && i < length; i++) {
        key = keys[i];
        val = input[key];
        this._eachEntry(val, key, true);
      }

      this._checkFullfillment();
    };

    return PromiseHash;
  }(Enumerator);

  /**
    `hash` is similar to `all`, but takes an object instead of an array
    for its `promises` argument.

    Returns a promise that is fulfilled when all the given promises have been
    fulfilled, or rejected if any of them become rejected. The returned promise
    is fulfilled with a hash that has the same key names as the `promises` object
    argument. If any of the values in the object are not promises, they will
    simply be copied over to the fulfilled object.

    Example:

    ```javascript
    let promises = {
      myPromise: resolve(1),
      yourPromise: resolve(2),
      theirPromise: resolve(3),
      notAPromise: 4
    };

    hash(promises).then(function(hash){
      // hash here is an object that looks like:
      // {
      //   myPromise: 1,
      //   yourPromise: 2,
      //   theirPromise: 3,
      //   notAPromise: 4
      // }
    });
    ```

    If any of the `promises` given to `hash` are rejected, the first promise
    that is rejected will be given as the reason to the rejection handler.

    Example:

    ```javascript
    let promises = {
      myPromise: resolve(1),
      rejectedPromise: reject(new Error('rejectedPromise')),
      anotherRejectedPromise: reject(new Error('anotherRejectedPromise')),
    };

    hash(promises).then(function(hash){
      // Code here never runs because there are rejected promises!
    }, function(reason) {
      // reason.message === 'rejectedPromise'
    });
    ```

    An important note: `hash` is intended for plain JavaScript objects that
    are just a set of keys and values. `hash` will NOT preserve prototype
    chains.

    Example:

    ```javascript
    import { hash, resolve } from 'rsvp';
    function MyConstructor(){
      this.example = resolve('Example');
    }

    MyConstructor.prototype = {
      protoProperty: resolve('Proto Property')
    };

    let myObject = new MyConstructor();

    hash(myObject).then(function(hash){
      // protoProperty will not be present, instead you will just have an
      // object that looks like:
      // {
      //   example: 'Example'
      // }
      //
      // hash.hasOwnProperty('protoProperty'); // false
      // 'undefined' === typeof hash.protoProperty
    });
    ```

    @method hash
    @public
    @static
    @for rsvp
    @param {Object} object
    @param {String} [label] optional string that describes the promise.
    Useful for tooling.
    @return {Promise} promise that is fulfilled when all properties of `promises`
    have been fulfilled, or rejected if any of them become rejected.
  */
  function hash(object, label) {
    return Promise.resolve(object, label).then(function (object) {
      if (object === null || typeof object !== 'object') {
        throw new TypeError("Promise.hash must be called with an object");
      }
      return new PromiseHash(Promise, object, label).promise;
    });
  }

  function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var HashSettled = function (_PromiseHash) {
    _inherits$2(HashSettled, _PromiseHash);

    function HashSettled(Constructor, object, label) {
      return _possibleConstructorReturn$2(this, _PromiseHash.call(this, Constructor, object, false, label));
    }

    return HashSettled;
  }(PromiseHash);

  HashSettled.prototype._setResultAt = setSettledResult;

  /**
    `hashSettled` is similar to `allSettled`, but takes an object
    instead of an array for its `promises` argument.

    Unlike `all` or `hash`, which implement a fail-fast method,
    but like `allSettled`, `hashSettled` waits until all the
    constituent promises have returned and then shows you all the results
    with their states and values/reasons. This is useful if you want to
    handle multiple promises' failure states together as a set.

    Returns a promise that is fulfilled when all the given promises have been
    settled, or rejected if the passed parameters are invalid.

    The returned promise is fulfilled with a hash that has the same key names as
    the `promises` object argument. If any of the values in the object are not
    promises, they will be copied over to the fulfilled object and marked with state
    'fulfilled'.

    Example:

    ```javascript
    import { hashSettled, resolve } from 'rsvp';

    let promises = {
      myPromise: resolve(1),
      yourPromise: resolve(2),
      theirPromise: resolve(3),
      notAPromise: 4
    };

    hashSettled(promises).then(function(hash){
      // hash here is an object that looks like:
      // {
      //   myPromise: { state: 'fulfilled', value: 1 },
      //   yourPromise: { state: 'fulfilled', value: 2 },
      //   theirPromise: { state: 'fulfilled', value: 3 },
      //   notAPromise: { state: 'fulfilled', value: 4 }
      // }
    });
    ```

    If any of the `promises` given to `hash` are rejected, the state will
    be set to 'rejected' and the reason for rejection provided.

    Example:

    ```javascript
    import { hashSettled, reject, resolve } from 'rsvp';

    let promises = {
      myPromise: resolve(1),
      rejectedPromise: reject(new Error('rejection')),
      anotherRejectedPromise: reject(new Error('more rejection')),
    };

    hashSettled(promises).then(function(hash){
      // hash here is an object that looks like:
      // {
      //   myPromise:              { state: 'fulfilled', value: 1 },
      //   rejectedPromise:        { state: 'rejected', reason: Error },
      //   anotherRejectedPromise: { state: 'rejected', reason: Error },
      // }
      // Note that for rejectedPromise, reason.message == 'rejection',
      // and for anotherRejectedPromise, reason.message == 'more rejection'.
    });
    ```

    An important note: `hashSettled` is intended for plain JavaScript objects that
    are just a set of keys and values. `hashSettled` will NOT preserve prototype
    chains.

    Example:

    ```javascript
    import Promise, { hashSettled, resolve } from 'rsvp';

    function MyConstructor(){
      this.example = resolve('Example');
    }

    MyConstructor.prototype = {
      protoProperty: Promise.resolve('Proto Property')
    };

    let myObject = new MyConstructor();

    hashSettled(myObject).then(function(hash){
      // protoProperty will not be present, instead you will just have an
      // object that looks like:
      // {
      //   example: { state: 'fulfilled', value: 'Example' }
      // }
      //
      // hash.hasOwnProperty('protoProperty'); // false
      // 'undefined' === typeof hash.protoProperty
    });
    ```

    @method hashSettled
    @public
    @for rsvp
    @param {Object} object
    @param {String} [label] optional string that describes the promise.
    Useful for tooling.
    @return {Promise} promise that is fulfilled when when all properties of `promises`
    have been settled.
    @static
  */

  function hashSettled(object, label) {
    return Promise.resolve(object, label).then(function (object) {
      if (object === null || typeof object !== 'object') {
        throw new TypeError("hashSettled must be called with an object");
      }

      return new HashSettled(Promise, object, false, label).promise;
    });
  }

  /**
    `rethrow` will rethrow an error on the next turn of the JavaScript event
    loop in order to aid debugging.

    Promises A+ specifies that any exceptions that occur with a promise must be
    caught by the promises implementation and bubbled to the last handler. For
    this reason, it is recommended that you always specify a second rejection
    handler function to `then`. However, `rethrow` will throw the exception
    outside of the promise, so it bubbles up to your console if in the browser,
    or domain/cause uncaught exception in Node. `rethrow` will also throw the
    error again so the error can be handled by the promise per the spec.

    ```javascript
    import { rethrow } from 'rsvp';

    function throws(){
      throw new Error('Whoops!');
    }

    let promise = new Promise(function(resolve, reject){
      throws();
    });

    promise.catch(rethrow).then(function(){
      // Code here doesn't run because the promise became rejected due to an
      // error!
    }, function (err){
      // handle the error here
    });
    ```

    The 'Whoops' error will be thrown on the next turn of the event loop
    and you can watch for it in your console. You can also handle it using a
    rejection handler given to `.then` or `.catch` on the returned promise.

    @method rethrow
    @public
    @static
    @for rsvp
    @param {Error} reason reason the promise became rejected.
    @throws Error
    @static
  */
  function rethrow(reason) {
    setTimeout(function () {
      throw reason;
    });
    throw reason;
  }

  /**
    `defer` returns an object similar to jQuery's `$.Deferred`.
    `defer` should be used when porting over code reliant on `$.Deferred`'s
    interface. New code should use the `Promise` constructor instead.

    The object returned from `defer` is a plain object with three properties:

    * promise - an `Promise`.
    * reject - a function that causes the `promise` property on this object to
      become rejected
    * resolve - a function that causes the `promise` property on this object to
      become fulfilled.

    Example:

     ```javascript
     let deferred = defer();

     deferred.resolve("Success!");

     deferred.promise.then(function(value){
       // value here is "Success!"
     });
     ```

    @method defer
    @public
    @static
    @for rsvp
    @param {String} [label] optional string for labeling the promise.
    Useful for tooling.
    @return {Object}
   */

  function defer(label) {
    var deferred = { resolve: undefined, reject: undefined };

    deferred.promise = new Promise(function (resolve, reject) {
      deferred.resolve = resolve;
      deferred.reject = reject;
    }, label);

    return deferred;
  }

  function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var MapEnumerator = function (_Enumerator) {
    _inherits$3(MapEnumerator, _Enumerator);

    function MapEnumerator(Constructor, entries, mapFn, label) {
      return _possibleConstructorReturn$3(this, _Enumerator.call(this, Constructor, entries, true, label, mapFn));
    }

    MapEnumerator.prototype._init = function _init(Constructor, input, bool, label, mapFn) {
      var len = input.length || 0;
      this.length = len;
      this._remaining = len;
      this._result = new Array(len);
      this._mapFn = mapFn;

      this._enumerate(input);
    };

    MapEnumerator.prototype._setResultAt = function _setResultAt(state, i, value, firstPass) {
      if (firstPass) {
        var val = tryCatch(this._mapFn)(value, i);
        if (val === TRY_CATCH_ERROR) {
          this._settledAt(REJECTED, i, val.error, false);
        } else {
          this._eachEntry(val, i, false);
        }
      } else {
        this._remaining--;
        this._result[i] = value;
      }
    };

    return MapEnumerator;
  }(Enumerator);

  /**
   `map` is similar to JavaScript's native `map` method. `mapFn` is eagerly called
    meaning that as soon as any promise resolves its value will be passed to `mapFn`.
    `map` returns a promise that will become fulfilled with the result of running
    `mapFn` on the values the promises become fulfilled with.

    For example:

    ```javascript
    import { map, resolve } from 'rsvp';

    let promise1 = resolve(1);
    let promise2 = resolve(2);
    let promise3 = resolve(3);
    let promises = [ promise1, promise2, promise3 ];

    let mapFn = function(item){
      return item + 1;
    };

    map(promises, mapFn).then(function(result){
      // result is [ 2, 3, 4 ]
    });
    ```

    If any of the `promises` given to `map` are rejected, the first promise
    that is rejected will be given as an argument to the returned promise's
    rejection handler. For example:

    ```javascript
    import { map, reject, resolve } from 'rsvp';

    let promise1 = resolve(1);
    let promise2 = reject(new Error('2'));
    let promise3 = reject(new Error('3'));
    let promises = [ promise1, promise2, promise3 ];

    let mapFn = function(item){
      return item + 1;
    };

    map(promises, mapFn).then(function(array){
      // Code here never runs because there are rejected promises!
    }, function(reason) {
      // reason.message === '2'
    });
    ```

    `map` will also wait if a promise is returned from `mapFn`. For example,
    say you want to get all comments from a set of blog posts, but you need
    the blog posts first because they contain a url to those comments.

    ```javscript
    import { map } from 'rsvp';

    let mapFn = function(blogPost){
      // getComments does some ajax and returns an Promise that is fulfilled
      // with some comments data
      return getComments(blogPost.comments_url);
    };

    // getBlogPosts does some ajax and returns an Promise that is fulfilled
    // with some blog post data
    map(getBlogPosts(), mapFn).then(function(comments){
      // comments is the result of asking the server for the comments
      // of all blog posts returned from getBlogPosts()
    });
    ```

    @method map
    @public
    @static
    @for rsvp
    @param {Array} promises
    @param {Function} mapFn function to be called on each fulfilled promise.
    @param {String} [label] optional string for labeling the promise.
    Useful for tooling.
    @return {Promise} promise that is fulfilled with the result of calling
    `mapFn` on each fulfilled promise or value when they become fulfilled.
     The promise will be rejected if any of the given `promises` become rejected.
  */
  function map(promises, mapFn, label) {
    if (typeof mapFn !== 'function') {
      return Promise.reject(new TypeError("map expects a function as a second argument"), label);
    }

    return Promise.resolve(promises, label).then(function (promises) {
      if (!Array.isArray(promises)) {
        throw new TypeError("map must be called with an array");
      }
      return new MapEnumerator(Promise, promises, mapFn, label).promise;
    });
  }

  /**
    This is a convenient alias for `Promise.resolve`.

    @method resolve
    @public
    @static
    @for rsvp
    @param {*} value value that the returned promise will be resolved with
    @param {String} [label] optional string for identifying the returned promise.
    Useful for tooling.
    @return {Promise} a promise that will become fulfilled with the given
    `value`
  */
  function resolve$2(value, label) {
    return Promise.resolve(value, label);
  }

  /**
    This is a convenient alias for `Promise.reject`.

    @method reject
    @public
    @static
    @for rsvp
    @param {*} reason value that the returned promise will be rejected with.
    @param {String} [label] optional string for identifying the returned promise.
    Useful for tooling.
    @return {Promise} a promise rejected with the given `reason`.
  */
  function reject$2(reason, label) {
    return Promise.reject(reason, label);
  }

  function _possibleConstructorReturn$4(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var EMPTY_OBJECT = {};

  var FilterEnumerator = function (_MapEnumerator) {
    _inherits$4(FilterEnumerator, _MapEnumerator);

    function FilterEnumerator() {
      return _possibleConstructorReturn$4(this, _MapEnumerator.apply(this, arguments));
    }

    FilterEnumerator.prototype._checkFullfillment = function _checkFullfillment() {
      if (this._remaining === 0 && this._result !== null) {
        var result = this._result.filter(function (val) {
          return val !== EMPTY_OBJECT;
        });
        fulfill(this.promise, result);
        this._result = null;
      }
    };

    FilterEnumerator.prototype._setResultAt = function _setResultAt(state, i, value, firstPass) {
      if (firstPass) {
        this._result[i] = value;
        var val = tryCatch(this._mapFn)(value, i);
        if (val === TRY_CATCH_ERROR) {
          this._settledAt(REJECTED, i, val.error, false);
        } else {
          this._eachEntry(val, i, false);
        }
      } else {
        this._remaining--;
        if (!value) {
          this._result[i] = EMPTY_OBJECT;
        }
      }
    };

    return FilterEnumerator;
  }(MapEnumerator);

  /**
   `filter` is similar to JavaScript's native `filter` method.
   `filterFn` is eagerly called meaning that as soon as any promise
    resolves its value will be passed to `filterFn`. `filter` returns
    a promise that will become fulfilled with the result of running
    `filterFn` on the values the promises become fulfilled with.

    For example:

    ```javascript
    import { filter, resolve } from 'rsvp';

    let promise1 = resolve(1);
    let promise2 = resolve(2);
    let promise3 = resolve(3);

    let promises = [promise1, promise2, promise3];

    let filterFn = function(item){
      return item > 1;
    };

    filter(promises, filterFn).then(function(result){
      // result is [ 2, 3 ]
    });
    ```

    If any of the `promises` given to `filter` are rejected, the first promise
    that is rejected will be given as an argument to the returned promise's
    rejection handler. For example:

    ```javascript
    import { filter, reject, resolve } from 'rsvp';

    let promise1 = resolve(1);
    let promise2 = reject(new Error('2'));
    let promise3 = reject(new Error('3'));
    let promises = [ promise1, promise2, promise3 ];

    let filterFn = function(item){
      return item > 1;
    };

    filter(promises, filterFn).then(function(array){
      // Code here never runs because there are rejected promises!
    }, function(reason) {
      // reason.message === '2'
    });
    ```

    `filter` will also wait for any promises returned from `filterFn`.
    For instance, you may want to fetch a list of users then return a subset
    of those users based on some asynchronous operation:

    ```javascript
    import { filter, resolve } from 'rsvp';

    let alice = { name: 'alice' };
    let bob   = { name: 'bob' };
    let users = [ alice, bob ];

    let promises = users.map(function(user){
      return resolve(user);
    });

    let filterFn = function(user){
      // Here, Alice has permissions to create a blog post, but Bob does not.
      return getPrivilegesForUser(user).then(function(privs){
        return privs.can_create_blog_post === true;
      });
    };
    filter(promises, filterFn).then(function(users){
      // true, because the server told us only Alice can create a blog post.
      users.length === 1;
      // false, because Alice is the only user present in `users`
      users[0] === bob;
    });
    ```

    @method filter
    @public
    @static
    @for rsvp
    @param {Array} promises
    @param {Function} filterFn - function to be called on each resolved value to
    filter the final results.
    @param {String} [label] optional string describing the promise. Useful for
    tooling.
    @return {Promise}
  */

  function filter(promises, filterFn, label) {
    if (typeof filterFn !== 'function') {
      return Promise.reject(new TypeError("filter expects function as a second argument"), label);
    }

    return Promise.resolve(promises, label).then(function (promises) {
      if (!Array.isArray(promises)) {
        throw new TypeError("filter must be called with an array");
      }
      return new FilterEnumerator(Promise, promises, filterFn, label).promise;
    });
  }

  var len = 0;
  var vertxNext = void 0;
  function asap(callback, arg) {
    queue$1[len] = callback;
    queue$1[len + 1] = arg;
    len += 2;
    if (len === 2) {
      // If len is 1, that means that we need to schedule an async flush.
      // If additional callbacks are queued before the queue is flushed, they
      // will be processed by this flush that we are scheduling.
      scheduleFlush$1();
    }
  }

  var browserWindow = typeof window !== 'undefined' ? window : undefined;
  var browserGlobal = browserWindow || {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

  // test for web worker but not in IE10
  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

  // node
  function useNextTick() {
    var nextTick = process.nextTick;
    // node version 0.10.x displays a deprecation warning when nextTick is used recursively
    // setImmediate should be used instead instead
    var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
    if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
      nextTick = setImmediate;
    }
    return function () {
      return nextTick(flush);
    };
  }

  // vertx
  function useVertxTimer() {
    if (typeof vertxNext !== 'undefined') {
      return function () {
        vertxNext(flush);
      };
    }
    return useSetTimeout();
  }

  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, { characterData: true });

    return function () {
      return node.data = iterations = ++iterations % 2;
    };
  }

  // web worker
  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function () {
      return channel.port2.postMessage(0);
    };
  }

  function useSetTimeout() {
    return function () {
      return setTimeout(flush, 1);
    };
  }

  var queue$1 = new Array(1000);

  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue$1[i];
      var arg = queue$1[i + 1];

      callback(arg);

      queue$1[i] = undefined;
      queue$1[i + 1] = undefined;
    }

    len = 0;
  }

  function attemptVertex() {
    try {
      var vertx = Function('return this')().require('vertx');
      vertxNext = vertx.runOnLoop || vertx.runOnContext;
      return useVertxTimer();
    } catch (e) {
      return useSetTimeout();
    }
  }

  var scheduleFlush$1 = void 0;
  // Decide what async method to use to triggering processing of queued callbacks:
  if (isNode) {
    scheduleFlush$1 = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush$1 = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush$1 = useMessageChannel();
  } else if (browserWindow === undefined && typeof require === 'function') {
    scheduleFlush$1 = attemptVertex();
  } else {
    scheduleFlush$1 = useSetTimeout();
  }

  // defaults
  config.async = asap;
  config.after = function (cb) {
    return setTimeout(cb, 0);
  };
  var cast = resolve$2;

  var async = function (callback, arg) {
    return config.async(callback, arg);
  };

  function on() {
    config.on.apply(config, arguments);
  }

  function off() {
    config.off.apply(config, arguments);
  }

  // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`
  if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
    var callbacks = window['__PROMISE_INSTRUMENTATION__'];
    configure('instrument', true);
    for (var eventName in callbacks) {
      if (callbacks.hasOwnProperty(eventName)) {
        on(eventName, callbacks[eventName]);
      }
    }
  }

  // the default export here is for backwards compat:
  //   https://github.com/tildeio/rsvp.js/issues/434
  var rsvp = {
    asap: asap,
    cast: cast,
    Promise: Promise,
    EventTarget: EventTarget,
    all: all$1,
    allSettled: allSettled,
    race: race$1,
    hash: hash,
    hashSettled: hashSettled,
    rethrow: rethrow,
    defer: defer,
    denodeify: denodeify,
    configure: configure,
    on: on,
    off: off,
    resolve: resolve$2,
    reject: reject$2,
    map: map,
    async: async,
    filter: filter
  };

  exports.default = rsvp;
  exports.asap = asap;
  exports.cast = cast;
  exports.Promise = Promise;
  exports.EventTarget = EventTarget;
  exports.all = all$1;
  exports.allSettled = allSettled;
  exports.race = race$1;
  exports.hash = hash;
  exports.hashSettled = hashSettled;
  exports.rethrow = rethrow;
  exports.defer = defer;
  exports.denodeify = denodeify;
  exports.configure = configure;
  exports.on = on;
  exports.off = off;
  exports.resolve = resolve$2;
  exports.reject = reject$2;
  exports.map = map;
  exports.async = async;
  exports.filter = filter;

  Object.defineProperty(exports, '__esModule', { value: true });

})));







},{}],33:[function(require,module,exports){
"use strict";

module.exports = {
  // OECD countries
  AUS: ['IDN', 'JPN', 'KOR', 'NZL'],
  AUT: ['CHE', 'CZE', 'DEU', 'HUN', 'SVK', 'SVN'],
  BEL: ['DEU', 'FRA', 'LUX', 'NLD'],
  CAN: ['USA', 'ISL'],
  CHE: ['AUT', 'DEU', 'FRA', 'ITA'],
  CHL: ['BRA', 'MEX'],
  CZE: ['AUT', 'GER', 'POL', 'SVK'],
  DEU: ['AUT', 'BEL', 'CHE', 'CZE', 'DNK', 'FRA', 'LUX', 'NLD', 'POL'],
  DNK: ['DEU', 'NOR', 'SWE'],
  ESP: ['FRA', 'PRT'],
  EST: ['FIN', 'RUS', 'SWE'],
  FIN: ['EST', 'RUS', 'SWE'],
  FRA: ['BEL', 'DEU', 'ESP', 'GBR', 'LUX'],
  GBR: ['FRA', 'IRL', 'NOR'],
  GRC: ['HUN', 'ITA', 'SVN', 'TUR'],
  HUN: ['AUT', 'GRC', 'SVK'],
  IRL: ['GBR', 'USA'],
  ISL: ['CAN', 'NOR'],
  ISR: ['TUR'],
  ITA: ['AUT', 'CHE', 'FRA', 'SVN'],
  JPN: ['AUS'],
  KOR: ['AUS', 'JPN', 'RUS', 'CHN'],
  LUX: ['BEL', 'DEU', 'FRA'],
  MEX: ['BRA', 'CHL', 'USA'],
  NLD: ['BEL', 'DEU'],
  NOR: ['DNK', 'GBR', 'ISL', 'SWE'],
  NZL: ['AUS'],
  POL: ['CZE', 'DEU', 'EST', 'RUS', 'SVK'],
  PRT: ['ESP', 'USA'],
  RUS: ['CHN', 'EST', 'FIN', 'KOR', 'SVK'],
  SVK: ['AUT', 'CZE', 'HUN', 'POL', 'RUS'],
  SVN: ['AUT', 'GRC', 'ITA'],
  SWE: ['DNK', 'EST', 'FIN', 'NOR'],
  TUR: ['GRC', 'ISR'],
  USA: ['CAN', 'MEX', 'PRT'],
  // B(R)IICS
  BRA: ['CHL', 'ZAF'],
  IDN: ['AUS', 'CHN', 'NZL'],
  IND: ['CHN'],
  CHN: ['IND', 'JPN', 'KOR', 'RUS'],
  ZAF: ['BRA'],
  // Nordic Portal
  // Greenland
  GRL: ['CAN', 'ISL', 'IRL'],
  // land Islands
  ALA: ['SWE', 'FIN', 'EST'],
  // Faroe Islands
  FRO: ['ISL', 'NOR', 'GBR']
};

},{}],34:[function(require,module,exports){
"use strict";

module.exports = {
  "type": "Topology",
  "objects": {
    "land": {
      "type": "MultiPolygon",
      "bbox": [-180, -90.00000000000003, 180.00000000000014, 83.64513000000002],
      "arcs": [[[0]], [[1]], [[2]], [[3]], [[4]], [[5]], [[6]], [[7]], [[8]], [[9]], [[10]], [[11]], [[12]], [[13]], [[14]], [[15]], [[16, 17]], [[18, -18]], [[19]], [[20]], [[21]], [[22]], [[23]], [[24]], [[25]], [[26]], [[27]], [[28]], [[29]], [[30]], [[31]], [[32]], [[33]], [[34]], [[35]], [[36]], [[37]], [[38]], [[39]], [[40]], [[41]], [[42]], [[43]], [[44]], [[45]], [[46]], [[47]], [[48]], [[49]], [[50]], [[51]], [[52]], [[53]], [[54]], [[55]], [[56]], [[57]], [[58]], [[59]], [[60]], [[61]], [[62]], [[63]], [[64]], [[65]], [[66]], [[67]], [[68]], [[69]], [[70]], [[71]], [[72]], [[73]], [[74]], [[75]], [[76]], [[77]], [[78]], [[79]], [[80]], [[81]], [[82]], [[83]], [[84]], [[85]], [[86]], [[87]], [[88]], [[89]], [[90]], [[91]], [[92]], [[93]], [[94]], [[95]], [[96]], [[97]], [[98]], [[99]], [[100]], [[101]], [[102]], [[103]], [[104]], [[105]], [[106]], [[107]], [[108]], [[109]], [[110]], [[111]], [[112]], [[113], [114]], [[115]], [[116]], [[117]], [[118]], [[119]], [[120]], [[121]], [[122]], [[123]], [[124]], [[125]], [[126]], [[127]], [[128]]]
    },
    "capitals": [{
      "id": "VAT",
      "lat": 41.9000122264,
      "long": 12.4478083889
    }, {
      "id": "SMR",
      "lat": 43.9171500845,
      "long": 12.4666702867
    }, {
      "id": "LIE",
      "lat": 47.1337237743,
      "long": 9.51666947291
    }, {
      "id": "LUX",
      "lat": 49.6116603791,
      "long": 6.13000280623
    }, {
      "id": "FSM",
      "lat": 6.91664369601,
      "long": 158.149974324
    }, {
      "id": "MHL",
      "lat": 7.10300431122,
      "long": 171.380000176
    }, {
      "id": "TUV",
      "lat": -8.51665199904,
      "long": 179.216647094
    }, {
      "id": "PLW",
      "lat": 7.48739617298,
      "long": 134.626548467
    }, {
      "id": "MCO",
      "lat": 43.7396456879,
      "long": 7.40691317347
    }, {
      "id": "KIR",
      "lat": 1.33818750562,
      "long": 173.017570829
    }, {
      "id": "COM",
      "lat": -11.7041576957,
      "long": 43.2402440987
    }, {
      "id": "AND",
      "lat": 42.5000014435,
      "long": 1.51648596051
    }, {
      "id": "TTO",
      "lat": 10.6519970896,
      "long": -61.5170308854
    }, {
      "id": "RWA",
      "lat": -1.95359006868,
      "long": 30.0605317777
    }, {
      "id": "SWZ",
      "lat": -26.3166507784,
      "long": 31.1333345121
    }, {
      "id": "SSD",
      "lat": 4.82997519828,
      "long": 31.5800255928
    }, {
      "id": "SVN",
      "lat": 46.0552883088,
      "long": 14.5149690335
    }, {
      "id": "SVK",
      "lat": 48.15001833,
      "long": 17.1169807522
    }, {
      "id": "QAT",
      "lat": 25.2865560089,
      "long": 51.5329678943
    }, {
      "id": "MNE",
      "lat": 42.4659725129,
      "long": 19.2663069241
    }, {
      "id": "CHE",
      "lat": 46.9166827587,
      "long": 7.46697546248
    }, {
      "id": "KOS",
      "lat": 42.6667096141,
      "long": 21.1659842516
    }, {
      "id": "DMA",
      "lat": 15.3010156443,
      "long": -61.3870129818
    }, {
      "id": "DJI",
      "lat": 11.5950144643,
      "long": 43.1480016671
    }, {
      "id": "GMB",
      "lat": 13.4538764603,
      "long": -16.5917014892
    }, {
      "id": "MKD",
      "lat": 42.0000061229,
      "long": 21.4334614651
    }, {
      "id": "BRB",
      "lat": 13.1020025828,
      "long": -59.6165267351
    }, {
      "id": "BDI",
      "lat": -3.37608722037,
      "long": 29.3600060615
    }, {
      "id": "VCT",
      "lat": 13.1482788279,
      "long": -61.2120624203
    }, {
      "id": "LCA",
      "lat": 14.0019734893,
      "long": -61.0000081804
    }, {
      "id": "KNA",
      "lat": 17.3020304555,
      "long": -62.7170093197
    }, {
      "id": "MUS",
      "lat": -20.1666385714,
      "long": 57.4999938546
    }, {
      "id": "GRD",
      "lat": 12.0526334017,
      "long": -61.7416432261
    }, {
      "id": "BHR",
      "lat": 26.2361362905,
      "long": 50.5830517159
    }, {
      "id": "ATG",
      "lat": 17.1180365183,
      "long": -61.8500338151
    }, {
      "id": "URY",
      "lat": -34.8580415662,
      "long": -56.1710522884
    }, {
      "id": "TGO",
      "lat": 6.13193707166,
      "long": 1.22275711936
    }, {
      "id": "TUN",
      "lat": 36.8027781362,
      "long": 10.1796780992
    }, {
      "id": "ARE",
      "lat": 24.4666835724,
      "long": 54.3665933826
    }, {
      "id": "TKM",
      "lat": 37.9499949331,
      "long": 58.3832991118
    }, {
      "id": "ZMB",
      "lat": -15.4166442679,
      "long": 28.2833275947
    }, {
      "id": "ZWE",
      "lat": -17.8177896944,
      "long": 31.0447094307
    }, {
      "id": "TLS",
      "lat": -8.55938840855,
      "long": 125.579455932
    }, {
      "id": "VUT",
      "lat": -17.733350404,
      "long": 168.316640584
    }, {
      "id": "HND",
      "lat": 14.1020449005,
      "long": -87.2175293393
    }, {
      "id": "GUY",
      "lat": 6.80197369275,
      "long": -58.1670286475
    }, {
      "id": "ISL",
      "lat": 64.1500236197,
      "long": -21.9500144872
    }, {
      "id": "HTI",
      "lat": 18.5410245961,
      "long": -72.3360345883
    }, {
      "id": "UGA",
      "lat": 0.31665895477,
      "long": 32.5833235257
    }, {
      "id": "SUR",
      "lat": 5.83503012992,
      "long": -55.1670308854
    }, {
      "id": "NER",
      "lat": 13.5167059519,
      "long": 2.11665604514
    }, {
      "id": "TJK",
      "lat": 38.5600352163,
      "long": 68.7738793527
    }, {
      "id": "PRY",
      "lat": -25.2964029757,
      "long": -57.6415051693
    }, {
      "id": "NIC",
      "lat": 12.1530165801,
      "long": -86.2684916603
    }, {
      "id": "SLE",
      "lat": 8.47001141249,
      "long": -13.2342157404
    }, {
      "id": "PAK",
      "lat": 33.6999959503,
      "long": 73.1666344797
    }, {
      "id": "NPL",
      "lat": 27.7166919139,
      "long": 85.3166422108
    }, {
      "id": "ZAF",
      "lat": -29.1199938774,
      "long": 26.2299128812
    }, {
      "id": "ZAF",
      "lat": -25.7069205538,
      "long": 28.2294290758
    }, {
      "id": "PNG",
      "lat": -9.46470782587,
      "long": 147.192503621
    }, {
      "id": "SLB",
      "lat": -9.43799429509,
      "long": 159.949765734
    }, {
      "id": "PAN",
      "lat": 8.96801719048,
      "long": -79.5330371518
    }, {
      "id": "MAR",
      "lat": 34.0252990916,
      "long": -6.83613082013
    }, {
      "id": "MDA",
      "lat": 47.0050236197,
      "long": 28.8577111397
    }, {
      "id": "MOZ",
      "lat": -25.9552774874,
      "long": 32.5891629626
    }, {
      "id": "SOM",
      "lat": 2.06668133433,
      "long": 45.3666776111
    }, {
      "id": "OMN",
      "lat": 23.6133248077,
      "long": 58.5933121326
    }, {
      "id": "LKA",
      "lat": 6.93196575818,
      "long": 79.8577506093
    }, {
      "id": "MNG",
      "lat": 47.9166733999,
      "long": 106.916615762
    }, {
      "id": "NZL",
      "lat": -41.2999739393,
      "long": 174.783274291
    }, {
      "id": "NAM",
      "lat": -22.5700060844,
      "long": 17.0835461005
    }, {
      "id": "NGA",
      "lat": 9.08333314914,
      "long": 7.53332800155
    }, {
      "id": "GNB",
      "lat": 11.865023823,
      "long": -15.5983608413
    }, {
      "id": "JOR",
      "lat": 31.9500252472,
      "long": 35.9332999255
    }, {
      "id": "LTU",
      "lat": 54.6833663118,
      "long": 25.3166352933
    }, {
      "id": "LVA",
      "lat": 56.9500238232,
      "long": 24.0999653714
    }, {
      "id": "KGZ",
      "lat": 42.8730794465,
      "long": 74.5852042225
    }, {
      "id": "LSO",
      "lat": -29.3166743787,
      "long": 27.48327307
    }, {
      "id": "MDG",
      "lat": -18.9166373506,
      "long": 47.5166239001
    }, {
      "id": "ECU",
      "lat": -0.21498818065,
      "long": -78.5000511085
    }, {
      "id": "CRI",
      "lat": 9.93501242974,
      "long": -84.0840513527
    }, {
      "id": "SLV",
      "lat": 13.7100016469,
      "long": -89.2030412208
    }, {
      "id": "JAM",
      "lat": 17.9770766238,
      "long": -76.7674337137
    }, {
      "id": "TCD",
      "lat": 12.1130965362,
      "long": 15.0491483141
    }, {
      "id": "GNQ",
      "lat": 3.75001527803,
      "long": 8.78327754582
    }, {
      "id": "ERI",
      "lat": 15.3333392527,
      "long": 38.9333235258
    }, {
      "id": "HRV",
      "lat": 45.8000067333,
      "long": 15.9999946682
    }, {
      "id": "EST",
      "lat": 59.4338773795,
      "long": 24.7280407295
    }, {
      "id": "MWI",
      "lat": -13.9832950655,
      "long": 33.78330196
    }, {
      "id": "GTM",
      "lat": 14.6211346628,
      "long": -90.5269655779
    }, {
      "id": "GAB",
      "lat": 0.38538860972,
      "long": 9.45796504582
    }, {
      "id": "FJI",
      "lat": -18.1330159314,
      "long": 178.441707315
    }, {
      "id": "MRT",
      "lat": 18.0864270212,
      "long": -15.9753404149
    }, {
      "id": "MLI",
      "lat": 12.6500146677,
      "long": -8.00003910464
    }, {
      "id": "LBN",
      "lat": 33.871975117,
      "long": 35.50970821
    }, {
      "id": "GEO",
      "lat": 41.7250099885,
      "long": 44.7907954496
    }, {
      "id": "KAZ",
      "lat": 51.1811253043,
      "long": 71.4277742095
    }, {
      "id": "LAO",
      "lat": 17.9666927276,
      "long": 102.59998002
    }, {
      "id": "COG",
      "lat": -4.25918577181,
      "long": 15.2846894925
    }, {
      "id": "GIN",
      "lat": 9.53152284641,
      "long": -13.6802350275
    }, {
      "id": "CIV",
      "lat": 6.81838096,
      "long": -5.27550256491
    }, {
      "id": "CAN",
      "lat": 45.4166967967,
      "long": -75.7000153012
    }, {
      "id": "SRB",
      "lat": 44.8186454458,
      "long": 20.4679906806
    }, {
      "id": "BRN",
      "lat": 4.88333111462,
      "long": 114.933284057
    }, {
      "id": "BOL",
      "lat": -19.0409708467,
      "long": -65.2595156267
    }, {
      "id": "BLZ",
      "lat": 17.2520335072,
      "long": -88.7670729998
    }, {
      "id": "CAF",
      "lat": 4.36664430635,
      "long": 18.5582881253
    }, {
      "id": "CMR",
      "lat": 3.86670066214,
      "long": 11.5166507555
    }, {
      "id": "ALB",
      "lat": 41.3275407095,
      "long": 19.8188830146
    }, {
      "id": "ARM",
      "lat": 40.1811507355,
      "long": 44.5135513904
    }, {
      "id": "AZE",
      "lat": 40.3952720327,
      "long": 49.8622171619
    }, {
      "id": "KHM",
      "lat": 11.5500301299,
      "long": 104.91663448
    }, {
      "id": "BOL",
      "lat": -16.4979736137,
      "long": -68.1499851905
    }, {
      "id": "BEN",
      "lat": 6.40000856417,
      "long": 2.51999059918
    }, {
      "id": "BGR",
      "lat": 42.6833494253,
      "long": 23.3166540107
    }, {
      "id": "BLR",
      "lat": 53.8999774364,
      "long": 27.5666271553
    }, {
      "id": "BTN",
      "lat": 27.4729858592,
      "long": 89.639014037
    }, {
      "id": "BWA",
      "lat": -24.6463134574,
      "long": 25.9119477933
    }, {
      "id": "AUS",
      "lat": -35.2830285454,
      "long": 149.129026244
    }, {
      "id": "BFA",
      "lat": 12.3703159779,
      "long": -1.5247237563
    }, {
      "id": "BIH",
      "lat": 43.850022399,
      "long": 18.383001667
    }, {
      "id": "MMR",
      "lat": 19.7665570261,
      "long": 96.1186185292
    }, {
      "id": "TON",
      "lat": -21.1385123567,
      "long": -175.220564478
    }, {
      "id": "SOL",
      "lat": 9.56002239882,
      "long": 44.0653100167
    }, {
      "id": "SYC",
      "lat": -4.61663165397,
      "long": 55.4499897856
    }, {
      "id": "STP",
      "lat": 0.33340211883,
      "long": 6.73332515323
    }, {
      "id": "WSM",
      "lat": -13.8415450424,
      "long": -171.738641609
    }, {
      "id": "MLT",
      "lat": 35.8997324819,
      "long": 14.5147106513
    }, {
      "id": "MDV",
      "lat": 4.16670818981,
      "long": 73.499947468
    }, {
      "id": "ISR",
      "lat": 31.7784078156,
      "long": 35.2066259346
    }, {
      "id": "CPV",
      "lat": 14.9166980173,
      "long": -23.516688885
    }, {
      "id": "BHS",
      "lat": 25.0833901154,
      "long": -77.3500437843
    }, {
      "id": "CYP",
      "lat": 35.1666764517,
      "long": 33.3666348864
    }, {
      "id": "VNM",
      "lat": 21.0333272491,
      "long": 105.8500142
    }, {
      "id": "TUR",
      "lat": 39.9272385855,
      "long": 32.864391641
    }, {
      "id": "HUN",
      "lat": 47.5000063264,
      "long": 19.0833206774
    }, {
      "id": "YEM",
      "lat": 15.3547332957,
      "long": 44.2065933826
    }, {
      "id": "ROU",
      "lat": 44.4333718049,
      "long": 26.099946654
    }, {
      "id": "SYR",
      "lat": 33.5000339956,
      "long": 36.299995889
    }, {
      "id": "PRT",
      "lat": 38.7227228779,
      "long": -9.14486630549
    }, {
      "id": "SDN",
      "lat": 15.5880782257,
      "long": 32.5341792386
    }, {
      "id": "NOR",
      "lat": 59.9166902864,
      "long": 10.749979206
    }, {
      "id": "POL",
      "lat": 52.2500006298,
      "long": 20.9999995511
    }, {
      "id": "PRK",
      "lat": 39.0194386994,
      "long": 125.754690714
    }, {
      "id": "TZA",
      "lat": -6.80001259474,
      "long": 39.2683418363
    }, {
      "id": "IRL",
      "lat": 53.333061136,
      "long": -6.24890568178
    }, {
      "id": "LBR",
      "lat": 6.31055665987,
      "long": -10.8047516291
    }, {
      "id": "MYS",
      "lat": 3.1666658721,
      "long": 101.699983275
    }, {
      "id": "CUB",
      "lat": 23.1319588409,
      "long": -82.3641821713
    }, {
      "id": "CZE",
      "lat": 50.0833370149,
      "long": 14.4659797757
    }, {
      "id": "KWT",
      "lat": 29.36971763,
      "long": 47.9783011462
    }, {
      "id": "DOM",
      "lat": 18.4700728546,
      "long": -69.9000850847
    }, {
      "id": "GHA",
      "lat": 5.55003460583,
      "long": -0.21671574035
    }, {
      "id": "LBY",
      "lat": 32.8925000194,
      "long": 13.1800117581
    }, {
      "id": "FIN",
      "lat": 60.175563374,
      "long": 24.9341263415
    }, {
      "id": "DNK",
      "lat": 55.6785641904,
      "long": 12.5634857473
    }, {
      "id": "CIV",
      "lat": 5.31999696749,
      "long": -4.04004825989
    }, {
      "id": "BRA",
      "lat": -15.7833402315,
      "long": -47.9160522884
    }, {
      "id": "BEL",
      "lat": 50.8333170767,
      "long": 4.3333166083
    }, {
      "id": "BGD",
      "lat": 23.7230597117,
      "long": 90.4085794667
    }, {
      "id": "AGO",
      "lat": -8.83828611363,
      "long": 13.2344270413
    }, {
      "id": "DZA",
      "lat": 36.763064798,
      "long": 3.05055252952
    }, {
      "id": "MMR",
      "lat": 16.7833541046,
      "long": 96.1666776113
    }, {
      "id": "VEN",
      "lat": 10.5009985544,
      "long": -66.9170371924
    }, {
      "id": "UKR",
      "lat": 50.433367329,
      "long": 30.5166279691
    }, {
      "id": "UZB",
      "lat": 41.311701883,
      "long": 69.2949328195
    }, {
      "id": "ESP",
      "lat": 40.4000262645,
      "long": -3.683351686
    }, {
      "id": "SWE",
      "lat": 59.3507599543,
      "long": 18.0973347328
    }, {
      "id": "THA",
      "lat": 13.7499992055,
      "long": 100.516644652
    }, {
      "id": "PER",
      "lat": -12.0480126761,
      "long": -77.0500620948
    }, {
      "id": "SEN",
      "lat": 14.715831725,
      "long": -17.4731301284
    }, {
      "id": "ZAF",
      "lat": -26.17004474,
      "long": 28.0300097236
    }, {
      "id": "NLD",
      "lat": 52.3499686881,
      "long": 4.91664017601
    }, {
      "id": "KOR",
      "lat": 37.5663490998,
      "long": 126.999730997
    }, {
      "id": "PHL",
      "lat": 14.6041589548,
      "long": 120.982217162
    }, {
      "id": "DEU",
      "lat": 52.5218186636,
      "long": 13.4015486233
    }, {
      "id": "COD",
      "lat": -4.32972410189,
      "long": 15.3149718818
    }, {
      "id": "IND",
      "lat": 28.6000230092,
      "long": 77.1999800201
    }, {
      "id": "GRC",
      "lat": 37.9833262319,
      "long": 23.7333210843
    }, {
      "id": "IRQ",
      "lat": 33.3386484975,
      "long": 44.3938687732
    }, {
      "id": "ETH",
      "lat": 9.03331036268,
      "long": 38.700004434
    }, {
      "id": "IRN",
      "lat": 35.6719427684,
      "long": 51.4243440336
    }, {
      "id": "ARG",
      "lat": -34.6025016085,
      "long": -58.3975313737
    }, {
      "id": "AFG",
      "lat": 34.5166902863,
      "long": 69.1832600493
    }, {
      "id": "AUT",
      "lat": 48.2000152782,
      "long": 16.3666389554
    }, {
      "id": "TWN",
      "lat": 25.03583333333,
      "long": 121.56833333333
    }, {
      "id": "USA",
      "lat": 38.8995493765,
      "long": -77.0094185808
    }, {
      "id": "GBR",
      "lat": 51.4999947297,
      "long": -0.11672184386
    }, {
      "id": "SAU",
      "lat": 24.6408331492,
      "long": 46.7727416573
    }, {
      "id": "ZAF",
      "lat": -33.9200109672,
      "long": 18.4349881578
    }, {
      "id": "RUS",
      "lat": 55.7521641226,
      "long": 37.6155228259
    }, {
      "id": "MEX",
      "lat": 19.4424424428,
      "long": -99.1309882017
    }, {
      "id": "ITA",
      "lat": 41.8959556265,
      "long": 12.4832584215
    }, {
      "id": "CHN",
      "lat": 39.9288922313,
      "long": 116.388285684
    }, {
      "id": "KEN",
      "lat": -1.28334674185,
      "long": 36.8166568591
    }, {
      "id": "IDN",
      "lat": -6.17441770541,
      "long": 106.829437621
    }, {
      "id": "COL",
      "lat": 4.59642356253,
      "long": -74.0833439552
    }, {
      "id": "EGY",
      "lat": 30.0499603465,
      "long": 31.2499682197
    }, {
      "id": "JPN",
      "lat": 35.6850169058,
      "long": 139.751407429
    }, {
      "id": "FRA",
      "lat": 48.8666929312,
      "long": 2.33333532574
    }, {
      "id": "CHL",
      "lat": -33.4500138155,
      "long": -70.6670408546
    }, {
      "id": "SGP",
      "lat": 1.29303346649,
      "long": 103.855820678
    }, {
      "id": "GRL",
      "lat": 64.18141,
      "long": -51.69414
    }, {
      "id": "ALA",
      "lat": 60.0970945,
      "long": 19.934833900000058
    }, {
      "id": "FRO",
      "lat": 62.007864,
      "long": -6.790982
    }]
  },
  "arcs": [[[33452, 5736], [-82, -294], [-81, -259], [-582, 79], [-621, -34], [-348, 192], [0, 22], [-152, 170], [625, -23], [599, -56], [207, 237], [147, 203], [288, -237]], [[5775, 6048], [-533, -79], [-364, 204], [-163, 203], [-11, 34], [-180, 158], [169, 214], [517, -90], [277, -181], [212, -203], [76, -260]], [[37457, 6883], [342, -248], [120, -350], [33, -248], [11, -293], [-430, -181], [-452, -146], [-522, -136], [-582, -113], [-658, 34], [-365, 192], [49, 237], [593, 158], [239, 192], [174, 248], [126, 214], [168, 203], [180, 238], [0, -1], [141, 0], [414, 125], [419, -125]], [[16330, 9501], [359, -90], [332, 102], [-158, -203], [-261, -147], [-386, 45], [-278, 203], [60, 192], [332, -102]], [[15122, 9513], [425, -226], [-164, 23], [-359, 56], [-381, 158], [202, 124], [277, -135]], [[22505, 10404], [305, -79], [304, 68], [163, -327], [-217, 45], [-337, -23], [-343, 23], [-376, -34], [-283, 113], [-146, 237], [174, 101], [353, -79], [403, -45]], [[30985, 10967], [33, -259], [-49, -226], [-76, -214], [-326, -79], [-311, -113], [-364, 11], [136, 226], [-327, -79], [-310, -79], [-212, 169], [-16, 237], [305, 226], [190, 67], [321, -22], [82, 293], [16, 215], [-6, 462], [158, 271], [256, 90], [147, -214], [65, -214], [120, -260], [92, -248], [76, -260]], [[0, 3044], [16, -4], [245, 335], [501, -181], [32, 21], [78, 48], [94, 59], [81, 51], [41, 25], [41, -1], [29, -10], [402, -239], [352, 239], [63, 33], [816, 102], [265, -135], [130, -68], [419, -192], [789, -147], [625, -180], [1072, -136], [800, 158], [1181, -113], [669, -180], [734, 169], [773, 158], [60, 271], [-1094, 22], [-898, 136], [-234, 225], [-745, 125], [49, 259], [103, 237], [104, 214], [-55, 237], [-462, 158], [-212, 204], [-430, 180], [675, -34], [642, 91], [402, -192], [495, 169], [457, 214], [223, 192], [-98, 237], [-359, 158], [-408, 169], [-571, 34], [-500, 79], [-539, 57], [-180, 214], [-359, 181], [-217, 203], [-87, 654], [136, -56], [250, -181], [457, 57], [441, 79], [228, -249], [441, 57], [370, 124], [348, 158], [315, 192], [419, 56], [-11, 215], [-97, 214], [81, 203], [359, 102], [163, -192], [425, 113], [321, 146], [397, 12], [375, 56], [376, 136], [299, 124], [337, 124], [218, -34], [190, -45], [414, 79], [370, -102], [381, 12], [364, 79], [375, -57], [414, -56], [386, 22], [403, -11], [413, -11], [381, 22], [283, 170], [337, 90], [349, -124], [331, 101], [300, 203], [179, -180], [98, -203], [180, -192], [288, 169], [332, -214], [375, -68], [321, -158], [392, 34], [354, 101], [418, -22], [376, -79], [381, -102], [147, 249], [-180, 191], [-136, 204], [-359, 45], [-158, 214], [-60, 214], [-98, 429], [213, -79], [364, -34], [359, 34], [327, -90], [283, -169], [119, -203], [376, -34], [359, 79], [381, 113], [342, 67], [283, -135], [370, 45], [239, 440], [224, -259], [321, -102], [348, 56], [228, -225], [365, -23], [337, -68], [332, -124], [218, 215], [108, 203], [278, -226], [381, 57], [283, -125], [190, -191], [370, 56], [288, 124], [283, 147], [337, 79], [392, 68], [354, 79], [272, 124], [163, 180], [65, 249], [-32, 236], [-87, 226], [-98, 226], [-87, 226], [-71, 203], [-16, 225], [27, 226], [130, 214], [109, 237], [44, 226], [-55, 248], [-32, 226], [136, 260], [152, 169], [180, 214], [190, 181], [223, 169], [109, 248], [152, 158], [174, 147], [267, 34], [174, 180], [196, 113], [228, 68], [202, 147], [157, 180], [218, 68], [163, -147], [-103, -192], [-283, -169], [-120, -124], [-206, 90], [-229, -56], [-190, -136], [-202, -146], [-136, -170], [-38, -225], [17, -215], [130, -191], [-190, -136], [-261, -45], [-153, -192], [-163, -180], [-174, -249], [-44, -214], [98, -237], [147, -181], [229, -135], [212, -181], [114, -225], [60, -215], [82, -225], [130, -192], [82, -215], [38, -530], [81, -214], [22, -226], [87, -226], [-38, -304], [-152, -237], [-163, -192], [-370, -79], [-125, -203], [-169, -192], [-419, -215], [-370, -90], [-348, -124], [-376, -124], [-223, -237], [-446, -23], [-489, 23], [-441, -45], [-468, 0], [87, -226], [424, -101], [311, -158], [174, -204], [-310, -180], [-479, 56], [-397, -146], [-17, -237], [-11, -226], [327, -192], [60, -214], [353, -215], [588, -90], [500, -158], [398, -180], [506, -181], [690, -90], [681, -158], [473, -170], [517, -191], [272, -271], [136, -215], [337, 204], [457, 169], [484, 180], [577, 147], [495, 158], [691, 11], [680, -79], [560, -135], [180, 248], [386, 169], [702, 12], [550, 124], [522, 124], [577, 79], [614, 102], [430, 146], [-196, 203], [-119, 203], [0, 215], [-539, -23], [-571, -90], [-544, 0], [-77, 214], [39, 429], [125, 124], [397, 136], [468, 135], [337, 169], [337, 170], [251, 225], [380, 102], [376, 79], [190, 45], [430, 23], [408, 79], [343, 112], [337, 136], [305, 135], [386, 181], [245, 192], [261, 169], [82, 226], [-294, 135], [98, 237], [185, 181], [288, 112], [305, 136], [283, 180], [217, 226], [136, 271], [202, 158], [331, -34], [136, -192], [332, -22], [11, 214], [142, 226], [299, -57], [71, -214], [331, -34], [360, 102], [348, 67], [315, -34], [120, -237], [305, 192], [283, 102], [315, 79], [310, 79], [283, 135], [310, 91], [240, 124], [168, 203], [207, -147], [288, 79], [202, -271], [157, -203], [316, 113], [125, 226], [283, 158], [365, -34], [108, -215], [229, 215], [299, 68], [326, 22], [294, -11], [310, -68], [300, -34], [130, -192], [180, -169], [304, 102], [327, 22], [315, 0], [310, 12], [278, 79], [294, 67], [245, 158], [261, 102], [283, 56], [212, 158], [152, 316], [158, 192], [288, -90], [109, -203], [239, -136], [289, 45], [196, -203], [206, -146], [283, 135], [98, 248], [250, 102], [289, 192], [272, 79], [326, 112], [218, 125], [228, 135], [218, 124], [261, -68], [250, 203], [180, 158], [261, -11], [229, 136], [54, 203], [234, 158], [228, 113], [278, 90], [256, 45], [244, -34], [262, -56], [223, -158], [27, -249], [245, -191], [168, -158], [332, -68], [185, -158], [229, -158], [266, -34], [223, 113], [240, 237], [261, -124], [272, -68], [261, -68], [272, -45], [277, 0], [229, -598], [-11, -147], [-33, -259], [-266, -147], [-218, -214], [38, -226], [310, 11], [-38, -225], [-141, -215], [-131, -237], [212, -180], [321, -57], [321, 102], [153, 226], [92, 214], [153, 181], [174, 169], [70, 203], [147, 282], [174, 57], [316, 22], [277, 68], [283, 90], [136, 226], [82, 214], [190, 215], [272, 146], [234, 113], [153, 192], [157, 101], [202, 91], [277, -57], [250, 57], [272, 67], [305, -33], [201, 158], [142, 383], [103, -158], [131, -271], [234, -112], [266, -46], [267, 68], [283, -45], [261, -11], [174, 56], [234, -34], [212, -124], [250, 79], [300, 0], [255, 79], [289, -79], [185, 192], [141, 192], [191, 158], [348, 429], [179, -79], [212, -158], [185, -203], [354, -350], [272, -12], [256, 0], [299, 68], [299, 79], [229, 158], [190, 169], [310, 23], [207, 124], [218, -113], [141, -180], [196, -181], [305, 23], [190, -147], [332, -147], [348, -56], [288, 45], [218, 181], [185, 180], [250, 45], [251, -79], [288, -56], [261, 90], [250, 0], [245, -56], [256, -57], [250, 102], [299, 90], [283, 23], [316, 0], [255, 56], [251, 45], [76, 282], [11, 237], [174, -158], [49, -259], [92, -237], [115, -192], [234, -102], [315, 34], [365, 12], [250, 33], [364, 0], [262, 12], [364, -23], [310, -45], [196, -181], [-54, -214], [179, -169], [299, -136], [310, -146], [360, -102], [375, -90], [283, -90], [315, -12], [180, 192], [245, -158], [212, -180], [245, -136], [337, -56], [321, -68], [136, -226], [316, -135], [212, -203], [310, -90], [321, 11], [299, -34], [332, 11], [332, -45], [310, -79], [288, -135], [289, -113], [195, -169], [-32, -226], [-147, -203], [-125, -260], [-98, -203], [-131, -237], [-364, -90], [-163, -203], [-360, -124], [-125, -226], [-190, -214], [-201, -181], [-115, -237], [-70, -214], [-28, -260], [6, -214], [158, -226], [60, -214], [130, -204], [517, -78], [109, -249], [-501, -90], [-424, -124], [-528, -23], [-234, -327], [-49, -271], [-119, -214], [-147, -215], [370, -191], [141, -237], [239, -215], [338, -192], [386, -180], [419, -181], [636, -180], [142, -282], [800, -125], [53, -44], [208, -170], [767, 147], [636, -181], [-99520, -139]], [[31180, 20818], [361, -345], [389, -144], [-125, -288], [-264, -29], [-141, 203], [-92, -233], [-238, -178], [-301, 64], [-202, 174], [-291, 83], [-350, 322], [-283, 309], [-383, 645], [229, -121], [390, -384], [369, -207], [143, 264], [90, 394], [256, 238], [198, -68], [106, -267], [139, -432]], [[33736, 22402], [222, -259], [-83, -202], [-375, -173], [-125, 202], [-236, -259], [-139, 259], [333, 345], [236, -144], [167, 231]], [[69522, 23202], [-427, -37], [-7, 306], [41, 238], [19, 118], [179, -181], [263, -72], [9, -110], [-77, -262]], [[90387, 28338], [269, -199], [151, 79], [217, 111], [166, -39], [20, -684], [-95, -198], [-29, -463], [-97, 157], [-193, -401], [-57, 31], [-171, 18], [-171, 493], [-38, 380], [-160, 502], [7, 264], [181, -51]], [[98060, 28265], [63, -238], [198, 233], [80, -243], [0, -242], [-103, -267], [-182, -424], [-142, -232], [103, -277], [-214, -7], [-238, -217], [-75, -377], [-157, -583], [-219, -257], [-138, -164], [-256, 12], [-180, 190], [-302, 40], [-46, 212], [149, 427], [349, 568], [179, 109], [200, 219], [238, 301], [167, 299], [123, 429], [106, 146], [41, 321], [195, 267], [61, -245]], [[98502, 31008], [202, -607], [5, 394], [126, -158], [41, -435], [224, -188], [188, -46], [158, 220], [141, -67], [-67, -511], [-85, -336], [-212, 12], [-74, -175], [26, -248], [-41, -107], [-105, -310], [-138, -395], [-214, -229], [-48, 151], [-116, 83], [160, 474], [-91, 317], [-299, 230], [8, 209], [201, 200], [47, 444], [-13, 372], [-113, 386], [8, 102], [-133, 237], [-218, 510], [-117, 408], [104, 45], [151, -320], [216, -149], [78, -513]], [[96421, 39068], [-105, -138], [-153, 155], [-199, 259], [-179, 306], [-184, 406], [-38, 195], [119, -8], [156, -196], [122, -196], [89, -161], [228, -357], [144, -265]], [[99547, 41844], [96, -167], [-46, -300], [-172, -79], [-153, 71], [-27, 253], [107, 198], [126, -71], [69, 95]], [[0, 42295], [99822, -141], [-177, -122], [-36, 215], [139, 118], [88, 32], [-99836, 180]], [[0, 42577], [0, -282]], [[0, 42577], [57, 26], [-34, -277], [-23, -31]], [[96623, 42347], [-92, -76], [-93, 252], [10, 155], [175, -331]], [[96418, 43229], [45, -464], [-75, 72], [-58, -31], [-39, 159], [-6, 441], [133, -177]], [[63904, 44023], [45, -693], [72, -269], [-28, -277], [-49, -169], [-94, 338], [-53, -171], [53, -427], [-24, -244], [-77, -133], [-18, -488], [-109, -671], [-137, -793], [-172, -1092], [-106, -800], [-125, -668], [-226, -136], [-243, -244], [-160, 147], [-220, 206], [-77, 304], [-18, 510], [-98, 460], [-26, 414], [50, 415], [128, 100], [1, 191], [133, 437], [25, 367], [-65, 272], [-52, 364], [-23, 530], [97, 322], [38, 366], [138, 21], [155, 118], [103, 104], [122, 8], [158, 328], [229, 355], [83, 289], [-38, 247], [118, -70], [153, 401], [6, 346], [92, 257], [96, -247], [74, -245], [69, -380]], [[89877, 43903], [100, -452], [179, 217], [92, -243], [133, -225], [-29, -255], [60, -494], [42, -288], [70, -70], [75, -492], [-27, -299], [90, -390], [301, -301], [197, -274], [186, -251], [-37, -139], [159, -361], [108, -623], [111, 126], [113, -249], [68, 88], [48, -610], [197, -354], [129, -220], [217, -466], [78, -463], [7, -328], [-19, -356], [132, -490], [-16, -509], [-48, -267], [-75, -514], [6, -330], [-55, -413], [-123, -524], [-205, -283], [-102, -446], [-93, -284], [-82, -497], [-107, -287], [-70, -431], [-36, -397], [14, -182], [-159, -200], [-311, -21], [-257, -236], [-127, -223], [-168, -248], [-230, 255], [-170, 101], [43, 301], [-152, -109], [-243, -417], [-240, 156], [-158, 91], [-159, 41], [-269, 167], [-179, 355], [-52, 437], [-64, 291], [-137, 233], [-267, 70], [91, 279], [-67, 428], [-136, -399], [-247, -106], [146, 319], [42, 332], [107, 282], [-22, 427], [-226, -491], [-174, -197], [-106, -458], [-217, 237], [9, 305], [-174, 418], [-147, 216], [52, 133], [-356, 349], [-195, 16], [-267, 280], [-498, -54], [-359, -206], [-317, -192], [-265, 38], [-294, -296], [-241, -132], [-53, -302], [-103, -234], [-236, -14], [-174, -52], [-246, 105], [-199, -62], [-191, -27], [-165, -307], [-81, 26], [-140, -163], [-133, -183], [-203, 23], [-186, 0], [-295, 368], [-149, 109], [6, 330], [138, 79], [47, 131], [-10, 207], [34, 400], [-31, 341], [-147, 582], [-45, 329], [12, 328], [-111, 375], [-7, 169], [-123, 230], [-35, 451], [-158, 456], [-39, 245], [122, -249], [-93, 535], [137, -167], [83, -223], [-5, 294], [-138, 454], [-26, 181], [-65, 173], [31, 333], [56, 141], [38, 289], [-29, 336], [114, 415], [21, -439], [118, 396], [225, 193], [136, 245], [212, 212], [126, 45], [77, -71], [219, 214], [168, 64], [42, 126], [74, 53], [153, -14], [292, 169], [151, 256], [71, 307], [163, 293], [13, 229], [7, 314], [194, 489], [117, -497], [119, 115], [-99, 272], [87, 279], [122, -125], [34, 439], [152, 283], [67, 227], [140, 98], [4, 161], [122, -67], [5, 145], [122, 82], [134, 78], [205, -264], [155, -342], [173, -3], [177, -54], [-59, 316], [133, 462], [126, 150], [-44, 144], [121, 329], [168, 203], [142, -68], [234, 108], [-5, 294], [-204, 190], [148, 84], [184, -143], [148, -236], [234, -148], [79, 59], [172, -177], [162, 164], [105, -50], [65, 111], [127, -285], [-74, -308], [-105, -233], [-96, -19], [32, -230], [-81, -288], [-99, -283], [20, -163], [221, -318], [214, -184], [143, -199], [201, -341], [78, 1], [145, -148], [43, -178], [265, -195], [183, 197], [55, 309], [56, 255], [34, 316], [85, 458], [-39, 279], [20, 167], [-32, 330], [37, 434], [53, 117], [-43, 192], [67, 305], [52, 317], [7, 164], [104, 216], [78, -282], [19, -361], [70, -70], [11, -242], [101, -293], [21, -326], [-10, -209]], [[95032, 45793], [78, -198], [-194, 3], [-106, 355], [166, -140], [56, -20]], [[83531, 45933], [-117, -11], [-368, 403], [259, 113], [146, -175], [97, -175], [-17, -155]], [[94680, 46144], [-108, -13], [-170, 58], [-58, 89], [17, 228], [183, -90], [91, -121], [45, -151]], [[94910, 46301], [-42, -106], [-206, 499], [-57, 344], [94, 0], [100, -461], [111, -276]], [[84565, 45990], [-238, -127], [-33, 69], [25, 196], [119, 351], [275, 229], [32, 136], [239, 129], [194, 20], [87, 72], [105, -72], [-102, -156], [-289, -252], [-233, -165], [-181, -430]], [[82749, 47167], [100, -153], [172, 47], [69, -245], [-321, -116], [-193, -77], [-149, 4], [95, 332], [153, 5], [74, 203]], [[84139, 47168], [-41, -320], [-417, -163], [-370, 71], [0, 210], [220, 120], [174, -173], [185, 44], [249, 211]], [[94409, 47028], [12, -116], [-218, 245], [-152, 206], [-104, 192], [41, 59], [128, -138], [228, -265], [65, -183]], [[93760, 47598], [-56, -33], [-121, 131], [-114, 237], [14, 96], [166, -243], [111, -188]], [[80172, 47926], [533, -57], [61, 237], [515, -277], [101, -373], [417, -105], [341, -342], [-317, -220], [-306, 232], [-251, -15], [-288, 42], [-260, 104], [-322, 220], [-204, 57], [-116, -72], [-506, 237], [-48, 247], [-255, 43], [191, 550], [337, -34], [224, -225], [115, -44], [38, -205]], [[87423, 48251], [-143, -393], [-27, 434], [49, 207], [58, 195], [63, -169], [0, -274]], [[93299, 47902], [-78, -58], [-120, 221], [-122, 366], [-59, 439], [38, 55], [30, -171], [84, -130], [135, -366], [131, -195], [-39, -161]], [[92217, 48675], [-146, -48], [-44, -161], [-152, -140], [-142, -135], [-148, 1], [-228, 167], [-158, 161], [23, 178], [249, -84], [152, 45], [42, 276], [40, 14], [27, -306], [158, 44], [78, 197], [155, 206], [-30, 339], [166, 11], [56, -94], [-5, -320], [-93, -351]], [[85346, 49837], [-104, -191], [-192, 106], [-54, 248], [281, 27], [69, -190]], [[86241, 50048], [101, -441], [-234, 238], [-232, 48], [-157, -38], [-192, 20], [65, 317], [344, 24], [305, -168]], [[92538, 49238], [-87, -154], [-52, 340], [-65, 223], [-126, 189], [-158, 245], [-200, 170], [77, 139], [150, -162], [94, -126], [117, -139], [111, -241], [106, -185], [33, -299]], [[87261, 51166], [78, -931], [287, -345], [232, 611], [319, 347], [247, 1], [238, -201], [206, -206], [298, -110], [482, -397], [513, -329], [192, -295], [154, -290], [43, -339], [462, -356], [68, -306], [-256, -62], [62, -383], [248, -378], [180, -611], [159, 19], [-11, -255], [215, -98], [-84, -108], [295, -243], [-30, -166], [-184, -40], [-69, 149], [-238, 65], [-281, 86], [-216, 368], [-158, 316], [-144, 504], [-362, 252], [-235, -164], [-170, -190], [35, -425], [-218, -198], [-155, 96], [-288, 25], [-247, 472], [-282, 116], [-69, -164], [-352, -18], [118, 469], [175, 160], [-72, 626], [-134, 483], [-538, 488], [-229, 48], [-417, 532], [-82, -279], [-107, -51], [-63, 211], [-1, 250], [-212, 283], [299, 207], [198, -11], [-23, 153], [-407, 1], [-110, 343], [-248, 106], [-117, 285], [374, 140], [142, 188], [446, -237], [44, -214]], [[84788, 52647], [-223, -571], [-209, -111], [-267, 113], [-463, -29], [-243, -83], [-39, -436], [248, -512], [150, 261], [518, 196], [-22, -265], [-121, 83], [-121, -337], [-245, -223], [263, -738], [-50, -198], [249, -665], [-2, -378], [-148, -170], [-109, 203], [134, 471], [-273, -222], [-69, 159], [36, 222], [-200, 338], [21, 561], [-186, -175], [24, -671], [11, -824], [-176, -84], [-119, 169], [79, 530], [-43, 556], [-117, 4], [-86, 395], [115, 377], [40, 457], [139, 868], [58, 238], [237, 427], [217, -170], [350, -80], [319, 24], [275, 419], [48, -129]], [[85746, 52481], [-15, -503], [-143, 57], [-42, -351], [114, -304], [-78, -69], [-112, 365], [-82, 736], [56, 460], [92, 210], [20, -315], [164, -50], [26, -236]], [[79393, 48459], [-308, -12], [-234, 481], [-356, 471], [-119, 349], [-210, 469], [-138, 432], [-212, 806], [-244, 480], [-81, 495], [-103, 449], [-250, 363], [-145, 493], [-209, 322], [-290, 635], [-24, 293], [178, -23], [430, -111], [246, -564], [215, -390], [153, -240], [263, -619], [283, -9], [233, -394], [161, -482], [211, -263], [-111, -471], [159, -200], [100, -14], [47, -402], [97, -321], [204, -51], [135, -365], [-70, -716], [-11, -891]], [[82742, 52882], [312, -533], [-329, -68], [-93, -393], [12, -522], [-267, -393], [-7, -574], [-107, -881], [-41, 205], [-316, -259], [-110, 352], [-198, 33], [-139, 184], [-330, -207], [-101, 279], [-182, -32], [-229, 67], [-43, 772], [-138, 160], [-134, 493], [-38, 504], [32, 533], [165, 383], [204, -198], [214, 108], [56, 488], [119, 108], [333, 125], [199, 456], [137, 364], [110, 215], [236, 316], [214, 400], [140, 450], [112, 2], [143, -291], [13, -251], [183, -160], [231, -173], [-20, -226], [-186, -29], [50, -281], [-205, -196], [-158, -520], [204, -545], [-48, -265]], [[85104, 56675], [28, -382], [16, -323], [-94, -527], [-102, 587], [-130, -292], [89, -425], [-79, -270], [-327, 335], [-78, 416], [84, 274], [-176, 273], [-87, -239], [-131, 22], [-205, -321], [-46, 168], [109, 486], [175, 161], [151, 217], [98, -260], [212, 157], [45, 257], [196, 16], [-16, 445], [225, -273], [23, -290], [20, -212]], [[72560, 55398], [-242, -132], [-132, 458], [-49, 828], [126, 935], [192, -320], [129, -406], [134, -599], [-42, -600], [-116, -164]], [[33073, 57651], [-232, -63], [-50, 52], [81, 158], [-6, 228], [160, 75], [58, -20], [-11, -430]], [[84439, 57749], [-100, -190], [-87, -363], [-87, -171], [-171, 398], [57, 154], [70, 162], [30, 357], [153, 34], [-44, -388], [205, 556], [-26, -549]], [[82917, 57194], [-369, -546], [136, 403], [200, 355], [167, 399], [146, 572], [49, -470], [-183, -317], [-146, -396]], [[83856, 58678], [166, -179], [177, 1], [-5, -240], [-129, -245], [-176, -173], [-10, 268], [20, 293], [-43, 275]], [[84861, 58834], [78, -643], [-214, 152], [5, -193], [68, -355], [-132, -129], [-11, 405], [-84, 30], [-43, 348], [163, -46], [-4, 218], [-169, 440], [266, -13], [77, -214]], [[83757, 59356], [-74, -498], [-119, 288], [-142, 438], [238, -21], [97, -207]], [[83700, 62485], [171, -164], [85, 150], [26, -146], [-46, -239], [95, -413], [-73, -478], [-164, -191], [-43, -465], [62, -458], [147, -64], [123, 68], [347, -319], [-27, -313], [91, -139], [-29, -265], [-216, 283], [-103, 302], [-71, -211], [-177, 345], [-253, -86], [-138, 128], [14, 238], [87, 146], [-83, 133], [-36, -207], [-137, 331], [-41, 251], [-11, 551], [112, -190], [29, 901], [90, 522], [169, -1]], [[31780, 62327], [-71, -146], [-209, 4], [-163, -21], [-16, 247], [40, 84], [227, -3], [142, -51], [50, -114]], [[28638, 62119], [-84, -96], [-156, 92], [-159, 210], [34, 132], [116, 40], [64, -19], [187, -52], [147, -138], [46, -158], [-195, -11]], [[29839, 63273], [241, -90], [34, 98], [217, -3], [165, -148], [73, 14], [50, -204], [152, 11], [-9, -171], [124, -21], [136, -211], [-103, -235], [-132, 126], [-127, -25], [-92, 28], [-50, -105], [-106, -36], [-43, 140], [-92, -83], [-111, -394], [-71, 92], [-14, 165], [-185, 98], [-131, -40], [-169, 42], [-130, -108], [-149, 179], [24, 186], [256, -80], [210, -46], [100, 128], [-127, 250], [2, 220], [-175, 89], [62, 159], [170, -25]], [[80649, 62586], [-240, -277], [-228, 179], [-8, 495], [137, 261], [304, 161], [159, -13], [62, -220], [-122, -254], [-64, -332]], [[6794, 62819], [-41, -96], [-69, 82], [8, 161], [-46, 210], [14, 64], [48, 94], [-19, 113], [16, 54], [21, -11], [107, -97], [49, -50], [45, -77], [71, -202], [-7, -32], [-108, -123], [-89, -90]], [[6645, 63718], [-94, -41], [-47, 121], [-32, 47], [-3, 36], [27, 49], [99, -55], [73, -88], [-23, -69]], [[6456, 64025], [-9, -63], [-149, 17], [21, 70], [137, -24]], [[6207, 64108], [-15, -33], [-19, 8], [-97, 20], [-35, 130], [-11, 23], [74, 80], [23, -37], [80, -191]], [[5737, 64488], [-33, -57], [-93, 105], [14, 42], [43, 57], [64, -13], [5, -134]], [[27867, 64939], [110, -210], [260, 65], [98, -136], [235, -356], [173, -260], [92, 8], [165, -118], [-20, -162], [205, -23], [210, -236], [-33, -135], [-185, -73], [-187, -29], [-191, 46], [-398, -56], [186, 321], [-113, 150], [-179, 38], [-96, 166], [-66, 328], [-157, -22], [-259, 154], [-83, 121], [-362, 89], [-97, 113], [104, 144], [-273, 29], [-199, -299], [-115, -8], [-40, -141], [-138, -63], [-118, 55], [146, 178], [60, 208], [126, 128], [142, 112], [210, 55], [67, 63], [240, -41], [219, -6], [261, -197]], [[28462, 65512], [-68, -29], [-70, 332], [-104, 167], [60, 365], [84, -23], [97, -478], [1, -334]], [[83659, 64954], [-119, -472], [-146, 486], [-32, 427], [163, 566], [223, 436], [127, -172], [-49, -347], [-167, -924]], [[28383, 67136], [-303, -92], [-19, 213], [130, 46], [184, -17], [8, -150]], [[28611, 67142], [-48, -409], [-51, 73], [4, 301], [-124, 228], [-1, 66], [220, -259]], [[87399, 71495], [35, -197], [-156, -349], [-114, 185], [-143, -134], [-73, -337], [-181, 164], [2, 273], [154, 344], [158, -67], [114, 242], [204, -124]], [[59604, 72372], [-188, -245], [21, -108], [8, -46], [-285, -234], [-136, 74], [-64, 232], [132, 21], [19, 3], [40, 139], [200, -8], [253, 172]], [[56583, 72391], [152, -194], [216, 33], [207, -41], [-7, -100], [151, 69], [-35, -170], [-400, -49], [3, 95], [-339, 112], [52, 245]], [[54311, 73846], [-100, -453], [41, -179], [-58, -296], [-213, 217], [-141, 62], [-387, 293], [38, 296], [325, -53], [284, 63], [211, 50]], [[52558, 75561], [166, -408], [-39, -762], [-126, 36], [-113, -192], [-105, 153], [-11, 694], [-64, 330], [153, -29], [139, 178]], [[89159, 73219], [-104, -460], [48, -288], [-145, -406], [-355, -271], [-488, -36], [-396, -657], [-186, 221], [-12, 431], [-483, -127], [-329, -271], [-325, -11], [282, -424], [-186, -979], [-179, -242], [-135, 224], [69, 519], [-176, 167], [-113, 395], [263, 177], [145, 362], [280, 298], [203, 394], [553, 171], [297, -117], [291, 1024], [185, -275], [408, 575], [158, 224], [174, 704], [-47, 648], [117, 364], [295, 105], [152, -798], [-9, -467], [-256, -580], [4, -594]], [[52655, 76104], [-92, -445], [-126, 118], [-64, 387], [56, 214], [179, 220], [47, -494]], [[89974, 77268], [195, -122], [197, 244], [62, -647], [-412, -157], [-244, -572], [-436, 393], [-152, -630], [-308, -9], [-39, 573], [138, 443], [296, 32], [81, 797], [83, 449], [326, -600], [213, -194]], [[32315, 78637], [202, -78], [257, 16], [-137, -236], [-102, -37], [-353, 244], [-69, 193], [105, 177], [97, -279]], [[32831, 80108], [-135, -10], [-360, 180], [-258, 272], [96, 49], [365, -145], [284, -240], [8, -106]], [[15692, 79765], [-140, -80], [-456, 262], [-84, 204], [-248, 202], [-50, 164], [-286, 103], [-107, 314], [24, 133], [291, -125], [171, -88], [261, -61], [94, -198], [138, -274], [277, -238], [115, -318]], [[34407, 81019], [-184, -504], [181, 195], [187, -124], [-98, -200], [247, -158], [128, 140], [277, -177], [-86, -422], [194, 99], [36, -306], [86, -358], [-117, -507], [-125, -21], [-183, 109], [60, 471], [-77, 73], [-322, -499], [-166, 20], [196, 270], [-267, 140], [-298, -34], [-539, 17], [-43, 171], [173, 202], [-121, 157], [234, 347], [287, 917], [172, 328], [241, 198], [129, -25], [-54, -156], [-148, -363]], [[13136, 82950], [267, 46], [-84, -654], [242, -463], [-111, 1], [-167, 264], [-103, 265], [-140, 179], [-51, 253], [16, 184], [131, -75]], [[89901, 81054], [280, -1020], [-411, 190], [-171, -832], [271, -590], [-8, -403], [-211, 347], [-182, -445], [-51, 483], [31, 561], [-32, 621], [64, 436], [13, 770], [-163, 566], [24, 787], [257, 265], [-110, 267], [123, 81], [73, -381], [96, -555], [-7, -567], [114, -581]], [[48114, 81925], [-493, -340], [-393, 87], [225, 601], [-145, 586], [378, 451], [210, 269], [233, 23], [298, -356], [-149, -395], [46, -412], [-210, -514]], [[53524, 83854], [-166, -466], [-291, 325], [-39, 239], [408, 191], [88, -289]], [[7498, 84721], [-277, -219], [-142, 148], [-43, 270], [252, 205], [148, 88], [185, -39], [117, -179], [-240, -274]], [[49165, 85596], [-297, -623], [283, 79], [304, -3], [-72, -469], [-250, -516], [287, -37], [270, -740], [190, -93], [171, -656], [79, -227], [337, -110], [-34, -368], [-142, -169], [111, -298], [-250, -302], [-371, 6], [-473, -159], [-130, 114], [-183, -270], [-257, 65], [-195, -220], [-148, 115], [407, 605], [249, 125], [-436, 96], [-79, 229], [291, 179], [-152, 310], [52, 377], [414, -52], [40, 334], [-190, 363], [-337, 101], [-66, 156], [101, 258], [-92, 158], [-149, -272], [-17, 555], [-140, 294], [101, 595], [216, 467], [222, -45], [335, 48]], [[4006, 86330], [-171, -89], [-182, 107], [-168, 157], [274, 98], [220, -52], [27, -221]], [[27981, 87625], [-108, -302], [-123, 49], [-73, 171], [13, 40], [107, 173], [114, -13], [70, -118]], [[27250, 87943], [-325, -317], [-196, 13], [-61, 156], [207, 265], [381, -5], [-6, -112]], [[2297, 88560], [171, -109], [173, 59], [225, -152], [276, -77], [-23, -63], [-211, -121], [-211, 125], [-106, 104], [-245, -33], [-66, 51], [17, 216]], [[26344, 89640], [51, -253], [143, 89], [161, -151], [304, -198], [318, -179], [25, -274], [204, 45], [199, -191], [-247, -181], [-432, 138], [-156, 259], [-275, -306], [-396, -298], [-95, 337], [-377, -55], [242, 284], [35, 454], [95, 527], [201, -47]], [[45969, 90100], [-64, -373], [314, -392], [-361, -440], [-801, -394], [-240, -105], [-365, 85], [-775, 182], [273, 254], [-605, 282], [492, 112], [-12, 169], [-583, 134], [188, 375], [421, 85], [433, -391], [422, 314], [349, -163], [453, 307], [461, -41]], [[28926, 90499], [-312, -29], [-69, 282], [118, 323], [255, 80], [217, -160], [3, -246], [-32, -80], [-180, -170]], [[0, 91544], [681, -440], [728, -572], [-24, -358], [187, -143], [-64, 418], [754, -86], [544, -539], [-276, -251], [-455, -59], [-7, -563], [-111, -120], [-260, 17], [-212, 201], [-369, 168], [-62, 250], [-283, 94], [-315, -74], [-151, 201], [60, 214], [-333, -137], [126, -271], [-158, -244], [0, 2294]], [[23431, 91627], [-173, -202], [-374, 175], [-226, -63], [-380, 259], [245, 178], [194, 250], [295, -164], [166, -103], [84, -110], [169, -220]], [[0, 93014], [99999, -394], [-305, -29], [-49, 183], [-99645, 240]], [[0, 93014], [36, 24], [235, -1], [402, -165], [-24, -79], [-286, -138], [-363, -35], [0, 394]], [[24848, 91852], [-1, -589], [371, 451], [332, -371], [-83, -427], [269, -388], [290, 416], [202, 497], [16, 632], [394, -44], [411, -85], [373, -286], [17, -285], [-207, -307], [196, -309], [-36, -280], [-544, -402], [-386, -89], [-287, 173], [-83, -289], [-268, -486], [-81, -252], [-322, -389], [-397, -38], [-220, -244], [-18, -374], [-323, -72], [-340, -467], [-301, -648], [-108, -454], [-15, -669], [408, -96], [125, -539], [130, -437], [388, 114], [517, -250], [277, -219], [199, -272], [348, -158], [294, -243], [459, -33], [302, -56], [-45, -499], [86, -578], [201, -645], [414, -547], [214, 188], [150, 592], [-145, 909], [-196, 303], [445, 270], [314, 404], [154, 401], [-22, 385], [-189, 489], [-338, 434], [328, 603], [-121, 522], [-93, 899], [194, 133], [476, -157], [286, -56], [230, 152], [258, -196], [342, -333], [85, -224], [495, -43], [-8, -484], [92, -728], [254, -90], [201, -339], [402, 319], [266, 636], [184, 268], [216, -515], [362, -734], [307, -691], [-112, -362], [370, -325], [250, -329], [442, -149], [179, -183], [110, -488], [216, -76], [112, -217], [20, -647], [-202, -217], [-199, -202], [-458, -205], [-349, -473], [-470, -93], [-594, 121], [-417, 4], [-287, -40], [-233, -413], [-354, -255], [-401, -762], [-320, -532], [236, 95], [446, 756], [583, 480], [416, 58], [245, -283], [-262, -387], [88, -620], [91, -435], [361, -287], [459, 83], [278, 647], [19, -417], [180, -209], [-344, -377], [-615, -343], [-276, -233], [-310, -415], [-211, 43], [-11, 487], [483, 476], [-445, -19], [-309, -70], [48, -189], [-296, -279], [-286, -198], [-293, -171], [-159, -376], [-35, -95], [-3, -306], [92, -305], [115, -14], [-29, 210], [83, -128], [-22, -165], [-188, -93], [-133, 11], [-205, -100], [-121, -29], [-162, -28], [-231, -167], [408, 108], [82, -109], [-389, -173], [-177, -1], [8, 71], [-84, -160], [82, -26], [-60, -414], [-203, -443], [-20, 148], [-61, 30], [-91, 144], [57, -310], [66, -103], [8, -217], [-89, -224], [-157, -460], [-25, 23], [86, 392], [-142, 220], [-33, 478], [-53, -249], [59, -365], [-175, 86], [183, -181], [12, -548], [79, -40], [29, -199], [39, -577], [-176, -427], [-288, -171], [-182, -338], [-139, -37], [-141, -211], [-39, -193], [-305, -374], [-157, -274], [-131, -342], [-43, -409], [50, -400], [92, -492], [124, -408], [1, -249], [132, -668], [-9, -388], [-12, -224], [-69, -352], [-83, -73], [-137, 70], [-44, 253], [-106, 132], [-147, 496], [-129, 440], [-42, 226], [57, 382], [-77, 317], [-217, 481], [-108, 89], [-281, -262], [-49, 29], [-135, 269], [-174, 142], [-314, -72], [-247, 63], [-212, -39], [-118, -81], [54, -162], [-5, -234], [59, -113], [-53, -76], [-103, 85], [-104, -109], [-202, 18], [-207, 304], [-242, -72], [-202, 133], [-173, -40], [-234, -135], [-253, -427], [-276, -248], [-152, -275], [-63, -259], [-3, -397], [14, -277], [52, -196], [1, -1], [-1, -1], [-107, -503], [-49, -415], [-20, -771], [-27, -281], [48, -315], [86, -280], [56, -447], [184, -429], [65, -328], [109, -284], [295, -153], [114, -241], [244, 161], [212, 58], [208, 104], [175, 99], [176, 235], [67, 336], [22, 483], [48, 169], [188, 151], [294, 133], [246, -20], [169, 49], [66, -122], [-9, -278], [-149, -342], [-66, -351], [51, -100], [-42, -249], [-69, -449], [-71, 148], [-58, -10], [1, -84], [53, -3], [-5, -157], [-45, -249], [24, -89], [-29, -206], [18, -55], [-32, -291], [-55, -153], [-50, -18], [-55, -199], [90, -105], [24, 86], [82, -73], [29, -23], [61, 101], [79, 9], [26, -47], [43, 28], [129, -52], [128, 15], [90, 64], [32, 65], [89, -30], [66, -39], [73, 13], [55, 50], [127, -80], [44, -13], [85, -107], [80, -129], [101, -88], [73, -159], [-24, -55], [-14, -129], [29, -210], [-64, -197], [-30, -231], [-9, -254], [15, -148], [7, -260], [-43, -56], [-26, -247], [19, -152], [-56, -147], [12, -156], [43, -94], [70, -313], [108, -232], [130, -246], [100, -206], [-6, -122], [111, -26], [26, 47], [77, -142], [136, 42], [119, 145], [168, 116], [95, 173], [153, -34], [-10, -57], [155, -20], [124, -99], [90, -173], [105, -160], [143, -18], [209, 402], [114, 62], [3, 190], [51, 487], [159, 267], [175, 11], [22, 120], [218, -48], [218, 291], [109, 128], [134, 278], [98, -36], [73, -151], [-54, -194], [-8, -136], [-163, -67], [91, -262], [-3, -301], [-123, -334], [105, -457], [120, 37], [62, 417], [-86, 202], [-14, 436], [346, 234], [-38, 272], [97, 181], [100, -404], [195, -10], [180, -321], [11, -190], [249, -5], [297, 59], [159, -258], [213, -71], [155, 180], [4, 145], [344, 34], [333, 8], [-236, -170], [95, -272], [222, -43], [210, -283], [45, -461], [144, 13], [109, -136], [183, -212], [171, -375], [8, -297], [105, -13], [149, -281], [109, -201], [333, -115], [30, 104], [225, 41], [298, -155], [95, -63], [204, -136], [294, -486], [46, -236], [95, 27], [69, -318], [155, -1008], [149, -95], [7, -397], [-208, -474], [86, -174], [491, -90], [10, -577], [211, 377], [349, -207], [462, -351], [135, -338], [-45, -319], [323, 178], [540, -305], [415, 23], [411, -477], [355, -645], [214, -166], [237, -23], [101, -182], [94, -733], [46, -348], [-110, -953], [-142, -376], [-391, -801], [-177, -651], [-206, -499], [-69, -11], [-78, -424], [20, -1079], [-77, -888], [-30, -379], [-88, -228], [-49, -769], [-282, -752], [-47, -595], [-225, -249], [-65, -346], [-302, 2], [-437, -222], [-195, -256], [-311, -168], [-327, -459], [-235, -571], [-41, -430], [46, -318], [-51, -582], [-63, -281], [-195, -317], [-308, -1013], [-244, -457], [-189, -269], [-127, -548], [-183, -329], [-121, -362], [-313, -320], [-205, 115], [-151, -62], [-256, 247], [-189, -18], [-169, 318], [-19, -300], [353, -493], [-38, -397], [173, -251], [-14, -282], [-267, -738], [-412, -309], [-557, -120], [-305, 58], [59, -343], [-57, -431], [51, -291], [-167, -202], [-284, -80], [-267, 210], [-108, -151], [39, -572], [188, -173], [152, 181], [82, -299], [-255, -179], [-223, -358], [-41, -579], [-66, -309], [-262, -1], [-218, -295], [-80, -432], [274, -422], [265, -116], [-96, -517], [-328, -325], [-180, -675], [-254, -227], [-113, -270], [89, -598], [185, -333], [-117, 29], [-247, 4], [-134, -141], [-250, -208], [-45, -538], [-118, -14], [-313, 188], [-318, 401], [-346, 329], [-87, 365], [79, 337], [-140, 383], [-36, 982], [119, 554], [293, 445], [-422, 168], [265, 509], [94, 956], [309, -202], [145, 1193], [-186, 153], [-87, -719], [-175, 81], [87, 823], [95, 1067], [127, 394], [-79, 562], [-23, 649], [117, 18], [170, 930], [192, 922], [118, 858], [-64, 863], [83, 475], [-34, 711], [163, 703], [50, 1114], [89, 1196], [87, 1287], [-20, 943], [-58, 811], [-279, 331], [-24, 236], [-551, 578], [-498, 630], [-214, 355], [-115, 476], [46, 166], [-236, 755], [-274, 1063], [-262, 1147], [-114, 262], [-87, 424], [-216, 376], [-198, 233], [90, 257], [-134, 550], [86, 403], [221, 364], [148, 430], [-60, 251], [-106, -267], [-166, 252], [56, 163], [-47, 522], [97, 87], [52, 359], [105, 371], [-20, 235], [153, 123], [190, 230], [-37, 178], [103, 44], [-12, 288], [65, 209], [138, 38], [117, 362], [106, 302], [-102, 137], [52, 335], [-62, 526], [59, 152], [-44, 487], [-112, 306], [-93, 167], [-59, 310], [68, 154], [-70, 40], [-52, 190], [-138, 160], [-122, -37], [-56, -200], [-112, -145], [-61, -20], [-27, -120], [132, -312], [-75, -74], [-40, -85], [-130, -30], [-48, 344], [-36, -97], [-92, 33], [-56, 232], [-114, 38], [-72, 68], [-119, -1], [-8, -125], [-32, 87], [-151, 128], [-56, 121], [32, 100], [-11, 127], [-77, 138], [-109, 113], [-95, 74], [-19, 168], [-73, 103], [18, -167], [-55, -138], [-64, 160], [-89, 57], [-38, 116], [2, 175], [36, 182], [-78, 81], [64, 111], [-96, 181], [-130, 233], [-61, 194], [-117, 181], [-140, 260], [31, 89], [46, -87], [21, 41], [-48, 180], [-84, 50], [-31, -135], [-161, 8], [-100, 55], [-115, 115], [-154, 36], [-79, 123], [-142, 101], [-174, 10], [-127, 114], [-149, 238], [-314, 620], [-144, 187], [-226, 150], [-156, -42], [-223, -216], [-140, -57], [-196, 152], [-208, 109], [-260, 264], [-208, 81], [-314, 268], [-233, 275], [-70, 154], [-155, 34], [-284, 183], [-116, 262], [-299, 327], [-139, 363], [-66, 281], [93, 56], [-29, 164], [64, 150], [1, 199], [-93, 259], [-25, 229], [-94, 290], [-244, 573], [-280, 450], [-135, 359], [-238, 235], [-51, 140], [42, 356], [-142, 135], [-164, 279], [-69, 402], [-149, 47], [-162, 304], [-130, 280], [-12, 180], [-149, 434], [-99, 441], [5, 221], [-201, 229], [-93, -26], [-159, 159], [-44, -234], [46, -276], [27, -433], [95, -237], [206, -397], [46, -135], [42, -41], [37, -198], [49, 8], [56, -372], [85, -146], [59, -204], [174, -293], [92, -536], [83, -252], [77, -270], [15, -304], [134, -19], [112, -261], [100, -257], [-6, -103], [-117, -212], [-49, 3], [-74, 350], [-182, 328], [-200, 278], [-142, 147], [9, 421], [-42, 312], [-132, 179], [-191, 257], [-37, -74], [-70, 150], [-171, 139], [-164, 334], [20, 44], [115, -33], [103, 215], [10, 260], [-214, 411], [-163, 159], [-102, 360], [-103, 377], [-129, 461], [-113, 518], [-46, 294], [-180, 331], [-130, 69], [-30, 165], [-156, 29], [-100, 156], [-258, 57], [-70, 93], [-34, 316], [-270, 578], [-231, 801], [10, 133], [-123, 190], [-215, 483], [-38, 469], [-148, 315], [61, 477], [-10, 494], [-89, 442], [109, 542], [67, 1045], [-50, 773], [-88, 493], [-80, 267], [33, 112], [402, -195], [148, -544], [68, 152], [-44, 472], [-94, 473], [-38, 1], [-537, 566], [-199, 248], [-503, 239], [-155, 510], [40, 353], [-356, 245], [-48, 465], [-336, 418], [-6, 296], [-153, 217], [-245, 184], [-78, 502], [-358, 466], [-150, 543], [-267, 38], [-441, 14], [-326, 165], [-574, 598], [-266, 109], [-486, 206], [-385, -49], [-546, 264], [-330, 246], [-309, -122], [58, -400], [-154, -37], [-321, -120], [-245, -195], [-307, -122], [-40, 339], [125, 565], [295, 177], [-76, 145], [-354, -321], [-190, -383], [-400, -410], [203, -280], [-262, -413], [-299, -241], [-278, -176], [-69, -255], [-434, -297], [-87, -271], [-325, -246], [-191, 44], [-259, -160], [-282, -196], [-231, -193], [-477, -164], [-43, 97], [304, 269], [271, 177], [296, 315], [345, 65], [137, 236], [385, 345], [62, 115], [205, 204], [48, 437], [141, 340], [-320, -175], [-90, 99], [-150, -209], [-181, 292], [-75, -207], [-104, 287], [-278, -230], [-170, 0], [-24, 343], [50, 211], [-179, 205], [-361, -110], [-235, 270], [-190, 138], [-1, 327], [-214, 245], [108, 331], [226, 322], [99, 295], [225, 42], [191, -92], [224, 278], [201, -50], [212, 179], [-52, 263], [-155, 104], [205, 222], [-170, -7], [-295, -125], [-85, -127], [-219, 127], [-392, -65], [-407, 138], [-117, 232], [-351, 335], [390, 240], [620, 282], [228, 0], [-38, -288], [586, 22], [-225, 357], [-342, 219], [-197, 288], [-267, 246], [-381, 182], [155, 302], [493, 18], [350, 263], [66, 280], [284, 274], [271, 66], [526, 256], [256, -39], [427, 307], [421, -121], [201, -260], [123, 112], [469, -35], [-16, -132], [425, -98], [283, 57], [585, -182], [534, -54], [214, -75], [370, 94], [421, -173], [302, -81], [518, -139], [438, -277], [289, -53], [244, 241], [336, 180], [413, -71], [416, 253], [455, 144], [191, -239], [207, 134], [62, 272], [192, -62], [470, -516], [369, 390], [38, -437], [341, 95], [105, 168], [337, -33], [424, -242], [650, -211], [383, -98], [272, 37], [375, -292], [-391, -286], [502, -123], [750, 68], [236, 100], [296, -345], [302, 291], [-283, 245], [179, 197], [338, 26], [223, 58], [224, -138], [279, -312], [310, 46], [491, -260], [431, 91], [405, -13], [-32, 358], [247, 101], [431, -196], [-2, -545], [177, 459], [223, -15], [126, 579], [-298, 355], [-324, 233], [22, 636], [329, 418], [366, -92], [281, -255], [378, -649], [-247, -283], [517, -116]], [[18287, 93939], [-139, -270], [618, 174], [386, -291], [314, 294], [254, -188], [227, -566], [140, 238], [-197, 590], [244, 85], [276, -93], [311, -232], [175, -561], [86, -406], [466, -285], [502, -273], [-31, -253], [-456, -47], [178, -221], [-94, -211], [-503, 90], [-478, 156], [-322, -35], [-522, -196], [-824, -101], [-374, -39], [-151, 271], [-379, 157], [-246, -64], [-343, 456], [185, 61], [429, 99], [392, -26], [362, 100], [-537, 135], [-594, -46], [-394, 11], [-146, 213], [644, 230], [-428, -8], [-485, 152], [233, 431], [193, 229], [744, 351], [284, -111]], [[20972, 94111], [-244, -381], [-434, 404], [95, 80], [372, 23], [211, -126]], [[28794, 93928], [25, -159], [-296, 16], [-299, 13], [-304, -78], [-80, 35], [-306, 306], [12, 207], [133, 38], [636, -62], [479, -316]], [[25955, 93959], [219, -359], [256, 465], [704, 236], [477, -596], [-42, -377], [550, 168], [263, 228], [616, -291], [383, -274], [36, -252], [515, 131], [290, -367], [670, -228], [242, -232], [263, -539], [-510, -268], [654, -376], [441, -127], [400, -529], [437, -38], [-87, -404], [-487, -669], [-342, 246], [-437, 554], [-359, -72], [-35, -330], [292, -335], [377, -265], [114, -153], [181, -570], [-96, -414], [-350, 156], [-697, 461], [393, -496], [289, -348], [45, -201], [-753, 230], [-596, 334], [-337, 281], [97, 162], [-414, 296], [-405, 280], [5, -167], [-803, -92], [-235, 198], [183, 424], [522, 10], [571, 74], [-92, 205], [96, 287], [360, 561], [-77, 255], [-107, 197], [-425, 280], [-563, 196], [178, 145], [-294, 358], [-245, 33], [-219, 196], [-149, -170], [-503, -74], [-1011, 129], [-588, 169], [-450, 87], [-231, 202], [290, 263], [-394, 2], [-88, 583], [213, 515], [286, 235], [717, 154], [-204, -373]], [[22123, 94355], [331, -122], [496, 73], [72, -167], [-259, -276], [420, -248], [-50, -518], [-455, -223], [-268, 48], [-192, 220], [-690, 444], [5, 185], [567, -72], [-306, 377], [329, 279]], [[89889, 93991], [-421, -4], [-569, 64], [-49, 31], [263, 227], [348, 54], [394, -221], [34, -151]], [[24112, 93737], [-298, -430], [-317, 21], [-173, 506], [4, 287], [145, 244], [276, 157], [579, -20], [530, -140], [-415, -513], [-331, -112]], [[16539, 92947], [-731, -287], [-147, 253], [-641, 304], [93, 188], [218, 477], [241, 378], [-272, 353], [939, 90], [397, -119], [709, -32], [270, -167], [298, -243], [-349, -145], [-681, -405], [-344, -403], [0, -242]], [[91869, 95069], [-321, -228], [-444, 52], [-516, 227], [66, 187], [518, -87], [697, -151]], [[23996, 95009], [-151, -223], [-403, 43], [-337, 150], [148, 259], [399, 155], [243, -202], [101, -182]], [[90301, 95344], [-219, -427], [-1023, 16], [-461, -136], [-550, 374], [149, 396], [366, 108], [734, -25], [1004, -306]], [[22639, 96011], [212, -267], [9, -295], [-127, -429], [-458, -59], [-298, 92], [5, 336], [-455, -44], [-18, 445], [299, -18], [419, 197], [390, -34], [22, 76]], [[19941, 95712], [109, -205], [247, 97], [291, -25], [49, -282], [-169, -274], [-940, -89], [-701, -249], [-423, -13], [-35, 187], [577, 255], [-1255, -69], [-389, 103], [379, 563], [262, 161], [782, -194], [493, -341], [485, -44], [-397, 551], [255, 210], [286, -67], [94, -275]], [[65981, 92556], [-164, -51], [-907, 75], [-74, 256], [-503, 154], [-40, 311], [284, 124], [-10, 314], [551, 491], [-255, 70], [665, 506], [-75, 261], [621, 304], [917, 370], [925, 108], [475, 214], [541, 74], [193, -227], [-187, -179], [-984, -286], [-848, -274], [-863, -548], [-414, -563], [-435, -553], [56, -479], [531, -472]], [[23699, 96229], [308, -186], [547, 2], [240, -190], [-64, -216], [319, -130], [177, -137], [374, -26], [406, -48], [441, 125], [566, 49], [451, -40], [298, -218], [62, -238], [-174, -153], [-414, -124], [-355, 70], [-797, -88], [-570, -11], [-449, 71], [-738, 186], [-96, 316], [-34, 286], [-279, 251], [-574, 70], [-322, 179], [104, 236], [573, -36]], [[17722, 96544], [-38, -443], [-214, -199], [-259, -29], [-517, -246], [-444, -88], [-377, 124], [472, 431], [570, 373], [426, -8], [381, 85]], [[0, 91544], [0, -2297], [99640, -253], [-360, 42], [250, -307], [166, -474], [128, -155], [32, -238], [-71, -153], [-518, 126], [-777, -434], [-247, -67], [-425, -405], [-403, -353], [-102, -262], [-397, 398], [-724, -451], [-126, 213], [-268, -246], [-371, 79], [-90, -379], [-333, -557], [10, -233], [316, -129], [-37, -839], [-258, -21], [-119, -482], [116, -248], [-486, -294], [-96, -657], [-415, -141], [-83, -585], [-400, -536], [-103, 396], [-119, 841], [-155, 1279], [134, 799], [234, 344], [15, 269], [431, 129], [496, 725], [479, 592], [499, 459], [223, 812], [-337, -48], [-167, -475], [-705, -632], [-227, 708], [-717, -196], [-696, -965], [230, -353], [-620, -151], [-430, -59], [20, 417], [-431, 87], [-344, -283], [-850, 99], [-913, -171], [-900, -1124], [-1065, -1358], [438, -72], [136, -361], [270, -128], [178, 288], [305, -38], [401, -633], [9, -490], [-217, -576], [-23, -687], [-126, -921], [-418, -833], [-94, -399], [-377, -670], [-374, -665], [-179, -340], [-370, -338], [-175, -8], [-175, 280], [-373, -421], [-43, -192], [-106, 35], [-120, -195], [-83, -196], [10, -414], [-143, -127], [-50, -102], [-104, -170], [-185, -95], [-121, -154], [-9, -250], [-32, -63], [111, -94], [157, -253], [240, -679], [68, -373], [3, -664], [-105, -316], [-252, -111], [-222, -239], [-250, -49], [-31, 314], [52, 431], [-123, 600], [206, 97], [-190, 493], [-135, 109], [-34, -108], [-81, -48], [-10, 109], [-72, 52], [-75, 92], [77, 254], [65, 67], [-25, 106], [71, 310], [-18, 94], [-163, 63], [-131, 154], [-388, -167], [-204, -269], [-300, -157], [148, 267], [-58, 224], [220, 387], [-147, 302], [-242, -204], [-314, -400], [-171, -372], [-272, -28], [-142, -268], [147, -390], [227, -94], [9, -259], [220, -168], [311, 411], [247, -224], [179, -15], [46, -302], [-394, -161], [-130, -311], [-270, -289], [-142, -403], [299, -316], [109, -567], [169, -527], [189, -443], [-5, -428], [-174, -157], [66, -307], [164, -179], [-43, -469], [-71, -456], [-155, -52], [-203, -623], [-225, -756], [-258, -687], [-382, -532], [-386, -484], [-313, -67], [-170, -255], [-96, 186], [-157, -286], [-388, -288], [-294, -88], [-95, -609], [-154, -33], [-73, 418], [66, 222], [-373, 185], [-131, -94], [-371, -493], [-231, -544], [-61, -399], [212, -607], [260, -753], [252, -356], [169, -462], [127, -1066], [-37, -1013], [-232, -379], [-318, -371], [-227, -480], [-346, -536], [-101, 369], [78, 390], [-206, 327], [-233, 84], [-112, 301], [-141, 594], [-249, 265], [-238, -11], [41, 452], [-245, -3], [-22, -633], [-150, -841], [-90, -509], [19, -417], [181, -18], [113, -526], [50, -498], [155, -330], [168, -67], [144, -299], [64, -54], [164, -347], [116, -386], [16, -388], [-29, -262], [27, -198], [20, -340], [98, -159], [109, -509], [-5, -195], [-197, -38], [-263, 426], [-329, 457], [-32, 294], [-161, 385], [-38, 477], [-100, 314], [30, 419], [-61, 244], [-110, 221], [-47, 285], [-148, 325], [-135, 274], [-45, -339], [-53, 320], [30, 359], [82, 553], [-27, 427], [86, 441], [-94, 341], [23, 627], [-113, 299], [-90, 689], [-50, 727], [-121, 477], [-183, -288], [-315, -411], [-156, 51], [-172, 135], [96, 714], [-58, 539], [-218, 664], [34, 208], [-163, 74], [-197, 469], [-79, 301], [-16, 293], [-53, 277], [-116, 335], [-256, 23], [25, -237], [-87, -320], [-118, 116], [-41, -105], [-78, 63], [-108, 52], [-39, -210], [-189, 7], [-343, -120], [16, -433], [-148, -341], [-400, -387], [-311, -678], [-209, -363], [-276, -377], [-1, -265], [-138, -142], [-250, -206], [-130, -31], [-84, -439], [58, -749], [15, -478], [-118, -547], [-1, -978], [-144, -28], [-126, -439], [84, -190], [-253, -163], [-93, -392], [-112, -165], [-263, 537], [-128, 807], [-107, 581], [-97, 272], [-148, 553], [-69, 720], [-48, 360], [-253, 791], [-115, 1116], [-83, 737], [1, 698], [-54, 539], [-404, -345], [-196, 69], [-362, 698], [133, 208], [-82, 226], [-326, 489], [-203, 146], [-83, 414], [-215, 438], [-512, -108], [-451, -11], [-391, -81], [-523, 174], [-302, 133], [-314, 74], [-118, 707], [-133, 102], [-214, -103], [-280, -279], [-339, 191], [-281, 443], [-267, 164], [-186, 546], [-205, 768], [-149, -93], [-177, 190], [-103, -224], [-165, 28], [58, -254], [-25, -132], [89, -434], [109, -497], [137, -131], [47, -202], [190, -243], [16, -237], [-27, -192], [35, -193], [80, -162], [37, -189], [41, -141], [-18, 419], [75, 302], [76, 62], [84, -180], [5, -337], [-61, -339], [53, -220], [49, 28], [11, -158], [217, 91], [230, -15], [168, -17], [190, 389], [207, 369], [176, 355], [80, 196], [35, -50], [-26, -238], [-37, -104], [38, -455], [125, -393], [155, -209], [204, -76], [164, -105], [125, -330], [75, -191], [100, -73], [-1, -128], [-101, -344], [-44, -161], [-117, -184], [-104, -395], [-126, 30], [-58, -137], [-44, -292], [34, -385], [-26, -71], [-128, 2], [-174, -215], [-27, -281], [-63, -121], [-173, 5], [-109, -146], [1, -232], [-134, -160], [-153, 54], [-186, -194], [-128, -33], [-201, -154], [-54, -256], [-6, -196], [-277, -244], [-444, -268], [-249, -406], [-122, -32], [-83, 34], [-163, -239], [-177, -111], [-233, -30], [-70, -33], [-61, -152], [-73, -42], [-42, -146], [-138, 13], [-89, -79], [-192, 30], [-72, 336], [8, 315], [-46, 170], [-54, 426], [-80, 236], [56, 28], [-29, 264], [34, 111], [-12, 251], [-36, 246], [-84, 173], [-22, 230], [-143, 206], [-148, 483], [-79, 469], [-192, 397], [-124, 94], [-184, 549], [-32, 400], [12, 342], [-159, 638], [-130, 225], [-150, 119], [-92, 330], [15, 130], [-77, 299], [-81, 128], [-108, 429], [-170, 464], [-141, 396], [-139, -3], [44, 316], [12, 201], [34, 230], [-9, 84], [-78, -232], [-60, -435], [-75, -300], [-65, -100], [-93, 186], [-125, 257], [-198, 825], [-29, -52], [115, -608], [171, -579], [210, -897], [102, -313], [90, -325], [249, -638], [-55, -100], [9, -374], [323, -517], [49, -118], [90, -565], [-61, -105], [40, -593], [102, -687], [106, -142], [152, -213], [161, -666], [77, -529], [152, -281], [379, -544], [154, -328], [151, -332], [87, -198], [136, -173], [66, -178], [-9, -240], [-158, -137], [119, -158], [91, -106], [54, -238], [125, -241], [138, -2], [262, 147], [302, 68], [245, 179], [138, 38], [99, 105], [158, 21], [89, 11], [128, 85], [147, 58], [132, 198], [105, 1], [6, -159], [-25, -335], [1, -303], [-59, -208], [-78, -622], [-134, -644], [-172, -735], [-238, -844], [-237, -645], [-327, -785], [-278, -466], [-415, -572], [-259, -438], [-304, -698], [-64, -304], [-63, -136], [-195, -230], [-68, -240], [-104, -42], [-40, -406], [-89, -233], [-54, -383], [-112, -190], [-128, -709], [16, -327], [178, -210], [8, -149], [-76, -348], [16, -175], [-18, -275], [97, -361], [115, -568], [101, -126], [45, -258], [-11, -574], [34, -505], [11, -900], [49, -282], [-83, -412], [-108, -400], [-177, -357], [-254, -219], [-313, -279], [-313, -618], [-107, -106], [-194, -409], [-115, -133], [-23, -411], [132, -436], [54, -337], [4, -173], [49, 29], [-8, -565], [-45, -267], [65, -99], [-41, -239], [-116, -205], [-229, -195], [-334, -312], [-122, -213], [24, -242], [71, -39], [-24, -303], [-70, -419], [-32, -479], [-72, -260], [-190, -290], [-54, -84], [-118, -292], [-77, -296], [-158, -413], [-314, -594], [-196, -345], [-209, -262], [-291, -224], [-141, -30], [-36, -160], [-169, 85], [-138, -109], [-301, 111], [-168, -70], [-115, 30], [-286, -228], [-238, -91], [-171, -218], [-127, -13], [-117, 205], [-94, 11], [-120, 257], [-13, -80], [-37, 155], [2, 337], [-90, 386], [89, 105], [-7, 442], [-182, 539], [-139, 488], [-1, 1], [-199, 749], [-207, 435], [-108, 420], [-62, 561], [-68, 417], [-93, 887], [-7, 689], [-35, 314], [-108, 237], [-144, 476], [-146, 691], [-60, 361], [-226, 563], [-17, 441], [-26, 363], [38, 506], [96, 527], [15, 247], [90, 519], [66, 236], [159, 377], [90, 257], [29, 426], [-15, 326], [-83, 206], [-74, 350], [-68, 345], [15, 120], [85, 228], [-84, 557], [-57, 385], [-139, 365], [26, 111], [-39, 179], [-74, 433], [-228, 610], [-285, 581], [-184, 475], [-169, 595], [9, 192], [61, 184], [67, 419], [56, 427], [-52, 87], [96, 647], [40, 454], [-108, 381], [-127, 98], [-56, 258], [-71, 82], [3, 159], [-289, -207], [-105, 30], [-107, -129], [-222, 13], [-149, 360], [-91, 417], [-197, 379], [-209, -7], [-245, 1], [-229, -67], [-224, -123], [-436, -337], [-154, -198], [-250, -167], [-248, 164], [-126, -6], [-194, 112], [-178, -6], [-329, -101], [-193, -166], [-275, -211], [-54, 15], [-73, -5], [-286, 274], [-252, 439], [-237, 315], [-187, 371], [-75, 43], [-200, 232], [-144, 308], [-49, 211], [-34, 425], [-122, 341], [-108, 226], [-71, 74], [-69, 115], [-32, 254], [-41, 127], [-80, 94], [-149, 241], [-117, 38], [-63, 162], [1, 88], [-84, 122], [-18, 124], [-46, 441], [36, 255], [-115, 449], [-138, 205], [122, 109], [134, 404], [66, 296], [-24, 311], [78, 284], [34, 542], [-30, 569], [-34, 286], [28, 287], [-72, 274], [-146, 249], [12, 243], [13, 267], [106, 157], [91, 300], [-18, 195], [96, 406], [155, 366], [93, 93], [74, 336], [6, 307], [100, 356], [185, 210], [177, 588], [144, 229], [259, 64], [219, 393], [139, 154], [232, 481], [-70, 716], [106, 495], [37, 304], [179, 389], [278, 263], [206, 238], [186, 596], [87, 354], [205, -3], [167, -244], [264, 39], [288, -127], [121, -6], [267, 315], [300, 100], [175, 238], [268, 175], [471, 102], [459, 47], [140, -85], [262, 227], [297, 4], [113, -134], [190, 35], [302, 233], [195, -70], [-9, -291], [236, 212], [20, -111], [-139, -282], [-2, -266], [96, -143], [-36, -499], [-183, -289], [53, -314], [143, -10], [70, -274], [106, -90], [326, -198], [117, 50], [232, -96], [368, -258], [130, -512], [250, -111], [391, -242], [296, -286], [136, 150], [133, 265], [-65, 441], [87, 280], [200, 270], [192, 78], [375, -118], [95, -257], [104, -3], [88, -98], [276, -67], [68, -191], [369, 10], [268, -152], [275, -170], [129, -90], [214, 182], [114, 165], [245, 48], [198, -73], [75, -286], [65, 189], [222, -136], [217, -33], [137, 145], [80, 190], [-19, 32], [74, 269], [56, 435], [40, 146], [8, 6], [99, 469], [138, 406], [5, 20], [-26, 440], [68, 237], [-102, 261], [105, 217], [-169, -49], [-233, 132], [-191, -331], [-421, -65], [-225, 309], [-300, 19], [-64, -238], [-192, -69], [-268, 307], [-303, -11], [-165, 573], [-203, 320], [135, 448], [-176, 275], [308, 551], [428, 23], [117, 437], [529, -76], [334, 374], [324, 162], [459, 13], [485, -406], [399, -223], [323, 89], [239, -52], [328, 301], [42, 246], [-70, 393], [-160, 212], [-154, 66], [-102, 177], [-354, 486], [-317, 218], [-240, 338], [202, 92], [231, 482], [-156, 228], [410, 234], [-8, 126], [-249, -92], [-222, -46], [-185, -187], [-260, -30], [-239, -215], [16, -358], [136, -139], [284, 35], [-55, -206], [-304, -99], [-377, -334], [-154, 117], [61, 271], [-304, 169], [50, 110], [265, 191], [-80, 132], [-432, 146], [-19, 215], [-257, -71], [-103, -317], [-215, -426], [6, -149], [-135, -123], [-84, 53], [-78, -694], [-144, -239], [-101, -412], [89, -328], [33, -222], [243, -186], [-51, -141], [-330, -32], [-118, -178], [-232, -310], [-87, 268], [3, 119], [-169, 17], [-145, 54], [-336, -150], [192, -323], [-141, -94], [-154, -1], [-147, 297], [-52, -127], [62, -344], [139, -270], [-105, -126], [155, -265], [137, -167], [4, -326], [-257, 153], [82, -294], [-176, -60], [105, -509], [-184, -7], [-228, 251], [-104, 460], [-49, 384], [-108, 264], [-143, 329], [-18, 164], [-48, 40], [-5, 127], [-154, 193], [-24, 274], [23, 393], [38, 179], [-46, 91], [-59, 44], [-78, 188], [-120, 115], [-261, 213], [-161, 207], [-254, 171], [-233, 424], [56, 43], [-127, 242], [-5, 195], [-179, 91], [-85, -249], [-82, 193], [6, 200], [10, 9], [62, 52], [-221, 84], [-226, -204], [15, -286], [-34, -164], [91, -293], [261, -290], [140, -476], [309, -465], [217, 4], [68, -127], [-78, -115], [249, -208], [204, -174], [238, -301], [29, -107], [-52, -206], [-154, 269], [-242, 94], [-116, -372], [200, -214], [-33, -300], [-116, -34], [-148, -494], [-116, -45], [1, 176], [57, 309], [60, 123], [-108, 334], [-85, 290], [-115, 72], [-82, 249], [-179, 105], [-120, 231], [-206, 37], [-217, 260], [-254, 375], [-189, 332], [-86, 569], [-138, 67], [-226, 190], [-128, -78], [-161, -267], [-115, -42], [-252, -326], [-548, 156], [-404, -186], [-32, -347], [15, -335], [-263, -383], [-356, -122], [-25, -194], [-171, -319], [-107, -469], [108, -329], [-160, -257], [-60, -374], [-210, -115], [-197, -443], [-352, -9], [-265, 11], [-174, -203], [-106, -218], [-136, 48], [-103, 195], [-79, 331], [-259, 89], [-112, -149], [-146, 81], [-143, -64], [42, 451], [-26, 354], [-124, 53], [-67, 219], [22, 376], [111, 210], [20, 232], [58, 347], [-6, 244], [-56, 206], [-12, 195], [14, 410], [-114, 250], [393, 415], [340, -104], [373, 4], [296, -98], [230, 30], [449, -19], [144, 345], [53, 1147], [-287, 605], [-205, 291], [-424, 222], [-28, 420], [360, 125], [466, -148], [-88, 652], [263, -247], [646, 449], [84, 472], [243, 116], [222, 113], [143, 159], [244, 847], [380, 241], [231, -16], [54, 122], [232, 31], [52, -127], [188, 284], [-63, 216], [-13, 326], [-113, 320], [-8, 589], [46, 155], [80, 173], [244, 36], [98, 158], [223, 163], [-9, -296], [-82, -188], [33, -161], [151, -87], [-68, -217], [-83, 62], [-200, -414], [76, -281], [4, -222], [281, -135], [-3, -204], [283, 108], [156, 158], [313, -228], [132, -183], [189, 169], [434, 267], [350, 194], [277, -97], [21, -140], [268, -8], [63, 254], [383, 187], [-59, 484], [10, 433], [136, 362], [262, 196], [221, -430], [223, 11], [53, 443], [32, 339], [-102, -72], [-176, 204], [-24, 331], [351, 161], [350, 83], [301, -95], [287, 17], [316, 318], [-291, 274], [-504, -46], [-489, -211], [-452, -121], [-161, 314], [-269, 189], [62, 567], [-135, 520], [133, 335], [252, 362], [635, 624], [185, 121], [-28, 243], [-387, 272], [-478, -163], [-269, -401], [43, -353], [-441, -463], [-537, -495], [-202, -811], [198, -406], [265, -320], [-255, -649], [-289, -135], [-106, -967], [-157, -539], [-337, 55], [-158, -456], [-321, -27], [-89, 545], [-232, 653], [-211, 814], [-187, 354], [-548, -666], [-370, -135], [-385, 293], [-99, 619], [-88, 1329], [256, 371], [733, 483], [549, 595], [508, 802], [668, 1112], [465, 434], [763, 722], [610, 252], [457, -31], [423, 477], [506, -25], [499, 115], [869, -422], [-358, -154], [305, -361], [286, 200], [456, -348], [761, -137], [1050, -652], [213, -273], [18, -384], [-308, -302], [-454, -154], [-1240, 438], [-204, -73], [453, -422], [36, -856], [358, -175], [217, -150], [36, 279], [-174, 257], [183, 209], [672, -358], [234, 140], [-187, 422], [647, 564], [256, -33], [260, -202], [161, 396], [-231, 343], [136, 345], [-204, 357], [777, -185], [158, -322], [-351, -71], [2, -321], [218, -197], [429, 125], [68, 367], [581, 275], [969, 494], [209, -28], [-273, -350], [344, -60], [199, 197], [521, 16], [412, 239], [317, -347], [315, 381], [-291, 334], [145, 190], [820, -175], [385, -180], [1006, -658], [186, 302], [-282, 304], [-8, 122], [-335, 57], [92, 273], [-149, 449], [-8, 185], [512, 521], [182, 524], [207, 113], [735, -152], [58, -320], [-263, -467], [173, -184], [89, -403], [-63, -789], [307, -353], [-120, -384], [-544, -818], [318, -85], [110, 207], [306, 148], [74, 285], [240, 274], [-162, 328], [130, 380], [-304, 47], [-67, 321], [222, 578], [-361, 469], [497, 389], [-64, 409], [139, 13], [145, -319], [-109, -556], [297, -105], [-127, 415], [465, 227], [577, 30], [513, -328], [-247, 479], [-28, 614], [484, 116], [668, -25], [602, 75], [-226, 301], [321, 379], [319, 15], [540, 286], [734, 77], [93, 158], [729, 53], [227, -129], [624, 306], [510, -10], [77, 249], [265, 245], [656, 236], [476, -186], [-378, -142], [629, -89], [75, -284], [254, 140], [812, -8], [626, -281], [223, -215], [-69, -300], [-307, -170], [-730, -320], [-209, -171], [345, -80], [410, -146], [250, 109], [142, -369], [122, 149], [444, 91], [892, -95], [67, -269], [1162, -86], [15, 440], [590, -101], [443, 3], [449, -303], [128, -369], [-165, -241], [349, -453], [437, -234], [268, 605], [446, -260], [473, 155], [538, -177], [204, 162], [455, -81], [-201, 535], [367, 249], [2509, -374], [236, -342], [727, -440], [1122, 109], [553, -95], [231, -238], [-33, -421], [342, -164], [372, 118], [492, 15], [525, -113], [526, 64], [484, -512], [344, 184], [-224, 368], [123, 256], [886, -161], [578, 34], [799, -274], [-99610, -252]], [[63641, 75603], [141, -409], [130, -26], [85, -156], [-228, -46], [-49, -447], [-47, -202], [-102, -135], [7, -285], [88, -424], [263, -120], [193, -289], [395, -100], [434, 153], [27, 134], [-52, 408], [40, 602], [-216, 195], [71, 394], [-184, 34], [61, 485], [262, -141], [244, 184], [-202, 346], [-80, 329], [-224, -147], [-28, -422], [-87, 374], [-15, 140], [68, 240], [-53, 201], [-322, 196], [-125, 517], [-154, 146], [-9, 187], [270, -54], [11, 421], [236, 93], [243, -86], [50, 562], [-50, 356], [-278, -28], [-236, 141], [-321, -253], [-259, -121], [-127, -342], [-269, -95], [-276, -594], [252, -547], [-27, -387], [303, -679], [146, -303]], [[23933, 96472], [-126, -17], [-521, 37], [-74, 161], [559, -9], [195, -107], [-33, -65]], [[19392, 96574], [-518, -166], [-411, 186], [224, 183], [406, 59], [392, -90], [-93, -172]], [[56867, 96664], [-620, -236], [-490, 134], [191, 149], [-167, 184], [575, 115], [110, -216], [401, -130]], [[19538, 97095], [-339, -113], [-461, 1], [5, 82], [285, 173], [149, -27], [361, -116]], [[23380, 96781], [-411, -119], [-226, 134], [-119, 216], [-22, 238], [360, -23], [162, -38], [332, -200], [-76, -208]], [[22205, 96935], [108, -240], [-453, 64], [-457, 187], [-619, 21], [268, 171], [-335, 139], [-21, 221], [546, -79], [751, -210], [212, -274]], [[79187, 96925], [-1566, -222], [507, 756], [229, 64], [208, -37], [704, -327], [-82, -234]], [[55069, 97728], [915, -429], [-699, -227], [-155, -424], [-243, -108], [-132, -478], [-335, -22], [-598, 351], [252, 205], [-416, 166], [-541, 487], [-216, 451], [757, 206], [152, -202], [396, 8], [105, 197], [408, 20], [350, -201]], [[57068, 98134], [545, -202], [-412, -310], [-806, -68], [-819, 96], [-50, 159], [-398, 10], [-304, 264], [858, 161], [403, -138], [281, 172], [702, -144]], [[64204, 98215], [-373, -76], [-250, -44], [-39, -94], [-324, -95], [-301, 136], [158, 180], [-618, 17], [542, 105], [422, 7], [57, -155], [159, 138], [262, 95], [412, -126], [-107, -88]], [[77760, 97255], [-606, -71], [-773, 166], [-462, 220], [-213, 413], [-379, 113], [722, 394], [600, 130], [540, -290], [640, -557], [-69, -518]], [[25828, 97704], [334, -186], [-381, -171], [-513, -434], [-492, -41], [-575, 74], [-299, 235], [4, 208], [220, 154], [-508, -5], [-306, 192], [-176, 261], [193, 256], [192, 175], [285, 41], [-122, 132], [646, 29], [355, -308], [468, -123], [455, -109], [220, -380]], [[30972, 99689], [742, -45], [597, -74], [508, -156], [-12, -154], [-678, -250], [-672, -117], [-251, -129], [605, 3], [-656, -349], [-452, -163], [-476, -470], [-573, -96], [-177, -117], [-841, -62], [383, -72], [-192, -103], [230, -284], [-264, -198], [-429, -163], [-132, -225], [-388, -172], [39, -130], [475, 22], [6, -141], [-742, -345], [-726, 159], [-816, -89], [-414, 69], [-525, 30], [-35, 277], [514, 130], [-137, 415], [170, 41], [742, -249], [-379, 370], [-450, 110], [225, 223], [492, 137], [79, 201], [-392, 225], [-118, 297], [759, -25], [220, -63], [433, 210], [-625, 67], [-972, -37], [-491, 196], [-232, 232], [-324, 169], [-61, 197], [413, 110], [324, 18], [545, 94], [409, 214], [344, -30], [300, -161], [211, 311], [367, 92], [498, 64], [849, 24], [148, -63], [802, 98], [601, -37], [602, -36]], [[42472, 99927], [1737, -457], [-513, -222], [-1062, -25], [-1496, -56], [140, -103], [984, 63], [836, -198], [540, 176], [231, -206], [-305, -335], [707, 214], [1348, 223], [833, -111], [156, -246], [-1132, -410], [-157, -133], [-888, -99], [643, -28], [-324, -420], [-224, -373], [9, -641], [333, -376], [-434, -24], [-457, -182], [513, -305], [65, -490], [-297, -53], [360, -495], [-617, -42], [322, -234], [-91, -203], [-391, -89], [-388, -2], [348, -390], [4, -256], [-549, 238], [-143, -154], [375, -144], [364, -352], [105, -464], [-495, -111], [-214, 222], [-344, 331], [95, -391], [-322, -303], [732, -24], [383, -31], [-745, -502], [-755, -454], [-813, -199], [-306, -2], [-288, -222], [-386, -608], [-597, -404], [-192, -23], [-370, -142], [-399, -134], [-238, -357], [-4, -403], [-141, -378], [-453, -461], [112, -450], [-125, -476], [-142, -563], [-391, -35], [-410, 471], [-556, 3], [-269, 315], [-186, 563], [-481, 716], [-141, 375], [-38, 517], [-384, 532], [100, 424], [-186, 203], [275, 673], [418, 214], [110, 241], [58, 450], [-318, -204], [-151, -85], [-249, -83], [-341, 188], [-19, 392], [109, 306], [258, 8], [567, -153], [-478, 366], [-249, 197], [-276, -81], [-232, 143], [310, 536], [-169, 215], [-220, 398], [-335, 611], [-353, 223], [3, 241], [-745, 337], [-590, 42], [-743, -23], [-677, -42], [-323, 183], [-482, 362], [729, 181], [559, 31], [-1188, 149], [-627, 236], [39, 223], [1051, 277], [1018, 277], [107, 210], [-750, 206], [243, 230], [961, 402], [404, 62], [-115, 258], [658, 152], [854, 90], [853, 6], [303, -180], [737, 317], [663, -215], [390, -45], [577, -188], [-660, 311], [38, 246], [932, 344], [975, -26], [354, 213], [982, 55], [2219, -72]]],
  "transform": {
    "scale": [0.0036000360003600037, 0.001736468664686647],
    "translate": [-180, -90]
  }
};

},{}],35:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

require('es5-shim');

require('./initializers/catch-promise-errors');

var $ = require('jquery');

var Configuration = require('./configuration');

var ErrorReporter = require('./error-reporter');

var I18n = require('./i18n'); // Controllers


var SelectionsController = require('./controllers/selections-controller');

var StickyElementsController = require('./controllers/sticky-elements-controller');

var StandaloneShareController = require('./controllers/standalone-share-controller');

var CountryDashboardController = require('./controllers/country-dashboard-controller');

var PinboardEditorController = require('./controllers/pinboard-editor-controller');

var ChartsController = require('charts-controller');

var ChartControlsController = require('./controllers/chart-controls-controller'); // Smaller widgets


var Dropdown = require('./views/dropdown');

var DropdownMultiple = require('./views/dropdown-multiple');

var MoreSection = require('./views/more-section');

var CitationView = require('./views/citation-view'); // Full application for the data portal web sites and charts.


var Application = /*#__PURE__*/function () {
  function Application() {
    (0, _classCallCheck2.default)(this, Application);
  }

  (0, _createClass2.default)(Application, [{
    key: "initialize",
    value: // Property declarations
    // ---------------------
    //
    // chartViews: Array
    function initialize() {
      // Initialize singletons
      Configuration.load(window.DDP_CHART_CONFIG);
      ErrorReporter.init();
      I18n.init();
      this.createWidgets();
      this.createControllers();
      this.createCharts();
    } // Creates smaller widgets

  }, {
    key: "createWidgets",
    value: function createWidgets() {
      // More sections
      $('.more-section').each(function (index, el) {
        new MoreSection({
          el: el
        });
      }); // Toggle header menu (small screen)

      $('.header-statistics-inner .toggle-search-form').click(function () {
        $('.header-statistics-inner').toggleClass('header-search-form-open');
      }); // Dropdowns

      $('.ddp-root .dropdown').each(function (index, el) {
        new Dropdown({
          el: el
        });
      }); // Dropdowns multiple

      $('.ddp-root .dropdown-multiple').each(function (index, el) {
        new DropdownMultiple({
          el: el
        });
      }); // Close alerts

      $('.alert .close').click(function (event) {
        $(event.target).closest('.alert').hide();
      }); // Citation box

      $('.citation').each(function (index, el) {
        new CitationView({
          el: el
        });
      });
    }
  }, {
    key: "createControllers",
    value: function createControllers() {
      // SelectionsController needs to be initialized before ChartsController
      new SelectionsController().create();
      new StickyElementsController().create();
      new StandaloneShareController().create();
      new CountryDashboardController().create();
      new PinboardEditorController().create();
    }
  }, {
    key: "createCharts",
    value: function createCharts() {
      var _ChartsController$cre = new ChartsController().create(),
          chartViews = _ChartsController$cre.chartViews;

      new ChartControlsController().create(chartViews);
    }
  }]);
  return Application;
}(); // Bootstrap the application


new Application().initialize();

},{"./configuration":67,"./controllers/chart-controls-controller":75,"./controllers/country-dashboard-controller":76,"./controllers/pinboard-editor-controller":77,"./controllers/selections-controller":78,"./controllers/standalone-share-controller":79,"./controllers/sticky-elements-controller":80,"./error-reporter":81,"./i18n":82,"./initializers/catch-promise-errors":83,"./views/citation-view":157,"./views/dropdown":162,"./views/dropdown-multiple":161,"./views/more-section":166,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"charts-controller":"charts-controller","es5-shim":28,"jquery":"jquery"}],36:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var methodBinding = require('../util/method-binding');

var TooltipService = require('./tooltip-service');

var Annotation = require('./annotation');
/** @typedef {import('./tooltip')} Tooltip */

/** @typedef {import('./tooltip').TooltipXPlacement} TooltipXPlacement */

/** @typedef {import('./tooltip').TooltipYPlacement} TooltipYPlacement */
// Constants
// ---------


var PROPERTY_NAME = 'ddpAnnotation';

var AnnotationService = /*#__PURE__*/function (_TooltipService) {
  (0, _inherits2.default)(AnnotationService, _TooltipService);

  var _super = _createSuper(AnnotationService);

  // Property declarations
  // ---------------------
  //
  // annotations: Array
  // layoutHandle: Number
  //   setTimeout handle
  // forcedPlacement: { x: String, y: String }
  //   Forces the placement of the tooltips instead of auto-layouting them.

  /**
   * @param {{
   * container: Element,
   * forcedPlacement?: { x: TooltipXPlacement, y: TooltipYPlacement }
   * }} options
   */
  function AnnotationService(options) {
    var _this;

    (0, _classCallCheck2.default)(this, AnnotationService);
    _this = _super.call(this, options);

    _this.bindMethods();

    var forcedPlacement = options.forcedPlacement;

    if (forcedPlacement) {
      _this.forcedPlacement = forcedPlacement;
    }

    return _this;
  } // Layouting
  // ---------


  (0, _createClass2.default)(AnnotationService, [{
    key: "layoutInNextTick",
    value: function layoutInNextTick() {
      if (this.layoutHandle) {
        clearTimeout(this.layoutHandle);
      }

      this.layoutHandle = setTimeout(this.layout, 10);
    }
  }, {
    key: "layout",
    value: function layout() {
      if (this.forcedPlacement) {
        this.fixedLayout();
      } else {
        this.autoLayout();
      }
    } // Applies the fixed placement.

  }, {
    key: "fixedLayout",
    value: function fixedLayout() {
      var _this2 = this;

      var tooltips = this.tooltips;
      tooltips.forEach(function (tooltip) {
        tooltip.createElement();
        tooltip.setPlacement(_this2.forcedPlacement.x, _this2.forcedPlacement.y);
        tooltip.calculatePositionAtTarget();
      }); // Apply positions in one go to avoid Layout Thrashing

      tooltips.forEach(function (tooltip) {
        tooltip.applyPosition();
      });
    }
    /**
     * Auto-layouts annotations so overlap is reduced.
     */

  }, {
    key: "autoLayout",
    value: function autoLayout() {
      var _this3 = this;

      delete this.layoutHandle; // Tend to place the tooltips left-aligned

      var xPlacementThreshold = this.container.width() * 0.45;
      var tooltips = this.tooltips;
      tooltips.forEach(function (tooltip) {
        tooltip.createElement(); // Hide while layouting

        tooltip.hide();

        _this3.layoutTooltip(tooltip, xPlacementThreshold);
      });

      var sortedTooltips = _.sortBy(tooltips, function (tooltip) {
        return tooltip.position.y;
      });

      sortedTooltips.forEach(this.decollideTooltip); // Apply positions in one go to avoid Layout Thrashing

      sortedTooltips.forEach(function (tooltip) {
        tooltip.applyPosition();
      });
    }
    /**
     * Sets the initial tooltip position before decollision.
     *
     * @param {Tooltip} tooltip
     * @param {number} xPlacementThreshold
     */

  }, {
    key: "layoutTooltip",
    value: function layoutTooltip(tooltip, xPlacementThreshold) {
      // Tooltips in the left half are left-aligned,
      // tooltips in the right half are right-aligned.
      var xPlacement = tooltip.targetPosition().x < xPlacementThreshold ? 'right' : 'left';
      var yPlacement = 'center';
      tooltip.setPlacement(xPlacement, yPlacement);
      tooltip.calculatePositionAtTarget();
    }
    /**
     * Changes the position if a tooltip overlaps with the previous.
     * Switches the y position to avoid overlap.
     *
     * @param {Tooltip} tooltip
     * @param {number} tooltipIndex
     * @param {Tooltip[]} tooltips
     */

  }, {
    key: "decollideTooltip",
    value: function decollideTooltip(tooltip, tooltipIndex, tooltips) {
      var list = tooltips.slice(0, tooltipIndex);

      for (var i = 0, l = list.length; i < l; i++) {
        var previous = list[i];
        var overlap = this.overlap(previous, tooltip);

        if (overlap) {
          if (tooltipIndex === 1) {
            previous.setPlacement(previous.placement.x, 'top');
            previous.calculatePositionAtTarget();
          } else {
            tooltip.setPlacement(tooltip.placement.x, 'bottom');
            tooltip.calculatePositionAtTarget();
          }
        }
      }
    }
    /**
     * Returns whether two tooltips overlap
     *
     * @param {Tooltip} tooltip1
     * @param {Tooltip} tooltip2
     */

  }, {
    key: "overlap",
    value: function overlap(tooltip1, tooltip2) {
      var a = tooltip1.boundingBox();
      var b = tooltip2.boundingBox();
      return a.x <= b.x + b.width && b.x <= a.x + a.width && a.y <= b.y + b.height && b.y <= a.y + a.height;
    } // Disposal
    // --------

  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(AnnotationService.prototype), "dispose", this).call(this);

      if (this.layoutHandle) {
        clearTimeout(this.layoutHandle);
      }
    }
  }]);
  return AnnotationService;
}(TooltipService);

_.assign(AnnotationService.prototype, methodBinding);

AnnotationService.prototype.boundMethods = ['layout', 'autoLayout', 'decollideTooltip'];
AnnotationService.prototype.propertyName = PROPERTY_NAME;
AnnotationService.prototype.tooltipConstructor = Annotation;
module.exports = AnnotationService;

},{"../util/method-binding":134,"./annotation":37,"./tooltip-service":64,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"lodash":"lodash"}],37:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Tooltip = require('./tooltip'); // An annotation is a fixed tooltip.


var Annotation = /*#__PURE__*/function (_Tooltip) {
  (0, _inherits2.default)(Annotation, _Tooltip);

  var _super = _createSuper(Annotation);

  function Annotation() {
    (0, _classCallCheck2.default)(this, Annotation);
    return _super.apply(this, arguments);
  }

  return Annotation;
}(Tooltip);

Annotation.prototype.className = 'tooltip annotation';
module.exports = Annotation;

},{"./tooltip":66,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],38:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var I18n = require('../i18n');

var _require = require('../util/chart'),
    dataWithLastValue = _require.dataWithLastValue,
    dataWithLatestValue = _require.dataWithLatestValue,
    extent = _require.extent,
    hasValue = _require.hasValue,
    idKey = _require.idKey,
    singleDSelector = _require.singleDSelector,
    singleValueSelector = _require.singleValueSelector;

var numberFormatter = require('../util/number-formatter');

var SingleTimePeriodChart = require('./single-time-period-chart');

var tooltipTemplates = require('./tooltip-templates');
/** @typedef {import('../types/types').DataPoint} DataPoint */

/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').LocationWithValues} LocationWithValues */

/** @typedef {import('../types/types').LocationsWithValues} LocationsWithValues */
// Constants
// ---------
// The class of the element that represents a datum


var ITEM_CLASS = 'bar-group';

var BarChart = /*#__PURE__*/function (_SingleTimePeriodChar) {
  (0, _inherits2.default)(BarChart, _SingleTimePeriodChar);

  var _super = _createSuper(BarChart);

  function BarChart() {
    (0, _classCallCheck2.default)(this, BarChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(BarChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(BarChart.prototype), "initialize", this).call(this, options);
      /** @type {d3.scale.Ordinal<string, number>} */

      this.x;
      /** @type {d3.scale.Linear<number, number>} */

      this.y;
      /** @type {number} */

      this.xRangeBand;
      /** @type {number} */

      this.barWidth;
      /** @type {number} */

      this.barX;
      this.base.classed('single-time-period-chart bar-chart', true);
    } // Data transformation
    // -------------------

    /**
     *
     * @param {RawChartData} data
     * @returns {RawChartData}
     */

  }, {
    key: "transform",
    value: function transform(data) {
      var transformed = this.model.get('useLatestData') ? dataWithLatestValue(data) : dataWithLastValue(data); // Filter missing values

      transformed.filteredLocationsWithValues = transformed.filteredLocationsWithValues.filter(function (locationWithValues) {
        return hasValue(singleDSelector(locationWithValues));
      }); // Sorting by value for ranking

      transformed.filteredLocationsWithValues = _.orderBy(transformed.filteredLocationsWithValues, function (locationWithValues) {
        return singleValueSelector(locationWithValues);
      }, this.model.get('sorting'));
      return transformed;
    }
    /**
     * @param {Element} barGroup
     * @param {LocationWithValues} locationWithValues
     */

  }, {
    key: "updateBarGroup",
    value: function updateBarGroup(barGroup, locationWithValues) {
      var _this = this;

      var d = singleDSelector(locationWithValues);
      var value = d.value;
      this.updateHighlight(barGroup, d);
      var $barGroup = d3.select(barGroup); // Calculate bar attributes for reuse

      var barY = value != null ? this.y(Math.max(0, value)) : 0;
      var barHeight = value != null ? Math.abs(this.y(value) - this.y(0)) : 0;
      var barAttributes = {
        x: this.barX,
        y: barY,
        width: this.barWidth,
        height: barHeight
      }; // Update the bar

      $barGroup.select('.bar').attr(barAttributes); // Update the bar hover helper

      var barHoverHelper = $barGroup.select('.bar-hover-helper').attr({
        x: 0,
        y: barY,
        width: this.xRangeBand,
        height: barHeight
      });
      this.addBarTooltip(barHoverHelper.node(), d); // Accessible description

      $barGroup.select('.bar-desc').text(function () {
        var timePeriod = d.timePeriodName;

        var formattedValue = _this.formatLabel(value);

        var measure = _this.measure.name;
        return "".concat(d.name, ", ").concat(timePeriod, ": ").concat(formattedValue, " ").concat(measure);
      });
      this.updateValueLabel($barGroup.select('.value-label'), barAttributes, d);
    }
    /**
     * @param {SVGRectElement} rect
     * @param {DataPoint} d
     */

  }, {
    key: "addBarTooltip",
    value: function addBarTooltip(rect, d) {
      if (hasValue(d)) {
        this.addTooltip({
          target: rect,
          render: this.tooltipContent,
          d: d
        });
      } else {
        this.removeTooltip(rect);
      }
    }
    /**
     *
     * @param {d3.Selection} valueLabel
     * @param {{ x: number, y: number, width: number, height: number }} barAttributes
     * @param {DataPoint} d
     */

  }, {
    key: "updateValueLabel",
    value: function updateValueLabel(valueLabel, barAttributes, d) {
      if (this.valueLabelVisible && this.isForegroundLocation(d.id)) {
        var x = barAttributes.x + barAttributes.width / 2;
        var y = barAttributes.y - 6;
        valueLabel.attr({
          x: x,
          y: y,
          visibility: 'visible'
        }).text(this.formatLabelSuffixed(d.value));
      } else {
        valueLabel.attr('visibility', 'hidden');
      }
    } // Tooltips
    // --------

    /**
     * @param {DataPoint} d
     */

  }, {
    key: "tooltipContent",
    value: function tooltipContent(d) {
      /** @type {{ abbr: string, description: string } | null} */
      var obsInfo = d.status ? I18n.t('observationStatus')[d.status.id] : null;
      return tooltipTemplates.full.render({
        location: d.name,
        timePeriod: d.timePeriodName,
        value: this.formatLabel(d.value),
        measure: this.measure.name,
        observationStatusAbbr: obsInfo ? obsInfo.abbr : null,
        observationStatusDescription: obsInfo ? obsInfo.description : null
      });
    }
  }]);
  return BarChart;
}(SingleTimePeriodChart);

BarChart.prototype.itemClass = ITEM_CLASS;
/** @type {import('../types/types').Dependents<RawChartData, BarChart>} */

BarChart.prototype.dependents = {
  // Scales
  // ------
  // The extent of the data as [min: Number, max: Number]
  dataExtent: {
    recipe: function recipe(data) {
      var _extent = extent(data.filteredLocationsWithValues),
          _extent2 = (0, _slicedToArray2.default)(_extent, 2),
          min = _extent2[0],
          max = _extent2[1]; // The minimum must not be larger that 0


      if (min > 0) {
        min = 0;
      } // If min and max are identical, apply some scale


      if (min === max) {
        max = Math.abs(min * 5);
      }

      return [min, max];
    }
  },
  locationIds: {
    recipe: function recipe(data) {
      return data.filteredLocationsWithValues.map(idKey);
    }
  },
  // x scale without range band padding
  x: {
    after: ['plotWidth', 'locationIds'],
    initial: function initial() {
      return d3.scale.ordinal();
    },

    /**
     * @param {RawChartData} data
     * @param {d3.scale.Ordinal<string, number>} scale
     */
    recipe: function recipe(_data, scale) {
      return scale.rangeRoundBands([0, this.plotWidth], 0, 0).domain(this.locationIds);
    }
  },
  y: {
    after: ['plotHeight', 'dataExtent'],
    initial: function initial() {
      return d3.scale.linear();
    },

    /**
     * @param {RawChartData} data
     * @param {d3.scale.Linear<number, number>} scale
     */
    recipe: function recipe(_data, scale) {
      return scale.range([this.plotHeight, 0]).domain(this.dataExtent);
    }
  },
  xRangeBand: {
    after: ['x'],
    recipe: function recipe() {
      return this.x.rangeBand();
    }
  },
  barWidth: {
    after: ['xRangeBand'],
    recipe: function recipe() {
      return Math.floor(this.xRangeBand * (1 - this.rangePadding));
    }
  },
  barX: {
    after: ['xRangeBand', 'barWidth'],
    recipe: function recipe() {
      return (this.xRangeBand - this.barWidth) / 2;
    }
  },
  valueLabelVisible: {
    after: ['xRangeBand'],
    recipe: function recipe() {
      return this.xRangeBand > 20;
    }
  },
  formatLabelSuffixed: {
    after: ['dataExtent'],
    recipe: function recipe() {
      return numberFormatter.labelFormatter(this.dataExtent, true, true);
    }
  }
}; // Layers
// ------

/**
 * @type {import('../types/types').LayerOptions<
 * RawChartData, LocationsWithValues, BarChart
 * >}
 */

BarChart.prototype.locationsLayerConfig = {
  dataBind: function dataBind(data) {
    return this.selectAll(".".concat(this.chart().itemClass)).data(data.filteredLocationsWithValues, idKey);
  },
  insert: function insert() {
    return this.append('g').attr('class', this.chart().itemClass);
  },
  events: {
    enter: function enter() {
      // Actual bar
      var bar = this.append('rect').attr('class', 'bar'); // Accessible description

      bar.append('desc').attr('class', 'bar-desc'); // Bar hover helper

      this.append('rect').attr('class', 'bar-hover-helper'); // Value label

      this.append('text').attr('class', 'value-label');
    },
    merge: function merge() {
      var chart = this.chart(); // Add the location id as an attribute

      this.attr({
        'data-id': idKey,
        transform: function transform(d) {
          return "translate(".concat(chart.x(d.id), ", 0)");
        }
      });
      this.each(function (locationWithValues) {
        chart.updateBarGroup(this, locationWithValues);
      });
    },
    exit: function exit() {
      var chart = this.chart();
      this.select('.bar').each(function () {
        chart.removeTooltip(this);
      });
      this.remove();
    }
  }
};
BarChart.prototype.boundMethods = ['tooltipContent'];
module.exports = BarChart;

},{"../i18n":82,"../util/chart":119,"../util/number-formatter":135,"./single-time-period-chart":59,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/slicedToArray":20,"d3":27,"lodash":"lodash"}],39:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var I18n = require('../i18n');

var _require = require('../util/chart'),
    extent = _require.extent,
    hasValue = _require.hasValue,
    idKey = _require.idKey,
    latestDataPoint = _require.latestDataPoint,
    selector = _require.selector,
    singleDSelector = _require.singleDSelector,
    singleValueSelector = _require.singleValueSelector;

var numberFormatter = require('../util/number-formatter');

var PaddedChart = require('./padded-chart');

var ChartLabels = require('./chart-labels');

var _require2 = require('./location-labels'),
    LocationLabels = _require2.LocationLabels,
    marginBottomDependent = _require2.marginBottomDependent;

var tooltipTemplates = require('./tooltip-templates');
/** @typedef {import('../types/types').IdAndName} IdAndName */

/** @typedef {import('../types/types').DataPoint} DataPoint */

/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').LocationWithValues} LocationWithValues */

/** @typedef {import('../types/types').LocationsWithValues} LocationsWithValues */

/** @typedef {import('../types/types').ChartMode} ChartMode */
// Constants
// ---------

/**
 * @type {{ [key: ChartMode]: number }}
 */


var POINT_RADIUS_MAP = {
  small: 1.5,
  reduced: 2.5,
  normal: 4,
  big: 5,
  large: 6
};
var POINT_HOVER_HELPER_RADIUS = 6; // The class for the main layer group

var LOCATIONS_CLASS = 'locations';
var ITEM_CLASS = 'location-group';
var BAR_CLASS = 'bar';
var BAR_DESC_CLASS = 'bar-desc';
var POINT_CLASS = 'point';
var POINT_HOVER_HELPER_CLASS = 'point-hover-helper';
var POINT_DESC_CLASS = 'point-desc';
/**
 * Selects the second data point for a locationWithValues.
 *
 * @param {LocationWithValues} locationWithValues
 */

var secondDSelector = function secondDSelector(locationWithValues) {
  return locationWithValues.values[1];
};
/**
 * Returns the second number value for a LocationWithValues.
 *
 * @param {LocationWithValues} locationWithValues
 */


var secondValueSelector = function secondValueSelector(locationWithValues) {
  return secondDSelector(locationWithValues).value;
};

var BarPointChart = /*#__PURE__*/function (_PaddedChart) {
  (0, _inherits2.default)(BarPointChart, _PaddedChart);

  var _super = _createSuper(BarPointChart);

  function BarPointChart() {
    (0, _classCallCheck2.default)(this, BarPointChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(BarPointChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(BarPointChart.prototype), "initialize", this).call(this, options);
      /** @type {d3.scale.Ordinal<string>} */

      this.x;
      /** @type {d3.scale.Linear<number, number>} */

      this.y;
      this.base.classed('bar-point-chart', true); // Location labels

      this.locationLabels = this.base.append('g').attr('class', LocationLabels.BASE_CLASS);
      this.attach('locationLabels', new LocationLabels(this.locationLabels, {
        model: this.model,
        x: this.x,
        xAxisModes: this.xAxisModes,
        highlightService: this.highlightService,
        dataForLocationLabels: this.dataForLocationLabels,
        isLabelVisible: this.isLabelVisible
      })); // y axis

      var labels = this.base.append('g').attr('class', 'chart-labels');
      this.attach('labels', new ChartLabels(labels, {
        model: this.model,
        yAxis: this.yAxis,
        interactiveTooltipService: this.interactiveTooltipService
      }));
      this.locationsGroup = this.base.append('g').attr('class', LOCATIONS_CLASS);
      this.layer('locations', this.locationsGroup, this.locationsLayerConfig);
    } // Transformation
    // --------------

    /**
     * Transforms the data so there is only the first and last value
     * @param {RawChartData} data
     * @returns {RawChartData}
     */

  }, {
    key: "transform",
    value: function transform(data) {
      var _this = this;

      // In small mode, show only highlighted and baseline
      var showForegroundLocationsOnly = this.model.get('mode') === 'small' && this.highlightService.hasHighlightedLocations();
      var useLatestData = this.model.get('useLatestData');
      var locations = data.filteredLocationsWithValues // Filter background locations
      .filter(function (locationWithValues) {
        return !showForegroundLocationsOnly || _this.isForegroundLocation(locationWithValues.id);
      }) // Reduce values to the first and last
      .map(function (locationWithValues) {
        var locationWithTwoValues = _.create(locationWithValues);

        var firstValue = singleDSelector(locationWithValues);
        var lastValue = latestDataPoint(locationWithValues.values, useLatestData);
        locationWithTwoValues.values = [firstValue, lastValue];
        return locationWithTwoValues;
      }) // Both values must be present
      .filter(function (locationWithValues) {
        return locationWithValues.values.every(hasValue);
      }); // Sort by most recent value

      var sortedLocations = _.orderBy(locations, secondValueSelector, this.model.get('sorting'));

      return _.create(data, {
        filteredLocationsWithValues: sortedLocations
      });
    } // Drawing
    // -------

  }, {
    key: "applyDependents",
    value: function applyDependents(data) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(BarPointChart.prototype), "applyDependents", this).call(this, data);
      this.locationsGroup.attr('transform', "translate(".concat(this.paddingLeft, " ").concat(this.paddingTop, ")"));
      this.locationLabels.attr('transform', "translate(".concat(this.paddingLeft, " ").concat(this.height - this.marginBottom, ")"));
    }
    /**
     * @param {DataPoint} dataPoint
     */

  }, {
    key: "desc",
    value: function desc(dataPoint) {
      var timePeriod = dataPoint.timePeriodName;
      var formattedValue = this.formatLabel(dataPoint.value);
      var measure = this.measure.name;
      return "".concat(dataPoint.name, ", ").concat(timePeriod, ": ").concat(formattedValue, " ").concat(measure);
    } // Tooltips
    // --------

    /**
     * @param {Element} element
     * @param {DataPoint} dataPoint
     */

  }, {
    key: "updateTooltip",
    value: function updateTooltip(element, dataPoint) {
      this.addTooltip({
        target: element,
        render: this.tooltipContent,
        d: dataPoint
      });
    }
    /**
     * @param {DataPoint} d
     */

  }, {
    key: "tooltipContent",
    value: function tooltipContent(d) {
      /** @type {{ abbr: string, description: string } | null} */
      var obsInfo = d.status ? I18n.t('observationStatus')[d.status.id] : null;
      return tooltipTemplates.full.render({
        location: d.name,
        timePeriod: d.timePeriodName,
        value: this.formatLabel(d.value),
        measure: this.measure.name,
        observationStatusAbbr: obsInfo ? obsInfo.abbr : null,
        observationStatusDescription: obsInfo ? obsInfo.description : null
      });
    } // Location labels
    // ---------------

    /**
     * Function passed to LocationLabels to determine the visible locations.
     * @param {RawChartData} data
     */

  }, {
    key: "dataForLocationLabels",
    value: function dataForLocationLabels(data) {
      return data.filteredLocationsWithValues;
    }
    /**
     * Function passed to LocationLabels to determine whether a label is visible.
     * @param {LocationWithValues} locationWithValues
     */

  }, {
    key: "isLabelVisible",
    value: function isLabelVisible(locationWithValues) {
      return hasValue(singleDSelector(locationWithValues));
    }
  }]);
  return BarPointChart;
}(PaddedChart); // Dependents
// ----------

/** @type {import('../types/types').Dependents<RawChartData, BarPointChart>} */


BarPointChart.prototype.dependents = {
  // Scales
  // ------
  // The extent of the data as [min: Number, max: Number]
  dataExtent: {
    recipe: function recipe(data) {
      var _extent = extent(data.filteredLocationsWithValues),
          _extent2 = (0, _slicedToArray2.default)(_extent, 2),
          min = _extent2[0],
          max = _extent2[1]; // Ensure that min/max is 0 when the numbers are in the same quadrant


      if (min > 0 && max > 0) {
        min = 0;
      } else if (min < 0 && max < 0) {
        max = 0;
      } // If min and max are identical, apply some scale


      if (min === max) {
        max = Math.abs(min * 5);
      }

      return [min, max];
    }
  },
  // x scale
  x: {
    after: ['plotWidth'],
    initial: function initial() {
      return d3.scale.ordinal();
    },

    /**
     * @param {d3.scale.Ordinal<string>} scale
     */
    recipe: function recipe(data, scale) {
      var locationIds = data.filteredLocationsWithValues.map(idKey);
      return scale.rangeRoundBands([0, this.plotWidth], 0.2, 0).domain(locationIds);
    }
  },
  y: {
    after: ['plotHeight', 'dataExtent'],
    initial: function initial() {
      return d3.scale.linear();
    },

    /**
     * @param {d3.scale.Linear<number, number>} scale
     */
    recipe: function recipe(_data, scale) {
      return scale.range([this.plotHeight, 0]).domain(this.dataExtent);
    }
  },
  // Margins
  // -------
  marginBottom: marginBottomDependent,
  // Padding
  // -------
  paddingBottom: {
    after: ['mode'],
    recipe: function recipe() {
      if (this.xAxisModes.indexOf(this.mode) >= 0) {
        return this.paddingRecipe();
      } else {
        return 0;
      }
    }
  },
  // Label formatting
  // ----------------
  measure: {
    recipe: function recipe(data) {
      return data.measure;
    }
  },
  // Full number without suffix
  formatLabel: {
    after: ['dataExtent'],
    recipe: function recipe() {
      return numberFormatter.labelFormatter(this.dataExtent, false, true);
    }
  }
}; // Layers
// ------

/**
 * @type {import('../types/types').LayerOptions<
 * RawChartData, LocationWithValues, BarPointChart
 * >}
 */

BarPointChart.prototype.locationsLayerConfig = {
  dataBind: function dataBind(data) {
    return this.selectAll(selector(ITEM_CLASS)).data(data.filteredLocationsWithValues, idKey);
  },
  insert: function insert() {
    return this.append('g').attr('class', ITEM_CLASS);
  },
  events: {
    enter: function enter() {
      // Bar
      this.append('rect').attr('class', BAR_CLASS) // Bar: Accessible description
      .append('desc').attr('class', BAR_DESC_CLASS); // Point

      this.append('circle').attr('class', POINT_CLASS) // Point: Accessible description
      .append('desc').attr('class', POINT_DESC_CLASS); // Point hover helper

      this.append('circle').attr('class', POINT_HOVER_HELPER_CLASS);
    },
    merge: function merge() {
      var chart = this.chart();
      this.order(); // Add the location id as an attribute

      this.attr({
        'data-id': idKey,
        transform: function transform(locationWithValues) {
          return "translate(".concat(chart.x(locationWithValues.id), ", 0)");
        }
      }).each(function (locationWithValues) {
        chart.updateHighlight(this, locationWithValues);
      }); // Bar

      this.select(selector(BAR_CLASS)).attr({
        x: 0,
        y: function y(locationWithValues) {
          return chart.y(Math.max(0, secondValueSelector(locationWithValues)));
        },
        width: chart.x.rangeBand(),
        height: function height(locationWithValues) {
          return Math.abs(chart.y(secondValueSelector(locationWithValues)) - chart.y(0));
        }
      }).each(function (locationWithValues) {
        chart.updateTooltip(this, secondDSelector(locationWithValues));
      }); // Point

      this.select(selector(POINT_CLASS)).attr({
        cx: chart.x.rangeBand() / 2,
        cy: function cy(locationWithValues) {
          return chart.y(singleValueSelector(locationWithValues));
        },
        r: POINT_RADIUS_MAP[chart.mode]
      }); // Point hover helper

      this.select(selector(POINT_HOVER_HELPER_CLASS)).attr({
        cx: chart.x.rangeBand() / 2,
        cy: function cy(locationWithValues) {
          return chart.y(singleValueSelector(locationWithValues));
        },
        r: POINT_HOVER_HELPER_RADIUS
      }).each(function (locationWithValues) {
        chart.updateTooltip(this, singleDSelector(locationWithValues));
      }); // Bar and point desc

      this.select(selector(POINT_DESC_CLASS)).text(function (locationWithValues) {
        return chart.desc(singleDSelector(locationWithValues));
      });
      this.select(selector(BAR_DESC_CLASS)).text(function (locationWithValues) {
        return chart.desc(secondDSelector(locationWithValues));
      });
    },
    exit: function exit() {
      var chart = this.chart(); // Remove tooltips

      this.select(selector(BAR_CLASS)).each(function () {
        chart.removeTooltip(this);
      });
      this.select(selector(POINT_HOVER_HELPER_CLASS)).each(function () {
        chart.removeTooltip(this);
      });
      this.remove();
    }
  }
};
BarPointChart.prototype.itemClass = ITEM_CLASS;
BarPointChart.prototype.boundMethods = ['tooltipContent'];
module.exports = BarPointChart;

},{"../i18n":82,"../util/chart":119,"../util/number-formatter":135,"./chart-labels":44,"./location-labels":54,"./padded-chart":58,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/slicedToArray":20,"d3":27,"lodash":"lodash"}],40:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var d3 = require('d3');

require('../vendor/d3.chart/layer-extensions');

require('../vendor/d3.chart/chart-extensions');

var objectUtil = require('../util/object');

var linearize = require('../util/linearize');

var disposal = require('../util/disposal');

var methodBinding = require('../util/method-binding');
/** @typedef {import('../models/chart-data')} ChartData */

/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').Layers} Layers */

/** @typedef {import('../types/types').Layer} Layer */

/** @typedef {import('../types/types').LayerOptions} LayerOptions */

/** @typedef {import('../types/types').Dependent} Dependent */

/** @typedef {import('../types/types').Dependents} Dependents */
// Base chart with a model, dependents, layers and attached charts.
//
// Based on d3.chart:
// https://github.com/misoproject/d3.chart/blob/master/src/chart.js
// License: MIT license https://github.com/misoproject/d3.chart/blob/master/LICENSE-MIT
// Copyright (c) 2014 Irene Ros & Mike Pennisi
//
// This is class does not simply extend d3.chart because we cant properly hook
// into the constructor when using ES6 classes. We need to create the dependents
// before the initialize methods are called.
//
// Instead of d3.charts initCascade, were using standard super calls
// in the initialize method of derived classes. For example:
// initialize(options) {
//   super.initialize(options);
//   // 
// }

/**
 * @template Data
 */


var BaseChart = /*#__PURE__*/function () {
  // Property declarations
  // ---------------------
  //
  // base: D3 selection
  // _layers: Object
  // _attached: Object
  // _dependents: Object
  // model: Backbone.Model

  /**
   * @param {d3.Selection<Data>} selection
   * @param {{ model: ChartData }} options
   */
  function BaseChart(selection, options) {
    (0, _classCallCheck2.default)(this, BaseChart);
    this.base = selection;
    /** @type {Layers} */

    this._layers = {};
    /** @type {{ [key: string]: BaseChart }}} */

    this._attached = {};
    /** @type {Dependents} */

    this._dependents;
    /** @type {Dependents} */

    this.dependents; // Dependents

    /** @type {number} */

    this.width;
    /** @type {number} */

    this.height;
    /** @type {number} */

    this.rawWidth;
    /** @type {number} */

    this.rawHeight;
    /** @type {string} */

    this.mode;
    this.model = options.model;
    this.bindMethods();
    this.createDependents();
    this.initialize(options);
  }
  /**
   * Initializes the chart. Empty per default.
   * In a derived class, use:
   * `initialize(options) { super.initialize(options);  }`
   *
   * @param {{ model: ChartData }} options
   */
  // eslint-disable-next-line no-unused-vars


  (0, _createClass2.default)(BaseChart, [{
    key: "initialize",
    value: function initialize(options) {} // DOM
    // ---
    // Returns the container element of the base element.
    // Returns an element.

  }, {
    key: "container",
    value: function container() {
      return this.base.node().parentNode;
    } // Returns the container element of the base element.
    // Returns a D3 Selection.

  }, {
    key: "$container",
    value: function $container() {
      return d3.select(this.container());
    } // Applies the width and height to the base element.

  }, {
    key: "setBaseSize",
    value: function setBaseSize() {
      var width = this.model.get('width');
      var height = this.model.get('height');
      var base = this.base;

      if (this.isSVG()) {
        // SVG
        base.attr({
          width: width,
          height: height
        });
      } else {
        // HTML
        base.style({
          width: "".concat(width, "px"),
          height: "".concat(height, "px")
        });
      }
    } // Returns whether the base element is an SVG element.

  }, {
    key: "isSVG",
    value: function isSVG() {
      var node = this.base.node();
      return node.namespaceURI === 'http://www.w3.org/2000/svg' || node.tagName.toLowerCase() === 'svg';
    } // Dependents
    // ----------

  }, {
    key: "createDependents",
    value: function createDependents() {
      this._dependents = {};
      /** @type {Dependents} */

      var dependents = objectUtil.getMergedVersion(this, 'dependents');

      for (var name in dependents) {
        var config = dependents[name];
        this.dependent(name, config);
      }
    }
    /**
     * Linearize dependencies and re-compute them
     *
     * @param {Data} data
     */

  }, {
    key: "updateDependents",
    value: function updateDependents(data) {
      var ordering = linearize(this._dependents);

      for (var i = 0, l = ordering.length; i < l; i++) {
        var name = ordering[i];
        var dependent = this._dependents[name];
        this[name] = dependent.recipe.call(this, data, this[name]);
      }
    }
    /**
     * Applies the dependents. Empty per default
     *
     * @param {Data} _data
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "applyDependents",
    value: function applyDependents(_data) {}
    /**
     * Register a property that is dependent on incoming data.
     *
     * Property values defined through register will be kept up to date
     * automatically as data changes.
     *
     * `recipe` will be called with the new data as first, and the prior value as
     * second parameter, its return value will be used as the new value:
     *
     *     (data, prior) ->
     *       # update or replace prior based on data
     *       return newValue
     *
     * `initial` is an optional first value.
     *
     * @param {string} name
     * @param {Dependent?} options
     */

  }, {
    key: "dependent",
    value: function dependent(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var initial = options.initial,
          recipe = options.recipe;
      var after = options.after || [];

      if (typeof recipe !== 'function') {
        throw new TypeError("Expecting `recipe` for ".concat(name, " to be a function."));
      }

      if (!_.isArray(after)) {
        throw new TypeError("Expecting `after` for ".concat(name, " to be an array."));
      }

      if (name in this) {
        throw new TypeError("Class already has a member ".concat(name, "."));
      }

      if (typeof initial === 'function') {
        this[name] = initial.call(this);
      } else {
        this[name] = initial;
      }

      this._dependents[name] = {
        recipe: recipe,
        after: after
      };
    } // Layers
    // ------

    /**
     * Override the d3.chart method to allow non-data-bound layers
     *
     * @param {string} name
     * @param {d3.Selection} selection
     * @param {LayerOptions} [options]
     */

  }, {
    key: "layer",
    value: function layer(name, selection) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!options.dataBind && !options.insert && options.draw) {
        // Non-data-bound layers
        // Like d3.chart, extend the selection and save it in this._layers
        selection.chart = function () {
          return _this;
        };

        selection.draw = function (data) {
          return options.draw.call(selection, data);
        };

        selection.modes = options.modes || null;
        this._layers[name] = selection;
        return selection;
      } else {
        // Data-bound layers
        // Original d3.chart code
        // https://github.com/misoproject/d3.chart/blob/master/src/chart.js#L171
        if (arguments.length === 1) {
          return this._layers[name];
        } // we are reattaching a previous layer, which the
        // selection argument is now set to.


        if (arguments.length === 2) {
          if (typeof selection.draw === 'function') {
            selection._chart = this;
            this._layers[name] = selection;
            return this._layers[name];
          } else {
            throw new Error('When reattaching a layer, the second argument must be a d3.chart layer');
          }
        }
        /** @type {Layer} */


        var layer = selection.layer(options);
        this._layers[name] = layer;
        selection._chart = this;
        return layer;
      }
    } // Attachments
    // -----------

    /**
     * @param {string} attachmentName
     * @param {BaseChart} chart
     * @returns {BaseChart}
     */

  }, {
    key: "attach",
    value: function attach(attachmentName, chart) {
      if (arguments.length === 1) {
        return this._attached[attachmentName];
      }

      this._attached[attachmentName] = chart;
      return chart;
    } // Transformation
    // --------------

    /**
     * @param {Data} data
     */

  }, {
    key: "transform",
    value: function transform(data) {
      return data;
    } // Drawing
    // -------

    /**
     * @param {Data} data
     */

  }, {
    key: "draw",
    value: function draw(data) {
      // Set the base size before updating the dependents because they might
      // force a layout + paint by getting the dimensions of an element.
      this.setBaseSize();
      var transformedData = this.transform(data);
      this.updateDependents(transformedData);
      this.applyDependents(transformedData);
      this.drawLayers(transformedData);
      this.drawAttached(transformedData);
      return this;
    }
    /**
     * Layers may have a `modes` property to specify in which modes
     * the layer is visible.
     * Similar to Irene Ros d3.chart.base
     * https://github.com/iros/d3.chart.base/blob/master/src/base.js#L98-L147
     *
     * @param {Data} data
     */

  }, {
    key: "drawLayers",
    value: function drawLayers(data) {
      var mode = this.mode;

      if (mode) {
        for (var name in this._layers) {
          var layer = this._layers[name];

          if (!layer.modes || layer.modes.indexOf(mode) >= 0) {
            // Show and draw the layer
            layer.style('display', '').draw(data);
          } else {
            // Hide and empty the layer
            layer.style('display', 'none').html('');
          }
        }
      }
    } // Draw attached charts. Works the same as in d3.chart,
    // its just in a separate method.
    // https://github.com/misoproject/d3.chart/blob/v0.3.0/src/chart.js#L265-L272

  }, {
    key: "drawAttached",
    value: function drawAttached(data) {
      for (var name in this._attached) {
        var attachment = this._attached[name];
        var attachmentData = this.demux(name, data);
        attachment.draw(attachmentData);
      }
    } // Demux the data for attached charts

  }, {
    key: "demux",
    value: function demux(name, data) {
      if (name === 'labels') {
        return this.demuxDataForLabels(data);
      } else {
        return data;
      }
    } // For the labels, augment data with dependents

  }, {
    key: "demuxDataForLabels",
    value: function demuxDataForLabels(data) {
      return _.create(data, {
        width: this.width,
        height: this.height
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      this.disposed = true;
      this.base.remove(); // Remove listeners from the model

      this.model.off(null, null, this); // Dispose all attached charts

      for (var name in this._attached) {
        var attachment = this._attached[name];

        if (typeof attachment.dispose === 'function') {
          attachment.dispose();
        }
      }

      disposal.disposeProperties(this);
    }
  }]);
  return BaseChart;
}(); // Method binding
// -------------


_.assign(BaseChart.prototype, methodBinding);

BaseChart.prototype.boundMethods = []; // Dependents
// ----------

BaseChart.prototype.dependents = {
  // Shortcuts for accessing model properties
  // Integer width
  width: {
    recipe: function recipe() {
      return this.model.get('width');
    }
  },
  // Integer height
  height: {
    recipe: function recipe() {
      return this.model.get('height');
    }
  },
  // Float width
  rawWidth: {
    recipe: function recipe() {
      return this.model.get('rawWidth');
    }
  },
  // Float height
  rawHeight: {
    recipe: function recipe() {
      return this.model.get('rawHeight');
    }
  },
  mode: {
    recipe: function recipe() {
      return this.model.get('mode');
    }
  }
}; // Data transformation

BaseChart.prototype.transform = _.identity; // Disposal
// --------

BaseChart.prototype.disposed = false;
BaseChart.prototype.disposedProperties = ['base', 'model'];
module.exports = BaseChart;

},{"../util/disposal":123,"../util/linearize":129,"../util/method-binding":134,"../util/object":136,"../vendor/d3.chart/chart-extensions":145,"../vendor/d3.chart/layer-extensions":146,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"d3":27,"lodash":"lodash"}],41:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var Hammer = require('../vendor/hammer-2.0.4.js');

var I18n = require('../i18n');

var FREQUENCIES = require('../constants/frequencies');

var _require = require('../util/chart'),
    extent = _require.extent,
    hasValue = _require.hasValue,
    idKey = _require.idKey,
    latestDataPoint = _require.latestDataPoint,
    selector = _require.selector;

var numberFormatter = require('../util/number-formatter');

var timePeriodNavigation = require('../models/time-period-navigation');

var PaddedChart = require('./padded-chart');

var tooltipTemplates = require('./tooltip-templates');

var timePeriodKey = function timePeriodKey(d) {
  return d.timePeriod;
};
/** @typedef {import('../types/types').ChartMode} ChartMode */

/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').IdAndName} IdAndName */

/** @typedef {import('../types/types').DataPoint} DataPoint */

/** @typedef {import('../types/types').LocationWithValues} LocationWithValues */

/** @typedef {{ dataPoint: DataPoint, direction: 'up' | 'down' }} TurningPoint */

/** @typedef {LocationWithValues & {
 * latestValue?: DataPoint,
 * turningPoints: TurningPoint[],
 * }} LineChartDatum */

/** @typedef {LineChartDatum[]} LineChartData */
// Constants
// ---------


var NAVIGATION_STEPS = 2;
/**
 * Show background locations (non-highlighted, non-baseline) in these modes
 *
 * @type {ChartMode[]}
 */

var BACKGROUND_MODES = ['reduced', 'normal', 'big', 'large']; // Minimum label width. Used to calculate whether labels are shown.

var MIN_LABEL_WIDTH = 30;
var TURNING_POINT_DOWN = 'down';
var TURNING_POINT_UP = 'up';
/** @type {{ [key: ChartMode]: number }} */

var TURNING_POINT_MARKER_HEIGHTS = {
  small: 5,
  reduced: 6,
  normal: 8,
  big: 9,
  large: 10
}; // TODO: Use the real observation status id

var TURNING_POINT_STATUS_ID = 'TP'; // Classes
// -------

var CLASS_NAME = 'line-chart';
var LINE_GROUP_CLASS = 'line-group';
var LINE_ANNOTATION_TARGET_CLASS = 'line-annotation-target';
var LINE_CLASS = 'line';
var LINE_DESC_CLASS = 'line-desc';
var LINE_INTERPOLATOR_CLASS = 'line-interpolator';
var LINE_HOVER_HELPER_CLASS = 'line-hover-helper';
var MARKERS_CLASS = 'markers';
var MARKER_DOT_CLASS = 'marker-dot';
var MARKER_DOT_DESC_CLASS = 'marker-dot-desc';
var MARKER_LABEL_CLASS = 'marker-label';
var TURNING_POINT_MARKER_CLASS = 'turning-point-marker'; // The class of the element that represents a datum

var ITEM_CLASS = LINE_GROUP_CLASS; // Base class of different line charts

var BaseLineChart = /*#__PURE__*/function (_PaddedChart) {
  (0, _inherits2.default)(BaseLineChart, _PaddedChart);

  var _super = _createSuper(BaseLineChart);

  function BaseLineChart(selection, options) {
    var _this;

    (0, _classCallCheck2.default)(this, BaseLineChart);
    _this = _super.call(this, selection, options);
    /** @type {LineChartData} */

    _this.visibleLocationsWithValues;
    return _this;
  }

  (0, _createClass2.default)(BaseLineChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(BaseLineChart.prototype), "initialize", this).call(this, options);
      this.base.classed(CLASS_NAME, true);
      this.createLineGenerator();
    }
  }, {
    key: "createLineGenerator",
    value: function createLineGenerator() {
      var _this2 = this;

      this.lineGenerator = d3.svg.line().defined(hasValue).x(function (d) {
        return _this2.x(d.date);
      }).y(function (d) {
        return _this2.y(d.value);
      });
    } // Interaction
    // -----------

  }, {
    key: "initInteraction",
    value: function initInteraction() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(BaseLineChart.prototype), "initInteraction", this).call(this);
      var h = this.hammerManager;
      h.add(new Hammer.Swipe({
        direction: Hammer.DIRECTION_HORIZONTAL
      }));
      h.on('swipeleft swiperight', _.debounce(this.touchNavigation, 300, {
        leading: true,
        trailing: false
      }));
    }
  }, {
    key: "touchNavigation",
    value: function touchNavigation(event) {
      switch (event.type) {
        case 'swipeleft':
          timePeriodNavigation.forward(this.model, NAVIGATION_STEPS);
          break;

        case 'swiperight':
          timePeriodNavigation.back(this.model, NAVIGATION_STEPS);
          break;
      }
    } // Location and label visibility
    // -----------------------------
    // For a given location id, returns whether it is visible.
    // Requires the dependent backgroundLocationsVisible.

  }, {
    key: "isVisible",
    value: function isVisible(id) {
      return this.backgroundLocationsVisible || this.isForegroundLocation(id);
    } // Z-index Sorting
    // ---------------

    /**
     * Sorting function that ensures the highlighted locations and
     * the baseline comparison come first
     *
     * @param {IdAndName} a
     * @param {IdAndName} b
     */

  }, {
    key: "highlightSorter",
    value: function highlightSorter(a, b) {
      var highlightedLocations = this.model.get('highlightedLocations');
      var aNum = highlightedLocations.indexOf(a.id);
      var bNum = highlightedLocations.indexOf(b.id);

      if (aNum === -1 && bNum === -1) {
        return this.baselineSorter(a, b);
      }

      if (aNum < bNum) {
        return -1;
      } else if (aNum === bNum) {
        return 0;
      } else {
        return 1;
      }
    } // Sorting function that ensures the baseline comparison comes first

  }, {
    key: "baselineSorter",
    value: function baselineSorter(a, b) {
      var baseline = this.model.get('baselineComparison');

      if (a.id === baseline) {
        return 1;
      } else if (b.id === baseline) {
        return -1;
      } else {
        return 0;
      }
    } // Lines paths
    // -----------

    /**
     * @param {LineChartDatum} d
     */

  }, {
    key: "linePath",
    value: function linePath(d) {
      return this.lineGenerator(d.values);
    }
    /**
     * @param {LineChartDatum} d
     */

  }, {
    key: "hoverHelperPath",
    value: function hoverHelperPath(d) {
      var values = d.values;
      var path = '';

      for (var i = 0, l = values.length; i < l; i++) {
        var record = values[i];

        if (!hasValue(record)) {
          continue;
        }

        var command = path.length ? 'L' : 'M';
        path += "".concat(command, " ").concat(this.x(record.date), " ").concat(this.y(record.value));
      }

      return path || 'M 0 0';
    }
    /**
     * @param {LineChartDatum} d
     */

  }, {
    key: "dashedLinePath",
    value: function dashedLinePath(d) {
      var values = d.values;
      var segments = [];
      var segment = null;
      var onLine = false;

      for (var index = 0; index < values.length; index++) {
        // If current record has no defined value, take note that we are
        // not on a line and skip ahead.
        var record = values[index];

        if (!hasValue(record)) {
          onLine = false;
          continue;
        } // Now the current record has a defined value.
        // If we were not on a line, close a potentially open segment


        if (!onLine && segment != null) {
          segment += " L ".concat(this.x(record.date), " ").concat(this.y(record.value));
          segments.push(segment);
          segment = null;
        } // If the next record has no defined value, open a new segment


        var nextRecord = values[index + 1];

        if (nextRecord != null && !hasValue(nextRecord)) {
          segment = "M ".concat(this.x(record.date), " ").concat(this.y(record.value));
        } // Take note that we were on a line of defined points


        onLine = true;
      } // Join segments to path or return empty path


      return segments.join(' ') || 'M 0 0';
    } // Line tooltips and annotations
    // -----------------------------

    /**
     * Creates or updates the tooltip for the line hover helper
     *
     * @param {Element} lineHoverHelper
     * @param {LineChartDatum} d
     */

  }, {
    key: "addLineTooltip",
    value: function addLineTooltip(lineHoverHelper, d) {
      this.addTooltip({
        target: lineHoverHelper,
        render: this.lineTooltipContent,
        d: d
      });
    }
    /**
     * @param {Element} lineAnnotationTarget
     * @param {LineChartDatum} d
     */

  }, {
    key: "toggleLineAnnotation",
    value: function toggleLineAnnotation(lineAnnotationTarget, d) {
      if (d.latestValue) {
        this.toggleAnnotation({
          target: lineAnnotationTarget,
          render: this.lineAnnotationContent,
          d: d.latestValue
        });
      } else {
        this.removeAnnotation(lineAnnotationTarget);
      }
    } // Markers (dots and labels)
    // -------------------------

    /**
     * @param {Element} lineGroup
     * @param {DataPoint[]} values
     * @param {TurningPoint[]} turningPoints
     */

  }, {
    key: "createOrUpdateMarkers",
    value: function createOrUpdateMarkers(lineGroup, values, turningPoints) {
      var markerGroup = d3.select(lineGroup).select(selector(MARKERS_CLASS));
      this.createOrUpdateMarkerDots(markerGroup, values);
      this.createOrUpdateMarkerLabels(markerGroup, values, turningPoints);
    } // Marker dots
    // -----------

    /**
     * @param {d3.Selection} markerGroup
     * @param {DataPoint[]} values
     */

  }, {
    key: "createOrUpdateMarkerDots",
    value: function createOrUpdateMarkerDots(markerGroup, values) {
      var chart = this; // Find all elements

      var markerDots = markerGroup.selectAll(selector(MARKER_DOT_CLASS)); // Remove all elements and break if there is not enough space.

      if (!this.markerDotsVisible) {
        this.removeSelectionWithTooltips(markerDots);
        return;
      } // Bind the selection to the data


      var boundMarkerDots = markerDots.data(values, timePeriodKey); // Enter

      boundMarkerDots.enter().append('circle').attr('class', MARKER_DOT_CLASS) // Accessible description
      .append('desc').attr('class', MARKER_DOT_DESC_CLASS); // Merge

      boundMarkerDots.attr({
        cx: function cx(d) {
          return chart.x(d.date);
        },
        cy: function cy(d) {
          return chart.y(d.value);
        },
        r: chart.markerDotRadius
      }) // Tooltip
      .each(function (d) {
        chart.addMarkerDotTooltip(this, d);
      }) // Accessible description
      .select(selector(MARKER_DOT_DESC_CLASS)).text(function (d) {
        var timePeriod = d.timePeriodName;
        var value = chart.formatLabel(d.value);
        var measure = chart.measure.name;
        return "".concat(d.name, ", ").concat(timePeriod, ": ").concat(value, " ").concat(measure);
      }); // Exit

      this.removeSelectionWithTooltips(boundMarkerDots.exit());
    } // Marker dot tooltips
    // -------------------

    /**
     * @param {Element} markerDot
     * @param {DataPoint} d
     */

  }, {
    key: "addMarkerDotTooltip",
    value: function addMarkerDotTooltip(markerDot, d) {
      this.addTooltip({
        target: markerDot,
        render: this.markerTooltipContent,
        d: d
      });
    } // Marker labels
    // -------------

    /**
     * @param {d3.Selection} markerGroup
     * @param {DataPoint[]} values
     * @param {TurningPoint[]} turningPoints
     */

  }, {
    key: "createOrUpdateMarkerLabels",
    value: function createOrUpdateMarkerLabels(markerGroup, values, turningPoints) {
      var chart = this; // Find all elements

      var markerLabels = markerGroup.selectAll(selector(MARKER_LABEL_CLASS)); // Remove all elements and break if there is not enough space.

      if (chart.labelDisplay === 'none') {
        markerLabels.remove();
        return;
      } // Bind the selection to the data


      var boundMarkerLabels = markerLabels.data(values, timePeriodKey); // Enter

      boundMarkerLabels.enter().append('text').attr('class', MARKER_LABEL_CLASS) // Hide the label for screen readers since
      // there is an accessible `desc` fallback at the marker dot
      .attr('aria-hidden', 'true'); // Merge

      boundMarkerLabels.style('display', chart.labelDisplay).attr('x', function (d) {
        return chart.x(d.date);
      }).attr('y', function (d) {
        var isTurningPointDown = turningPoints.some(function (_ref) {
          var dataPoint = _ref.dataPoint,
              direction = _ref.direction;
          return d === dataPoint && direction == TURNING_POINT_DOWN;
        });
        return chart.y(d.value) + (isTurningPointDown ? 17 : -9);
      }).text(function (d) {
        return chart.formatLabelSuffixed(d.value);
      }); // Exit

      boundMarkerLabels.exit().remove();
    } // Turning point markers
    // ---------------------

    /**
     * @param {Element} markerGroup
     * @param {TurningPoint[]} turningPoints
     */

  }, {
    key: "createOrUpdateTurningPointMarkers",
    value: function createOrUpdateTurningPointMarkers(markerGroup, turningPoints) {
      var chart = this; // Find all elements

      var turningPointMarkers = d3.select(markerGroup).selectAll(selector(TURNING_POINT_MARKER_CLASS)); // Remove all elements and break if there is not enough space.

      if (!this.turningPointMarkersVisible) {
        chart.removeSelectionWithTooltips(turningPointMarkers);
        return;
      } // Bind the selection to the data


      var boundTurningPointMarkers = turningPointMarkers.data(turningPoints, timePeriodKey); // Enter

      boundTurningPointMarkers.enter().append('path').classed(TURNING_POINT_MARKER_CLASS, true);
      var h = TURNING_POINT_MARKER_HEIGHTS[chart.mode];
      var h2 = h / 2; // Merge

      boundTurningPointMarkers.attr({
        transform: function transform(_ref2) {
          var dataPoint = _ref2.dataPoint,
              direction = _ref2.direction;
          var isUp = direction == TURNING_POINT_UP;
          var x = chart.x(dataPoint.date) - h2;
          var y = chart.y(dataPoint.value) + (isUp ? h : -2 * h);
          return "translate(".concat(x, " ").concat(y, ")");
        },
        d: function d(_ref3) {
          var direction = _ref3.direction;
          return direction == TURNING_POINT_UP ? "M 0,".concat(h, " L ").concat(h2, ",0 L ").concat(h, ",").concat(h, " Z") : "M 0,0 L ".concat(h, ",0 L ").concat(h2, ",").concat(h, " Z");
        }
      }).each(function (d) {
        chart.addTurningPointMarkerTooltip(this, d);
      }); // Exit

      this.removeSelectionWithTooltips(boundTurningPointMarkers.exit());
    } // Turning point markers tooltips
    // ------------------------------

    /**
     * Creates or updates the tooltip for the turning point marker
     *
     * @param {SVGPathElement} path
     * @param {LineChartDatum} d
     */

  }, {
    key: "addTurningPointMarkerTooltip",
    value: function addTurningPointMarkerTooltip(path, d) {
      this.addTooltip({
        target: path,
        render: this.turningPointMarkerTooltipContent,
        d: d
      });
    }
    /**
     * Removes all elements in the given selection, removes tooltips correctly
     *
     * @param {d3.Selection} selection
     */

  }, {
    key: "removeSelectionWithTooltips",
    value: function removeSelectionWithTooltips(selection) {
      var chart = this;
      selection.each(function () {
        chart.removeTooltip(this);
      });
      selection.remove();
    } // Tooltip content
    // ---------------
    // Line tooltip
    // ------------

    /**
     * @param {DataPoint} d
     */

  }, {
    key: "lineTooltipContent",
    value: function lineTooltipContent(d) {
      return tooltipTemplates.location.render(this.lineTooltipData(d));
    }
    /**
     * @param {DataPoint} d
     */

  }, {
    key: "lineTooltipData",
    value: function lineTooltipData(d) {
      return {
        location: d.name
      };
    } // Marker tooltip
    // --------------

    /**
     * @param {DataPoint} d
     */

  }, {
    key: "markerTooltipContent",
    value: function markerTooltipContent(d) {
      return tooltipTemplates.full.render(this.markerTooltipData(d));
    }
    /**
     * @param {DataPoint} d
     */

  }, {
    key: "markerTooltipData",
    value: function markerTooltipData(d) {
      /** @type {{ abbr: string, description: string } | null} */
      var obsInfo = d.status ? I18n.t('observationStatus')[d.status.id] : null;
      return {
        location: d.name,
        timePeriod: d.timePeriodName,
        value: this.formatLabel(d.value),
        measure: this.measure.name,
        observationStatusAbbr: obsInfo ? obsInfo.abbr : null,
        observationStatusDescription: obsInfo ? obsInfo.description : null
      };
    } // Line annotation
    // ---------------

    /**
     * @param {DataPoint} d
     */

  }, {
    key: "lineAnnotationContent",
    value: function lineAnnotationContent(d) {
      return tooltipTemplates.location.render(this.lineAnnotationData(d));
    }
    /**
     * @param {DataPoint} d
     */

  }, {
    key: "lineAnnotationData",
    value: function lineAnnotationData(d) {
      return {
        location: d.name
      };
    } // Turning point marker tooltip
    // ----------------------------

    /**
     * @param {DataPoint} d
     */

  }, {
    key: "turningPointMarkerTooltipContent",
    value: function turningPointMarkerTooltipContent(d) {
      return tooltipTemplates.turningPoint.render(this.turningPointMarkerTooltipData(d));
    }
    /**
     * @param {DataPoint} d
     */

  }, {
    key: "turningPointMarkerTooltipData",
    value: function turningPointMarkerTooltipData(d) {
      return {
        label: I18n.t('chart.turningPointLabel'),
        location: d.name,
        timePeriod: d.timePeriodName
      };
    }
  }]);
  return BaseLineChart;
}(PaddedChart); // Class properties
// ----------------
// Make class constants public


BaseLineChart.LINE_HOVER_HELPER_CLASS = LINE_HOVER_HELPER_CLASS;
BaseLineChart.MARKER_DOT_CLASS = MARKER_DOT_CLASS;
BaseLineChart.LINE_ANNOTATION_TARGET_CLASS = LINE_ANNOTATION_TARGET_CLASS; // Method binding
// --------------

BaseLineChart.prototype.boundMethods = ['touchNavigation', 'highlightSorter', 'linePath', 'hoverHelperPath', 'dashedLinePath', 'lineTooltipContent', 'markerTooltipContent', 'lineAnnotationContent', 'turningPointMarkerTooltipContent']; // Instance properties
// -------------------
// Make classes public so derived classes may access them

BaseLineChart.prototype.itemClass = ITEM_CLASS;
BaseLineChart.prototype.xAxisTickSize = 5; // Padding configuration
// ---------------------

var xPaddingRecipe = function xPaddingRecipe(side) {
  return (
    /**
     * @this {BaseLineChart}
     * @param {RawChartData} data */
    function (data) {
      if (data.timePeriods.length === 2) {
        // Two time periods: Slope chart
        return this.width * 0.25;
      } else if (side === 'left') {
        return this.paddingLeftRecipe();
      } else {
        return this.paddingRecipe();
      }
    }
  );
};
/** @this {BaseLineChart} */


var paddingBottomRecipe = function paddingBottomRecipe() {
  if (this.xAxisModes.indexOf(this.mode) >= 0) {
    return this.xAxisTickSize + 2;
  } else {
    return 5;
  }
};
/** @type {import('../types/types').Dependents<RawChartData, BaseLineChart>} */


BaseLineChart.prototype.dependents = {
  // Augmented visible locations
  visibleLocationsWithValues: {
    after: ['backgroundLocationsVisible'],
    recipe: function recipe(data) {
      var _this3 = this;

      var locations = data.filteredLocationsWithValues.filter(function (locationWithValues) {
        return _this3.isVisible(locationWithValues.id);
      }).map(function (locationWithValues) {
        /** @type {LineChartDatum} */
        var datum = _.create(locationWithValues); // For the line annotatin, augment the datum with the latest value
        // (might be undefined)


        datum.latestValue = latestDataPoint(locationWithValues.values, true); // Find turning points

        datum.turningPoints = [];
        datum.values.forEach(function (dataPoint, index) {
          var isTurningPoint = dataPoint.status !== null && dataPoint.status.id === TURNING_POINT_STATUS_ID;

          if (isTurningPoint) {
            var nextDataPoint = datum.values[index + 1];

            if (nextDataPoint) {
              var direction = nextDataPoint.value < dataPoint.value ? TURNING_POINT_DOWN : TURNING_POINT_UP;
              /** @type {TurningPoint} */

              var turningPoint = {
                dataPoint: dataPoint,
                direction: direction
              };
              datum.turningPoints.push(turningPoint);
            }
          }
        });
        return datum;
      });
      return locations;
    }
  },
  // The extent of the visualized data as [min: Number, max: Number]
  dataExtent: {
    after: ['visibleLocationsWithValues'],
    recipe: function recipe() {
      return extent(this.visibleLocationsWithValues);
    }
  },
  // Scales
  // ------
  x: {
    after: ['plotWidth'],
    initial: function initial() {
      return d3.time.scale();
    },
    recipe: function recipe(data, scale) {
      return scale.range([0, this.plotWidth]).domain(d3.extent(data.timePeriods, function (timePeriod) {
        return timePeriod.date;
      }));
    }
  },
  y: {
    after: ['plotHeight', 'dataExtent'],
    initial: function initial() {
      return d3.scale.linear();
    },
    recipe: function recipe(data, scale) {
      return scale.range([this.plotHeight, 0]).domain(this.dataExtent);
    }
  },
  // Axes
  // ----
  xAxis: {
    after: ['x'],
    initial: function initial() {
      return d3.svg.axis().orient('bottom').tickSize(-this.xAxisTickSize, 0).tickPadding(8);
    },
    recipe: function recipe(data, axis) {
      return axis.scale(this.x) // Dont use more than 10 ticks
      .ticks(Math.min(10, data.timePeriods.length)).tickFormat(data.frequency.id === FREQUENCIES.QUARTERLY ? I18n.d3QuarterlyTimeFormatter : I18n.d3TimeFormatter);
    }
  },
  // Padding
  // -------
  paddingRight: {
    after: ['mode', 'width'],
    recipe: xPaddingRecipe('right')
  },
  paddingBottom: {
    after: ['mode'],
    recipe: paddingBottomRecipe
  },
  paddingLeft: {
    after: ['mode', 'width', 'yAxisWidth'],
    recipe: xPaddingRecipe('left')
  },
  // Label visibility
  // ----------------
  widthPerTimePeriod: {
    after: ['plotWidth'],
    recipe: function recipe(data) {
      return this.plotWidth / data.timePeriods.length;
    }
  },

  /** The CSS `display` value of the marker labels */
  labelDisplay: {
    after: ['widthPerTimePeriod'],
    recipe: function recipe() {
      if (this.widthPerTimePeriod < MIN_LABEL_WIDTH / 2) {
        // Hide all labels, they wont fit
        return 'none';
      } else if (this.widthPerTimePeriod < MIN_LABEL_WIDTH) {
        // Show every second label
        return function (data, index) {
          if (index % 2 === 0) {
            return 'none';
          } else {
            return '';
          }
        };
      } else {
        // Apply default styles (show labels on hover and in larger modes)
        return '';
      }
    }
  },
  // Visibility
  // ----------
  backgroundLocationsVisible: {
    after: ['mode'],
    recipe: function recipe() {
      return BACKGROUND_MODES.indexOf(this.mode) >= 0;
    }
  },
  markerDotRadius: {
    after: ['mode'],
    recipe: function recipe() {
      switch (this.mode) {
        case 'small':
          return 2.5;

        case 'reduced':
          return 3;

        case 'normal':
          return 3.5;

        case 'big':
          return 5;

        case 'large':
          return 6;

        default:
          return 3.5;
      }
    }
  },
  markerDotsVisible: {
    after: ['widthPerTimePeriod', 'markerDotRadius'],
    recipe: function recipe() {
      // Hide the marker dots if they would overlap
      if (this.widthPerTimePeriod < this.markerDotRadius * 2.5) {
        return false;
      } else {
        return true;
      }
    }
  },
  turningPointMarkersVisible: {
    after: ['markerDotsVisible'],
    recipe: function recipe() {
      // Turning points are visible when marker dots are visible
      return this.markerDotsVisible;
    }
  },
  // Number formatting
  // -----------------
  //
  // Show as many decimals as needed so each location has meaningful values.
  // In both cases (suffixed or not), the decimals are forced so the numbers
  // are consistent throughout the chart.
  // Full number without suffix for the tooltips
  formatLabel: {
    after: ['dataExtent'],
    recipe: function recipe(data) {
      return numberFormatter.extensiveLabelFormatter(data, this.dataExtent, false, true);
    }
  },
  // Short number with possible suffixes for the marker labels
  formatLabelSuffixed: {
    after: ['dataExtent'],
    recipe: function recipe(data) {
      return numberFormatter.extensiveLabelFormatter(data, this.dataExtent, true, true);
    }
  },
  // Measure shortcut
  // ----------------
  measure: {
    recipe: function recipe(data) {
      return data.measure;
    }
  }
}; // Layers
// ------

/** @type {import('../types/types').LayerOptions<RawChartData, LineChartDatum, BaseLineChart>} */

BaseLineChart.prototype.linesLayerConfig = {
  // Context: the layer base (g.line-groups element)
  // Returns: bound selection with g.line-group
  dataBind: function dataBind() {
    var chart = this.chart();
    return this.selectAll(selector(ITEM_CLASS)).data(chart.visibleLocationsWithValues, idKey);
  },
  // Context: Bound selection with g.line-group
  // Returns: Bound selection with g.line-group
  insert: function insert() {
    return this.append('g').attr('class', ITEM_CLASS);
  },
  events: {
    // Context: Entering selection with g.lineGroup
    enter: function enter() {
      // Transparent circle that sits on the end of the line and
      // serves as target for the annotation
      this.append('circle').attr('class', LINE_ANNOTATION_TARGET_CLASS); // First line: Main visible line

      this.append('path').attr('class', LINE_CLASS) // Accessible description
      .append('desc').attr('class', LINE_DESC_CLASS); // Second line: Dashed interpolator segments

      this.append('path').attr('class', LINE_INTERPOLATOR_CLASS); // Third line: Transparent hover helper for mouse/touch interaction
      // Draw a continuous line ignoring undefined values

      this.append('path').attr('class', LINE_HOVER_HELPER_CLASS); // Marker dots

      this.append('g').attr('class', MARKERS_CLASS);
    },
    // Context: Bound selection with g.line-group
    merge: function merge() {
      var chart = this.chart(); // Add the location id as an attribute to allow item event handling
      // (see InteractiveChart)

      this.attr('data-id', idKey); // Line annotation target

      this.select(selector(LINE_ANNOTATION_TARGET_CLASS)).attr('r', function () {
        return chart.markerDotsVisible ? chart.markerDotRadius : 3;
      }).attr('cx', function (d) {
        return d.latestValue ? chart.x(d.latestValue.date) : 0;
      }).attr('cy', function (d) {
        return d.latestValue ? chart.y(d.latestValue.value) : 0;
      }).each(function (d) {
        chart.toggleLineAnnotation(this, d);
      }); // Lines
      // -----
      // First line: Main visible line

      this.select(selector(LINE_CLASS)).attr('d', chart.linePath).classed('background-line', function (d) {
        return chart.isBackgroundLocation(d.id);
      }); // First line: Accessible description

      this.select(selector(LINE_DESC_CLASS)).text(function (d) {
        return d.name;
      }); // Second line: Dashed interpolator segments
      // through undefined data points

      this.select(selector(LINE_INTERPOLATOR_CLASS)).attr('d', chart.dashedLinePath); // Third line: Transparent hover helper for mouse/touch interaction

      this.select(selector(LINE_HOVER_HELPER_CLASS)).attr('d', chart.hoverHelperPath).each(function (d) {
        chart.addLineTooltip(this, d);
      });
      this.each(function (d) {
        // Highlight the line group
        chart.updateHighlight(this, d); // Markers for defined values

        var definedValues = d.values.filter(hasValue);
        chart.createOrUpdateMarkers(this, definedValues, d.turningPoints); // Turning points

        chart.createOrUpdateTurningPointMarkers(this, d.turningPoints);
      }); // Sorting so highlighted line groups have the highest z-index

      this.sort(chart.highlightSorter);
    },
    // Context: Exiting selection
    exit: function exit() {
      var chart = this.chart(); // Remove tooltips and annotation

      this.select(selector(LINE_ANNOTATION_TARGET_CLASS)).each(function () {
        chart.removeAnnotation(this);
      });
      this.select(selector(LINE_HOVER_HELPER_CLASS)).each(function () {
        chart.removeTooltip(this);
      });
      this.selectAll(selector(MARKER_DOT_CLASS)).each(function () {
        chart.removeTooltip(this);
      });
      this.remove();
    }
  }
};
module.exports = BaseLineChart;

},{"../constants/frequencies":72,"../i18n":82,"../models/time-period-navigation":114,"../util/chart":119,"../util/number-formatter":135,"../vendor/hammer-2.0.4.js":149,"./padded-chart":58,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"d3":27,"lodash":"lodash"}],42:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var I18n = require('../i18n');

var _require = require('../util/chart'),
    dValue = _require.dValue,
    idKey = _require.idKey;

var numberFormatter = require('../util/number-formatter');

var InteractiveChart = require('./interactive-chart');

var ChartLabels = require('./chart-labels');

var tooltipTemplates = require('./tooltip-templates');

var EQUAL_SCALES = ["M28.866 7.366h-8.676c0 1.683 1.941 3.048 4.338 3.048 2.396 0 4.339-1.365 4.339-3.048", "M9.164 7.366h-8.676c0 1.683 1.941 3.048 4.338 3.048 2.396 0 4.339-1.365 4.339-3.048", "M20.78 16.141l-4.726-.597-.729-9.341 9.366-.747.013-.851h-9.503l-.114-1.464h-.877l-.109 1.464h-9.456v.851l9.339.745-.694 9.341-4.75.6v1.057h12.269l-.029-1.058z"];
var INEQUAL_SCALES = ["M9.042 9.676h-8.676c0 1.683 1.941 3.048 4.338 3.048 2.396 0 4.339-1.365 4.339-3.048", "M28.744 4.072h-8.678c0 1.683 1.943 3.048 4.339 3.048 2.396 0 4.339-1.365 4.339-3.048", "M20.658 15.648l-4.728-.597-.739-9.498 8.896-4.046-.291-.799-8.735 3.179-.096-1.24h-.877l-.121 1.639-9.019 3.282.29.8 8.601-2.359-.671 9.039-4.75.6v1.057h12.269l-.029-1.057z"];

var BinChart = /*#__PURE__*/function (_InteractiveChart) {
  (0, _inherits2.default)(BinChart, _InteractiveChart);

  var _super = _createSuper(BinChart);

  function BinChart() {
    (0, _classCallCheck2.default)(this, BinChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(BinChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(BinChart.prototype), "initialize", this).call(this, options);
      this.base.classed('bin-chart', true);
      var labels = this.base.append('g').attr('class', 'chart-labels');
      this.attach('labels', new ChartLabels(labels, {
        model: this.model
      }));
      this.legend = this.base.append('g').classed('legend', true);
      this.drawScales();
      this.layer('legend', this.legend, this.legendLayerConfig);
      this.layer('bins', this.base.append('g').classed('bins', true), this.binsLayerConfig);
    }
  }, {
    key: "y",
    value: function y(size) {
      var binHeight = this.radius * (size * (2 + this.markerPad) - this.markerPad); // TODO [JE] Should use padding instead of calculating with 0.1,
      // but this requires refactoring of super not to define specific padding
      // defaults.

      return (this.innerHeight - binHeight) / 2;
    }
  }, {
    key: "drawScales",
    value: function drawScales() {
      var legend = this.legend;
      var measure = this.model.get('measure');
      var scalesEqual = legend.append('g').classed('scales-equal', true);

      for (var i = 0, l = EQUAL_SCALES.length; i < l; i++) {
        var path = EQUAL_SCALES[i];
        scalesEqual.append('path').attr('d', path);
      }

      legend.append('text').classed('legend-equal', true).text(I18n.t(['binChart', measure, 'equality']));
      var scalesInequal = legend.append('g').classed('scales-inequal', true);

      for (var _i = 0, _l = INEQUAL_SCALES.length; _i < _l; _i++) {
        var _path = INEQUAL_SCALES[_i];
        scalesInequal.append('path').attr('d', _path);
      }

      return legend.append('text').classed('legend-inequal', true).text(I18n.t(['binChart', measure, 'inequality']));
    } // Tooltips
    // --------

  }, {
    key: "tooltipContent",
    value: function tooltipContent(d) {
      var measureId = this.model.get('measure');
      return tooltipTemplates.full.render({
        location: d.name,
        timePeriod: d.date,
        value: this.formatLabel(d.value),
        measure: I18n.t(['binChart', measureId, 'label'])
      });
    }
  }]);
  return BinChart;
}(InteractiveChart); // Method binding
// --------------


BinChart.prototype.boundMethods = ['tooltipContent'];
BinChart.prototype.markerPad = 0.5;
BinChart.prototype.dependents = {
  bins: {
    initial: function initial() {
      return [];
    },
    recipe: function recipe(data) {
      var accessor = function accessor(d) {
        return d.value;
      };

      return d3.layout.histogram().bins(15).value(accessor)(data);
    }
  },
  minimum: {
    after: ['bins'],
    initial: 0,
    recipe: function recipe() {
      return (this.bins[0] != null ? this.bins[0].x : undefined) || 0;
    }
  },
  maximum: {
    after: ['bins'],
    initial: 1,
    recipe: function recipe() {
      var last = this.bins[this.bins.length - 1];

      if (last != null) {
        return last.x + last.dx;
      } else {
        return 1;
      }
    }
  },
  innerHeight: {
    after: ['height'],
    recipe: function recipe() {
      return Math.floor(this.height * 0.85);
    }
  },
  radius: {
    after: ['bins', 'innerHeight', 'x'],
    initial: 4,
    recipe: function recipe() {
      var _this = this;

      // Fit all items of the largest bin plus their bottom padding, but the
      // last item needs no bottom padding
      var maxBinSize = d3.max(this.bins, function (bin) {
        return bin.y;
      }) || 0;
      var fittings = maxBinSize * (2 + this.markerPad);
      var yMax = fittings >= 0 ? Math.floor(this.innerHeight / fittings) : 4; // We also need to make sure markers fit into bins horizontally

      var xMax = function () {
        if (_this.bins.length) {
          var binWidth = _this.x(_this.bins[0].x + _this.bins[0].dx) - _this.x(_this.bins[0].x);

          return Math.floor(binWidth / (2 + _this.markerPad));
        } else {
          return 4;
        }
      }();

      return Math.min(xMax, yMax);
    }
  },
  x: {
    after: ['width', 'minimum', 'maximum'],
    initial: function initial() {
      return d3.scale.linear();
    },
    recipe: function recipe(data, prior) {
      return prior.domain([0.95 * this.minimum, 1.05 * this.maximum]).range([0, this.width]);
    }
  },
  formatLabel: {
    recipe: function recipe(data) {
      var values = data.map(dValue);
      return numberFormatter.labelFormatter(values);
    }
  }
}; // Layers
// ------

BinChart.prototype.legendLayerConfig = {
  draw: function draw() {
    var chart = this.chart();
    this.select('.legend-equal').attr('x', 4 + 26 + 4).attr('y', chart.height - 4).attr('text-anchor', 'start');
    this.select('.scales-equal').attr('transform', "translate(4, ".concat(chart.height - 15 - 4, ")"));
    this.select('.legend-inequal').attr('x', chart.width - 4 - 26 - 4).attr('y', chart.height - 4).attr('text-anchor', 'end');
    return this.select('.scales-inequal').attr('transform', "translate(".concat(chart.width - 4 - 28, ", ").concat(chart.height - 15 - 4, ")"));
  }
};
BinChart.prototype.binsLayerConfig = {
  dataBind: function dataBind() {
    var chart = this.chart();
    return this.selectAll('g').data(chart.bins);
  },
  insert: function insert() {
    return this.append('g').classed('bin', true);
  },
  events: {
    enter: function enter() {
      var chart = this.chart();
      this.attr('transform', function (d) {
        return "translate(".concat(chart.x(d.x), ", ").concat(chart.y(d.y), ")");
      });
      var markers = this.selectAll('.marker-dot').data(_.identity);
      return markers.enter().append('circle').attr('class', 'marker-dot').attr('data-id', idKey).attr('cx', chart.radius).attr('cy', function (d, i) {
        return i * (2 + chart.markerPad) * chart.radius + chart.markerPad * chart.radius;
      }).attr('r', chart.radius).each(function (d) {
        chart.updateHighlight(this, d);
        chart.addTooltip({
          target: this,
          render: chart.tooltipContent,
          d: d
        }); // No fixed tooltip for now. The chart is too small anyway.
      });
    }
  }
};
module.exports = BinChart;

},{"../i18n":82,"../util/chart":119,"../util/number-formatter":135,"./chart-labels":44,"./interactive-chart":49,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"d3":27,"lodash":"lodash"}],43:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

require('../vendor/d3.geo.projection.van-der-grinten3.js');

var WORLD_MAP = require('../../data/world-capitals-110m.js');

var COUNTRY_NEIGHBORS = require('../../data/country-neighbors.js');

var I18n = require('../i18n');

var _require = require('../util/chart'),
    absoluteExtremum = _require.absoluteExtremum,
    dValue = _require.dValue,
    idKey = _require.idKey;

var mathUtil = require('../util/math');

var numberFormatter = require('../util/number-formatter');

var geom = require('../util/geom');

var InteractiveChart = require('./interactive-chart');

var ChartLabels = require('./chart-labels');

var tooltipTemplates = require('./tooltip-templates'); // Constants
// ---------


var MAP_TRANSLATE_X = 0.373;
var MAP_TRANSLATE_Y = 0.63;
var ZOOM = 0.205;

var BubbleChart = /*#__PURE__*/function (_InteractiveChart) {
  (0, _inherits2.default)(BubbleChart, _InteractiveChart);

  var _super = _createSuper(BubbleChart);

  function BubbleChart() {
    (0, _classCallCheck2.default)(this, BubbleChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(BubbleChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(BubbleChart.prototype), "initialize", this).call(this, options);
      this.base.classed('bubble-chart', true);
      var labels = this.base.append('g').attr('class', 'chart-labels');
      this.attach('labels', new ChartLabels(labels, {
        model: this.model
      }));
      this.layer('countryMarks', this.base.append('g').classed('country-marks', true), this.countryMarksLayerConfig);
    }
  }, {
    key: "isDefined",
    value: function isDefined(value) {
      var sign = mathUtil.sign(value);
      return sign === 0 || sign === mathUtil.sign(this.extremum);
    }
  }, {
    key: "layoutCountryPoints",
    value: function layoutCountryPoints(selection) {
      geom.evenOut(this.countryPoints, this.links, this.width, this.height, selection);
    } // Tooltips
    // --------

  }, {
    key: "tooltipContent",
    value: function tooltipContent(d) {
      var measureId = this.model.get('measure');
      return tooltipTemplates.full.render({
        location: d.name,
        timePeriod: d.date,
        value: this.formatLabel(d.value),
        measure: I18n.t(['bubbleChart', measureId, 'label'])
      });
    } // Highlighting
    // ------------

  }, {
    key: "countryMarkClick",
    value: function countryMarkClick(d) {
      this.toggleHighlight(d.id);
    }
  }]);
  return BubbleChart;
}(InteractiveChart); // Properties
// ----------


BubbleChart.prototype.boundMethods = ['tooltipContent', 'countryMarkClick'];
BubbleChart.prototype.animateLayout = false; // Dependents
// ----------

BubbleChart.prototype.dependents = {
  projection: {
    after: ['width', 'height'],
    recipe: function recipe() {
      var scale = this.width * ZOOM;
      return d3.geo.vanDerGrinten3().translate([this.width * MAP_TRANSLATE_X, this.height * MAP_TRANSLATE_Y]).scale(scale);
    }
  },
  geoPath: {
    after: ['projection'],
    recipe: function recipe() {
      return d3.geo.path().projection(this.projection);
    }
  },
  extremum: {
    recipe: function recipe(data) {
      return absoluteExtremum(data, dValue);
    }
  },
  valueScale: {
    after: ['width', 'extremum'],
    initial: function initial() {
      return d3.scale.sqrt().nice();
    },
    recipe: function recipe(data, scale) {
      return scale.range([2, 0.09 * this.width]).domain([0, this.extremum]);
    }
  },
  // Similar to the countryPoints dependent in MapChart
  countryPoints: {
    after: ['projection', 'valueScale'],
    recipe: function recipe(data) {
      var countryPoints = [];

      for (var i = 0, l = data.length; i < l; i++) {
        var locationWithValue = data[i];

        var countryCapital = _.find(WORLD_MAP.objects.capitals, {
          id: locationWithValue.id
        });

        if (!countryCapital) {
          continue;
        }

        var value = locationWithValue.value;

        if (!this.isDefined(value)) {
          continue;
        }

        var _this$projection = this.projection([countryCapital.long, countryCapital.lat]),
            _this$projection2 = (0, _slicedToArray2.default)(_this$projection, 2),
            x = _this$projection2[0],
            y = _this$projection2[1];

        countryPoints.push({
          id: locationWithValue.id,
          name: locationWithValue.name,
          x: x,
          y: y,
          value: value,
          date: locationWithValue.date,
          radius: this.valueScale(value)
        });
      }

      return countryPoints;
    }
  },
  // Similar to the links dependent in MapChart
  links: {
    after: ['countryPoints'],
    recipe: function recipe() {
      var links = [];
      var countryPoints = this.countryPoints;

      for (var i = 0, l = countryPoints.length; i < l; i++) {
        var countryPoint = countryPoints[i];
        var neighbors = COUNTRY_NEIGHBORS[countryPoint.id];

        if (!neighbors) {
          continue;
        }

        for (var j = 0, l2 = neighbors.length; j < l2; j++) {
          var id = neighbors[j];

          var other = _.find(countryPoints, {
            id: id
          });

          if (other) {
            links.push({
              source: countryPoint,
              target: other
            });
          }
        }
      }

      return links;
    }
  },
  formatLabel: {
    after: ['countryPoints'],
    recipe: function recipe() {
      var values = this.countryPoints.map(dValue);
      return numberFormatter.labelFormatter(values);
    }
  }
}; // Country marks layer
// -------------------

BubbleChart.prototype.countryMarksLayerConfig = {
  dataBind: function dataBind() {
    var chart = this.chart();
    var selection = this.selectAll('.country-mark').data(chart.countryPoints, idKey);

    if (chart.animateLayout) {
      chart.layoutCountryPoints(selection);
    } else {
      chart.layoutCountryPoints();
    }

    return selection;
  },
  insert: function insert() {
    return this.append('g').attr('class', 'country-mark');
  },
  events: {
    enter: function enter() {
      this.append('circle').attr('class', 'marker-dot');
      this.append('text').attr('class', 'marker-label').attr('text-anchor', 'middle').attr('y', 3);
    },
    merge: function merge() {
      var chart = this.chart(); // Data: Circle

      this.select('.marker-dot').attr('r', function (d) {
        return d.radius;
      }); // Data: Label

      this.select('.marker-label').text(idKey); // Positioning and adjustments

      this.attr('data-id', idKey).attr('transform', function (d) {
        return "translate(".concat(d.x, ", ").concat(d.y, ")");
      }).each(function (d) {
        chart.updateHighlight(this, d);
        return chart.addTooltip({
          target: this,
          render: chart.tooltipContent,
          d: d
        });
      }); // No fixed tooltip for now. The chart is too small anyway.
    },
    exit: function exit() {
      var chart = this.chart();
      this.each(function () {
        chart.removeTooltip(this);
      });
      this.remove();
    }
  }
};
module.exports = BubbleChart;

},{"../../data/country-neighbors.js":33,"../../data/world-capitals-110m.js":34,"../i18n":82,"../util/chart":119,"../util/geom":127,"../util/math":132,"../util/number-formatter":135,"../vendor/d3.geo.projection.van-der-grinten3.js":148,"./chart-labels":44,"./interactive-chart":49,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/slicedToArray":20,"d3":27,"lodash":"lodash"}],44:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var _require = require('../i18n'),
    t = _require.t;

var _require2 = require('../util/chart'),
    selector = _require2.selector;

var numberFormatter = require('../util/number-formatter');

var tooltipTemplates = require('./tooltip-templates');

var BaseChart = require('./base-chart');
/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').Dependents} Dependents */

/** @typedef {import('../types/types').DataBoundLayerOptions} DataBoundLayerOptions */

/** @typedef {import('../types/types').DataForLabels} DataForLabels */

/** @typedef {import('../types/types').NonDataBoundLayerOptions<DataForLabels>} ChartLabelsLayerOptions */
// Constants
// ---------


var FORECAST_MARKER_CONTAINER_CLASS = 'forecast-marker-container';
var FORECAST_MARKER_CLASS = 'forecast-marker';
var FORECAST_MARKER_RECT_CLASS = 'forecast-marker-rect';
var FORECAST_MARKER_LABEL_CLASS = 'forecast-marker-label'; // The forecast marker label is visible in these modes

var FORECAST_MARKER_LABEL_MODES = ['normal', 'big', 'large'];
/**
 * Attached chart that renders the background, the x and y axes
 *
 * @template {DataForLabels} Data
 * @extends BaseChart<Data>
 */

var ChartLabels = /*#__PURE__*/function (_BaseChart) {
  (0, _inherits2.default)(ChartLabels, _BaseChart);

  var _super = _createSuper(ChartLabels);

  function ChartLabels() {
    (0, _classCallCheck2.default)(this, ChartLabels);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(ChartLabels, [{
    key: "initialize",
    value: // Property declarations
    // ---------------------
    //
    // x: d3.time.Scale
    // xAxis: d3.svg.Axis
    // yAxis: d3.svg.Axis
    // interactiveTooltipService: InteractiveTooltipService
    // background: d3.Selection

    /**
     * @param {{
     * model: import('../models/chart-data'),
     * x?: d3.time.Scale,
     * xAxis?: d3.svg.Axis,
     * yAxis?: d3.svg.Axis,
     * interactiveTooltipService: import('./interactive-tooltip-service'),
     * showForecastMarker: boolean
     * }} options
     */
    function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ChartLabels.prototype), "initialize", this).call(this, options);
      this.x = options.x;
      this.xAxis = options.xAxis;
      this.yAxis = options.yAxis;
      this.interactiveTooltipService = options.interactiveTooltipService;
      this.layer('background', this.base.append('rect').classed('chart-background', true), this.backgroundLayerConfig);

      if (options.showForecastMarker && this.x) {
        this.layer('forecastMarker', this.base.append('g').classed(FORECAST_MARKER_CONTAINER_CLASS, true), this.forecastMarkerLayerConfig);
      }

      if (this.xAxis) {
        this.xAxisContainer = this.base.append('g').attr({
          class: 'x chart-axis',
          'aria-hidden': 'true'
        });
        this.layer('xAxis', this.xAxisContainer, this.xAxisLayerConfig);
      }

      if (this.yAxis) {
        this.yAxisContainer = this.base.append('g').attr({
          class: 'y chart-axis',
          'aria-hidden': 'true'
        });
        this.layer('yAxis', this.yAxisContainer, this.yAxisLayerConfig);
      }
    }
  }, {
    key: "yTickTooltipContent",
    value: function yTickTooltipContent(value) {
      return tooltipTemplates.valueMeasure.render({
        value: numberFormatter.formatNumber(value),
        measure: this.measure.name
      });
    }
  }]);
  return ChartLabels;
}(BaseChart); // Method binding
// --------------


ChartLabels.prototype.boundMethods = ['yTickTooltipContent'];
/** @type {Dependents} */

ChartLabels.prototype.dependents = {
  measure: {
    recipe: function recipe(data) {
      return data.measure;
    }
  }
};
/** @type {ChartLabelsLayerOptions} */

ChartLabels.prototype.backgroundLayerConfig = {
  draw: function draw(data) {
    this.attr({
      width: data.width,
      height: data.height
    });
  }
};
/** @typedef {DataForLabels & { forecastDate: Date }} ForecastData */

/**
 * @type {import('../types/types').DataBoundLayerOptions<
 *   DataForLabels, ForecastData, ChartLabels
 * >}
 */

ChartLabels.prototype.forecastMarkerLayerConfig = {
  dataBind: function dataBind(data) {
    var chart = this.chart();
    var forecastData = [];
    var forecastStartTime = chart.model.get('forecastStartTime');

    if (forecastStartTime) {
      var timePeriod = _.find(data.timePeriods, function (candidate) {
        return candidate.id === forecastStartTime;
      });

      var date = timePeriod ? timePeriod.date : undefined;

      if (date) {
        /** @type {ForecastData} */
        var forecastDatum = _.clone(data);

        forecastDatum.forecastDate = date;
        forecastData.push(forecastDatum);
      }
    }

    return this.selectAll(selector(FORECAST_MARKER_CLASS)).data(forecastData);
  },
  insert: function insert() {
    return this.append('g').classed(FORECAST_MARKER_CLASS, true);
  },
  events: {
    enter: function enter() {
      this.append('rect').classed(FORECAST_MARKER_RECT_CLASS, true);
      this.append('text').classed(FORECAST_MARKER_LABEL_CLASS, true).attr('y', 10).attr('dy', '.71em');
    },
    merge: function merge() {
      var chart = this.chart();
      this.select(selector(FORECAST_MARKER_RECT_CLASS)).attr({
        x: function x(data) {
          return chart.x(data.forecastDate) + data.paddingLeft;
        },
        width: function width(data) {
          return data.width - (chart.x(data.forecastDate) + data.paddingLeft);
        },
        height: function height(data) {
          return data.height;
        }
      });
      this.select(selector(FORECAST_MARKER_LABEL_CLASS)).text(t('chart.forecastMarkerLabel')).attr({
        x: function x(data) {
          return chart.x(data.forecastDate) + data.paddingLeft + 10;
        },
        visibility: function visibility() {
          return FORECAST_MARKER_LABEL_MODES.indexOf(chart.mode) >= 0 ? 'visible' : 'hidden';
        }
      });
    },
    exit: function exit() {
      this.remove();
    }
  }
};
/** @type {ChartLabelsLayerOptions} */

ChartLabels.prototype.xAxisLayerConfig = {
  modes: ['normal', 'big', 'large'],
  draw: function draw(data) {
    var chart = this.chart(); // Draw axis

    chart.xAxis(this); // Move axis

    var height = data.height,
        paddingLeft = data.paddingLeft;
    var x = paddingLeft;
    var y = chart.xAxis.orient() === 'bottom' ? height : 0;
    this.attr('transform', "translate(".concat(x, ", ").concat(y, ")"));
  }
};
/** @type {ChartLabelsLayerOptions} */

ChartLabels.prototype.yAxisLayerConfig = {
  modes: ['reduced', 'normal', 'big', 'large'],
  draw: function draw(data) {
    var chart = this.chart(); // Draw axis

    chart.yAxis(this); // Move axis

    var width = data.width,
        paddingTop = data.paddingTop;
    var x = chart.yAxis.orient() === 'right' ? width : 0;
    var y = paddingTop;
    this.attr('transform', "translate(".concat(x, ", ").concat(y, ")")); // Fix y placement of labels

    var texts = this.selectAll('text').attr('dy', -3.5); // Add tooltips to all labels

    if (chart.interactiveTooltipService) {
      texts.each(function (d) {
        chart.interactiveTooltipService.add({
          target: this,
          render: chart.yTickTooltipContent,
          d: d
        });
      });
    }
  }
};
module.exports = ChartLabels;

},{"../i18n":82,"../util/chart":119,"../util/number-formatter":135,"./base-chart":40,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"lodash":"lodash"}],45:[function(require,module,exports){
"use strict";

var $ = require('jquery');

var CHART_MODES = require('../constants/chart-modes');

var ASPECT_RATIO = require('../constants/aspect-ratio');

var stringUtil = require('../util/string');
/** @typedef {import('../types/types').ChartMode} ChartMode */
// Determining the chart mode and setting


var chartMode = {
  /**
   * Determines the chart mode for the given dimensions
   *
   * @param {number} width
   * @param {number} height
   * @returns {ChartMode}
   */
  get: function get(width, height) {
    var mode = CHART_MODES[0].name;
    CHART_MODES.forEach(function (modeSpec) {
      var minX = modeSpec.threshold;
      var minY = minX / ASPECT_RATIO;

      if (width >= minX && height >= minY) {
        mode = modeSpec.name;
      }
    });
    return mode;
  },

  /**
   * Sets the appropriate HTML class for the given mode,
   * removes all other mode classes.
   *
   * @param {HTMLElement} element
   * @param {ChartMode} mode
   */
  setClass: function setClass(element, mode) {
    element = $(element); // Set mode class, remove others

    CHART_MODES.forEach(function (modeSpec) {
      var otherMode = modeSpec.name;
      var active = otherMode === mode;
      element.toggleClass(stringUtil.dasherize(otherMode), active);
    });
  }
};
module.exports = chartMode;

},{"../constants/aspect-ratio":68,"../constants/chart-modes":69,"../util/string":139,"jquery":"jquery"}],46:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var _require = require('../util/chart'),
    dName = _require.dName,
    hasValue = _require.hasValue,
    idKey = _require.idKey,
    latestDataPoint = _require.latestDataPoint,
    selector = _require.selector;

var _require2 = require('../util/number-formatter'),
    labelFormatter = _require2.labelFormatter;

var PaddedChart = require('./padded-chart');

var ChartLabels = require('./chart-labels');

var _require3 = require('./tooltip-templates'),
    fullWithSubject = _require3.fullWithSubject;
/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').SubjectWithValues} SubjectWithValues */

/** @typedef {import('../types/types').DataPoint} DataPoint */

/**
 * @typedef {import('../types/types').IdAndName & {
 * locationId: string,
 * locationName: string,
 * values: [DataPoint, DataPoint],
 * }} SubjectWithTwoValues
 */

/** @typedef {SubjectWithTwoValues[]} SubjectsWithTwoValues */
// Constants
// ---------
// The class of the element that represents a datum


var ITEM_CLASS = 'subject';
var BAR_GROUP_CLASS = 'bar-group';
var BAR_CLASS = 'bar';
var BAR_DESC_CLASS = 'bar-desc';
var VALUE_LABEL_CLASS = 'value-label';
/**
 * @template {RawChartData} Data
 */

var ClusteredBarChart = /*#__PURE__*/function (_PaddedChart) {
  (0, _inherits2.default)(ClusteredBarChart, _PaddedChart);

  var _super = _createSuper(ClusteredBarChart);

  function ClusteredBarChart() {
    (0, _classCallCheck2.default)(this, ClusteredBarChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(ClusteredBarChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ClusteredBarChart.prototype), "initialize", this).call(this, options);
      /** @type {d3.scale.Ordinal<string>} */

      this.xSubjects;
      /** @type {d3.scale.Ordinal<string>} */

      this.xValues;
      /** @type {string[]} */

      this.subjectIds;
      /** @type {SubjectsWithTwoValues} */

      this.subjectsWithTwoValues;
      this.base.classed('clustered-bar-chart', true); // y axis

      var labels = this.base.append('g').attr('class', 'chart-labels');
      this.attach('labels', new ChartLabels(labels, {
        model: this.model,
        xAxis: this.xAxis,
        yAxis: this.yAxis,
        interactiveTooltipService: this.interactiveTooltipService
      }));
      this.subjectsGroup = this.base.append('g').attr('class', 'subjects');
      this.layer('subjects', this.subjectsGroup, this.subjectsLayerConfig);
    }
    /**
     * @param {Data} data
     */

  }, {
    key: "applyDependents",
    value: function applyDependents(data) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ClusteredBarChart.prototype), "applyDependents", this).call(this, data);
      this.subjectsGroup.attr('transform', "translate(".concat(this.paddingLeft, ", ").concat(this.paddingTop, ")"));
    }
    /**
     * @param {SVGGElement} subjectGroup
     */

  }, {
    key: "updateSubjectGroup",
    value: function updateSubjectGroup(subjectGroup) {
      var chart = this;
      /** @type {import('../types/types').ChartSelection<SubjectWithTwoValues, ClusteredBarChart>} */

      var subjectSelection = d3.select(subjectGroup); // Data bind
      // ---------

      var barGroups = subjectSelection.selectAll(selector(BAR_GROUP_CLASS)).data(
      /**
       * @param {SubjectWithTwoValues} subjectWithValues
       */
      function (subjectWithValues) {
        return subjectWithValues.values;
      }); // Enter
      // -----

      var barGroupsEnterSelection = barGroups.enter().append('g').attr('class', BAR_GROUP_CLASS) // Actual bar
      .append('rect').attr('class', BAR_CLASS) // Accessible description
      .append('desc').attr('class', BAR_DESC_CLASS); // Value label

      barGroupsEnterSelection.append('text').attr('class', VALUE_LABEL_CLASS); // Merge
      // -----

      /** @param {DataPoint} dataPoint */

      var barY = function barY(dataPoint) {
        return hasValue(dataPoint) ? chart.y(Math.max(0, dataPoint.value)) : 0;
      }; // Actual bar


      var bars = barGroups.select(selector(BAR_CLASS)).attr({
        x: function x(_dataPoint, index) {
          return chart.xValues(index);
        },
        y: barY,
        width: chart.xValues.rangeBand(),
        height: function height(dataPoint) {
          return hasValue(dataPoint) ? Math.abs(chart.y(dataPoint.value) - chart.y(0)) : 0;
        }
      }).classed('first-bar', function (_dataPoint, index) {
        return index === 0;
      }).classed('second-bar', function (_dataPoint, index) {
        return index === 1;
      }).each(function (dataPoint) {
        chart.addTooltip({
          target: this,
          render: chart.barTooltipContent,
          d: dataPoint
        });
      }); // Accessible description

      bars.select(selector(BAR_DESC_CLASS)).text(function (dataPoint) {
        var locationName = dataPoint.name,
            timePeriodName = dataPoint.timePeriodName,
            subjectName = dataPoint.subjectName;
        var value = chart.formatLabel(dataPoint.value);
        return "".concat(locationName, ", ").concat(timePeriodName, ", ").concat(subjectName, ": ").concat(value, " ").concat(chart.measure.name);
      }); // Value label

      var valueLabels = barGroups.select(selector(VALUE_LABEL_CLASS));
      valueLabels.attr({
        visibility: function visibility(dataPoint) {
          return chart.valueLabelVisible && hasValue(dataPoint) ? 'visible' : 'hidden';
        },
        x: function x(_dataPoint, index) {
          return chart.xValues(index) + chart.xValues.rangeBand() / 2;
        },
        y: function y(dataPoint) {
          return barY(dataPoint) - 6;
        }
      }).text(function (dataPoint) {
        return chart.formatLabelSuffixed(dataPoint.value);
      }) // Classes for color fill
      .classed('first', function (_dataPoint, index) {
        return index === 0;
      }).classed('second', function (_dataPoint, index) {
        return index === 1;
      }); // Exit
      // ----

      barGroups.exit().remove();
    } // Event handling
    // --------------
    // Override method from InteractiveChart, remove the highlighting behavior

  }, {
    key: "itemTap",
    value: function itemTap(event, item) {
      if (event.pointerType === 'touch') {
        // Touch tap: Add hover class, remove from other items
        this.leaveAllItemsHover();
        this.enterItemHover(item);
      }
    } // Override method from InteractiveChart, remove the highlighting behavior

  }, {
    key: "itemPress",
    value: function itemPress() {// Do nothing
    } // Tooltip content
    // ---------------
    // Bar tooltip
    // -----------

    /**
     * @param {DataPoint} d
     */

  }, {
    key: "barTooltipContent",
    value: function barTooltipContent(d) {
      return fullWithSubject.render(this.barTooltipData(d));
    }
    /**
     * @param {DataPoint} d
     */

  }, {
    key: "barTooltipData",
    value: function barTooltipData(d) {
      return {
        location: d.name,
        timePeriod: d.timePeriodName,
        subject: d.subjectName,
        value: this.formatLabel(d.value),
        measure: this.measure.name
      };
    }
  }]);
  return ClusteredBarChart;
}(PaddedChart);

ClusteredBarChart.prototype.itemClass = ITEM_CLASS;
/**
 * @type {import('../types/types').Dependents<RawChartData, ClusteredBarChart>}
 */

ClusteredBarChart.prototype.dependents = {
  measure: {
    recipe: function recipe(data) {
      return data.measure;
    }
  },
  subjectsWithTwoValues: {
    recipe: function recipe(data) {
      var useLatestData = this.model.get('useLatestData');
      return data.subjectsWithValues.map(function (subjectWithValues) {
        var firstLocation = subjectWithValues.locationsWithValues[0];
        var values = firstLocation.values;
        var firstValue = values[0]; // Get latest value.
        // Fall back to the last if useLatestData=true and there is no defined value.

        var secondValue = latestDataPoint(values, useLatestData) || _.last(values);
        /** @type {SubjectWithTwoValues} */


        return {
          id: subjectWithValues.id,
          name: subjectWithValues.name,
          locationId: firstLocation.id,
          locationName: firstLocation.name,
          values: [firstValue, secondValue]
        };
      });
    }
  },
  // The extent of the data as [min: Number, max: Number]
  dataExtent: {
    after: ['subjectsWithTwoValues'],
    recipe: function recipe() {
      /** @type {number[]} */
      var allValues = [];
      this.subjectsWithTwoValues.forEach(function (subjectWithTwoValues) {
        var _subjectWithTwoValues = (0, _slicedToArray2.default)(subjectWithTwoValues.values, 2),
            value1 = _subjectWithTwoValues[0],
            value2 = _subjectWithTwoValues[1];

        allValues.push(value1.value, value2.value);
      });

      var _d3$extent = d3.extent(allValues),
          _d3$extent2 = (0, _slicedToArray2.default)(_d3$extent, 2),
          min = _d3$extent2[0],
          max = _d3$extent2[1]; // Ensure that min/max is 0 when the numbers are in the same quadrant


      if (min > 0 && max > 0) {
        min = 0;
      } else if (min < 0 && max < 0) {
        max = 0;
      } // If min and max are identical, apply some scale


      if (min === max) {
        max = Math.abs(min * 5);
      }

      return [min, max];
    }
  },
  // Subject helpers
  // ---------------
  subjectIds: {
    recipe: function recipe(data) {
      return data.subjects.map(idKey);
    }
  },
  subjectNames: {
    recipe: function recipe(data) {
      return data.subjects.map(dName);
    }
  },
  // Scales
  // ------
  xSubjects: {
    after: ['plotWidth', 'subjectIds'],
    initial: function initial() {
      return d3.scale.ordinal();
    },

    /**
     * @param {d3.scale.Ordinal<string>} scale
     */
    recipe: function recipe(_data, scale) {
      return scale.rangeRoundBands([0, this.plotWidth], 0.1, 0.1).domain(this.subjectIds);
    }
  },
  xValues: {
    after: ['xSubjects'],
    initial: function initial() {
      return d3.scale.ordinal();
    },

    /**
     * @param {d3.scale.Ordinal<number>} scale
     */
    recipe: function recipe(_data, scale) {
      return scale.rangeRoundBands([0, this.xSubjects.rangeBand()]) // We have two values, identified by index
      .domain([0, 1]);
    }
  },
  y: {
    after: ['plotHeight', 'dataExtent'],
    initial: function initial() {
      return d3.scale.linear();
    },

    /**
     * @param {d3.scale.Linear<number, number>} scale
     */
    recipe: function recipe(_data, scale) {
      return scale.range([this.plotHeight, 0]).domain(this.dataExtent);
    }
  },
  valueLabelVisible: {
    after: ['xValues'],
    recipe: function recipe() {
      return this.xValues.rangeBand() > 50 && this.plotWidth > 400;
    }
  },
  // Axes
  // ----
  xAxis: {
    after: ['xSubjects'],
    initial: function initial() {
      var _this = this;

      return d3.svg.axis().orient('bottom').tickFormat(function (_subjectId, index) {
        return _this.subjectNames[index];
      }).tickSize(4, 0);
    },

    /**
     * @param {RawChartData} _data
     * @param {d3.svg.Axis} axis
     */
    recipe: function recipe(_data, axis) {
      return axis.scale(this.xSubjects);
    }
  },
  // Label formatting
  // ----------------
  // Full number without suffix
  formatLabel: {
    after: ['dataExtent'],
    recipe: function recipe() {
      return labelFormatter(this.dataExtent, false, true);
    }
  },
  // Full number with suffix
  formatLabelSuffixed: {
    after: ['dataExtent'],
    recipe: function recipe() {
      return labelFormatter(this.dataExtent, true, true);
    }
  }
}; // Layers
// ------

/**
 * @type {import('../types/types').LayerOptions<
 *  SubjectWithTwoValues, SubjectWithTwoValues, ClusteredBarChart
 * >}
 */

ClusteredBarChart.prototype.subjectsLayerConfig = {
  dataBind: function dataBind() {
    var chart = this.chart();
    return this.selectAll(selector(ITEM_CLASS)).data(chart.subjectsWithTwoValues, idKey);
  },
  insert: function insert() {
    return this.append('g').attr('class', ITEM_CLASS);
  },
  events: {
    merge: function merge() {
      var chart = this.chart();
      this.attr({
        // Add the subject id as an attribute
        'data-subject': idKey,
        transform: function transform(d) {
          return "translate(".concat(chart.xSubjects(d.id), ", 0)");
        }
      });
      this.each(function (_d, index) {
        chart.updateSubjectGroup(this, index);
      });
    },
    exit: function exit() {
      var chart = this.chart();
      this.select(selector(BAR_CLASS)).each(function () {
        chart.removeTooltip(this);
      });
      this.remove();
    }
  }
};
ClusteredBarChart.prototype.boundMethods = ['barTooltipContent'];
module.exports = ClusteredBarChart;

},{"../util/chart":119,"../util/number-formatter":135,"./chart-labels":44,"./padded-chart":58,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/slicedToArray":20,"d3":27,"lodash":"lodash"}],47:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var I18n = require('../i18n');

var BaseChart = require('./base-chart');

var ChartLabels = require('./chart-labels'); // Constants
// ---------


var GENDERS = ['male', 'female']; // Spacing between each of the discipline choosers.

var NAVIGATION_SPACING = 12; // Height of the header bar.

var HEADER_BAR_HEIGHT = 24; // Abscissa values for dot columns.

var ABSCISSA_RATIO = 0.3; // Determines the spacing to the bottom edge.

var SPACING_BOTTOM = 8;
var ICON_CIRCLE_RADIUS = 6;
var STROKE_TO_RADIUS_RATIO = 1.8;

var EducationChart = /*#__PURE__*/function (_BaseChart) {
  (0, _inherits2.default)(EducationChart, _BaseChart);

  var _super = _createSuper(EducationChart);

  function EducationChart() {
    (0, _classCallCheck2.default)(this, EducationChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(EducationChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(EducationChart.prototype), "initialize", this).call(this, options);
      this.base.classed('education-chart', true); // Background

      var labels = this.base.append('g').attr('class', 'chart-labels');
      return this.attach('labels', new ChartLabels(labels, {
        model: this.model
      }));
    }
  }, {
    key: "$",
    value: function $(selector) {
      return this.base.selectAll(selector);
    }
  }, {
    key: "draw",
    value: function draw(data) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(EducationChart.prototype), "draw", this).call(this, data); // Empty the element

      this.base.html(''); // Reattach background

      var labelsG = this.attach('labels').base.node();
      this.base.node().appendChild(labelsG); // Data fields

      this.maximumRank = data.maximumRank;
      this.disciplines = _.keys(data.disciplines); // Geometric information

      this.firstColumnAbscissa = this.width * (0.0 + ABSCISSA_RATIO);
      this.secondColumnAbscissa = this.width * (1.0 - ABSCISSA_RATIO); // Spacing to the top edge

      this.spacingTop = 7 + HEADER_BAR_HEIGHT; // Spacing between two dots from center to center.

      this.spacingBetween = (this.height - this.spacingTop - SPACING_BOTTOM) / this.maximumRank; // Dot radii

      this.smallRadius = this.spacingBetween / 3.2;
      this.hugeRadius = this.spacingBetween / 1.2;
      this.drawIcons();
      this.drawTitle();
      this.drawLabels();
      this.drawNavigation(data);
      this.drawConnections(data);
      this.drawScaleDots();
      this.drawPassepartouts();
      this.drawRankDots(data);
      return this.update(data, this.disciplines[0]);
    }
  }, {
    key: "update",
    value: function update(data, highlightedDiscipline) {
      var disciplines = this.disciplines;
      this.highlightedDiscipline = highlightedDiscipline; // Update the text navigation outside of the chart

      d3.selectAll('.education-chart-disciplines a').classed('accessible-hide', function () {
        return d3.select(this).attr('data-discipline') !== highlightedDiscipline;
      });
      this.removeHover(); // Toggle navigation buttons and connection lines

      for (var i = 0, l = disciplines.length; i < l; i++) {
        var discipline = disciplines[i];
        var highlighted = discipline === highlightedDiscipline;
        this.$(".".concat(discipline, "-nav-button, .").concat(discipline, "-connection")).classed('is-highlighted', highlighted);
      }

      var highlightedRanks = {
        male: data.disciplines[highlightedDiscipline].m,
        female: data.disciplines[highlightedDiscipline].f
      };

      for (var rankIndex = 0, _l = this.maximumRank; rankIndex <= _l; rankIndex++) {
        // Whether this rank is highlighted for (fe)males.
        var _highlighted = {
          male: highlightedRanks.male === rankIndex,
          female: highlightedRanks.female === rankIndex
        }; // Whether the position is achieved in some discipline.

        var achieved = {
          male: false,
          female: false
        };
        var achievedDiscipline = {
          male: false,
          female: false
        };

        for (var _i = 0, l2 = disciplines.length; _i < l2; _i++) {
          var _discipline = disciplines[_i];
          var disciplineResults = data.disciplines[_discipline];

          if (disciplineResults.m === rankIndex) {
            achieved.male = true;
            achievedDiscipline.male = _discipline;
          }

          if (disciplineResults.f === rankIndex) {
            achieved.female = true;
            achievedDiscipline.female = _discipline;
          }
        } // Update rank and passepartout dots


        for (var _i2 = 0, _l2 = GENDERS.length; _i2 < _l2; _i2++) {
          var gender = GENDERS[_i2];
          var visible = _highlighted[gender] || achieved[gender];
          var visibility = visible ? 'visible' : 'hidden';
          var _discipline2 = achievedDiscipline[gender];
          this.$(".rank-dot-".concat(gender, "-").concat(rankIndex)).attr('visibility', visibility).classed('is-achieved', achieved[gender]).classed('is-highlighted', _highlighted[gender]).classed("".concat(_discipline2, "-rank-dot"), Boolean(_discipline2)).attr('data-discipline', _discipline2 || '');
          this.$(".passepartout-".concat(gender, "-").concat(rankIndex)).attr('visibility', visibility);
        }
      } // Layout and fill labels


      var minimumBaseLine = HEADER_BAR_HEIGHT + this.spacingTop;
      var maximumBaseLine = this.height - SPACING_BOTTOM - 30;

      for (var genderIndex = 0; genderIndex < GENDERS.length; genderIndex++) {
        var _gender = GENDERS[genderIndex];

        var shortGender = _gender.substring(0, 1);

        var rank = data.disciplines[highlightedDiscipline][shortGender];
        var baseline = rank * this.spacingBetween + this.spacingTop;

        if (baseline < minimumBaseLine) {
          baseline = minimumBaseLine;
        }

        if (baseline > maximumBaseLine) {
          baseline = maximumBaseLine;
        }

        var baselineAbscissa = genderIndex === 0 ? this.firstColumnAbscissa - 43 : this.secondColumnAbscissa + 10;
        this.$(".".concat(_gender, "-rank-label-rank")).attr({
          x: baselineAbscissa,
          y: baseline - 15
        });
        this.$(".".concat(_gender, "-rank")).attr({
          x: baselineAbscissa,
          y: baseline
        });
        this.$(".".concat(_gender, "-rank-label-achieved")).text(rank);
        this.$(".".concat(_gender, "-rank-label-total")).text("/".concat(this.maximumRank));
      }
    }
  }, {
    key: "navDotMouseenter",
    value: function navDotMouseenter(discipline) {
      this.addHover(discipline);
    }
  }, {
    key: "navDotMouseleave",
    value: function navDotMouseleave(discipline) {
      if (discipline === this.highlightedDiscipline) {
        return;
      }

      this.removeHover();
    } // Draws male and female icons

  }, {
    key: "drawIcons",
    value: function drawIcons() {
      // Male
      var cx = this.firstColumnAbscissa / 2;
      var cy = this.height - ICON_CIRCLE_RADIUS - SPACING_BOTTOM * 2;
      this.base.append('circle').attr({
        cx: cx,
        cy: cy,
        r: ICON_CIRCLE_RADIUS
      }).classed('gender-circle', true);
      var strokeRadius = ICON_CIRCLE_RADIUS * STROKE_TO_RADIUS_RATIO;
      this.base.append('line').attr({
        x1: cx + ICON_CIRCLE_RADIUS - 1.2,
        y1: cy - ICON_CIRCLE_RADIUS + 1.2,
        x2: cx + strokeRadius,
        y2: cy - strokeRadius
      }).classed('gender-line', true);
      this.base.append('line').attr({
        x1: cx + strokeRadius,
        y1: cy - strokeRadius,
        x2: cx + strokeRadius,
        y2: cy - strokeRadius / 2
      }).classed('gender-line', true);
      this.base.append('line').attr({
        x1: cx + strokeRadius,
        y1: cy - strokeRadius,
        x2: cx + strokeRadius / 2,
        y2: cy - strokeRadius
      }).classed('gender-line', true); // Female

      cx = (this.width + this.secondColumnAbscissa) / 2;
      cy = this.height - ICON_CIRCLE_RADIUS - SPACING_BOTTOM * 2 - ICON_CIRCLE_RADIUS * STROKE_TO_RADIUS_RATIO / 1.7;
      this.base.append('circle').attr({
        cx: cx,
        cy: cy,
        r: ICON_CIRCLE_RADIUS
      }).classed('gender-circle', true);
      this.base.append('line').attr({
        x1: cx,
        y1: cy + ICON_CIRCLE_RADIUS + 1.4,
        x2: cx,
        y2: cy + strokeRadius * 1.4
      }).classed('gender-line', true);
      this.base.append('line').attr({
        x1: cx - strokeRadius * 0.3,
        y1: cy + strokeRadius,
        x2: cx + strokeRadius * 0.3,
        y2: cy + strokeRadius
      }).classed('gender-line', true);
    }
  }, {
    key: "drawTitle",
    value: function drawTitle() {
      this.base.append('rect').attr('width', this.width).attr('height', HEADER_BAR_HEIGHT).classed('education-chart-title-bar', true);
    } // Draws labels showing the current rank that is being displayed

  }, {
    key: "drawLabels",
    value: function drawLabels() {
      for (var i = 0, l = GENDERS.length; i < l; i++) {
        var gender = GENDERS[i];
        var rank = this.base.append('text').classed("".concat(gender, "-rank"), true);
        rank.append('tspan').classed('rank-label-achieved', true).classed("".concat(gender, "-rank-label-achieved"), true);
        rank.append('tspan').classed('rank-label-total', true).classed("".concat(gender, "-rank-label-total"), true);
        this.base.append('text').classed('rank-label-rank', true).classed("".concat(gender, "-rank-label-rank"), true).text(I18n.t('educationChart.rank'));
      }
    }
  }, {
    key: "drawNavigation",
    value: function drawNavigation(data) {
      for (var i = 0; i < this.disciplines.length; i++) {
        var discipline = this.disciplines[i];
        var x = this.width - (this.disciplines.length - 1) * NAVIGATION_SPACING - NAVIGATION_SPACING + NAVIGATION_SPACING * i;
        this.base.append('circle').attr({
          r: HEADER_BAR_HEIGHT / 5,
          cx: x,
          cy: HEADER_BAR_HEIGHT / 2
        }).classed('nav-button', true).classed("".concat(discipline, "-nav-button"), true).on('click', this.update.bind(this, data, discipline)).on('mouseenter', this.navDotMouseenter.bind(this, discipline)).on('mouseleave', this.navDotMouseleave.bind(this, discipline));
      }
    }
  }, {
    key: "drawConnections",
    value: function drawConnections(data) {
      for (var i = 0, l = this.disciplines.length; i < l; i++) {
        var discipline = this.disciplines[i];
        this.base.append('line').attr({
          x1: this.firstColumnAbscissa,
          y1: data.disciplines[discipline].m * this.spacingBetween + this.spacingTop,
          x2: this.secondColumnAbscissa,
          y2: data.disciplines[discipline].f * this.spacingBetween + this.spacingTop
        }).classed('connection', true).classed("".concat(discipline, "-connection"), true);
      }
    }
  }, {
    key: "drawScaleDots",
    value: function drawScaleDots() {
      for (var rankIndex = 1, end = this.maximumRank; rankIndex <= end; rankIndex++) {
        for (var genderIndex = 0; genderIndex < GENDERS.length; genderIndex++) {
          this.base.append('circle').attr({
            r: this.smallRadius,
            cx: this.columnAbscissa(genderIndex),
            cy: this.dotYPos(rankIndex)
          }).classed('scale-dot', true);
        }
      }
    }
  }, {
    key: "drawPassepartouts",
    value: function drawPassepartouts() {
      for (var rankIndex = 1, end = this.maximumRank; rankIndex <= end; rankIndex++) {
        for (var genderIndex = 0; genderIndex < GENDERS.length; genderIndex++) {
          var gender = GENDERS[genderIndex];
          this.base.append('circle').attr({
            r: this.hugeRadius * 1.8,
            cx: this.columnAbscissa(genderIndex),
            cy: this.dotYPos(rankIndex),
            visibility: 'hidden'
          }).classed('passepartout', true).classed("passepartout-".concat(gender, "-").concat(rankIndex), true);
        }
      }
    }
  }, {
    key: "drawRankDots",
    value: function drawRankDots(data) {
      for (var rankIndex = 1, end = this.maximumRank; rankIndex <= end; rankIndex++) {
        for (var genderIndex = 0; genderIndex < GENDERS.length; genderIndex++) {
          var gender = GENDERS[genderIndex];
          this.base.append('circle').attr({
            r: this.hugeRadius,
            cx: this.columnAbscissa(genderIndex),
            cy: this.dotYPos(rankIndex)
          }).classed('rank-dot', true).classed("rank-dot-".concat(gender, "-").concat(rankIndex), true).on('click', this.rankDotClick.bind(this, data)).on('mouseenter', this.rankDotMouseenter).on('mouseleave', this.rankDotMouseleave);
        }
      }
    }
  }, {
    key: "rankDotClick",
    value: function rankDotClick(data) {
      var discipline = d3.select(event.target).attr('data-discipline');

      if (discipline) {
        this.update(data, discipline);
      }
    }
  }, {
    key: "rankDotMouseenter",
    value: function rankDotMouseenter() {
      var event = d3.event;
      var discipline = d3.select(event.target).attr('data-discipline');

      if (discipline) {
        this.addHover(discipline);
      }
    }
  }, {
    key: "rankDotMouseleave",
    value: function rankDotMouseleave() {
      this.removeHover();
    }
  }, {
    key: "dotYPos",
    value: function dotYPos(rankIndex) {
      return rankIndex * this.spacingBetween + this.spacingTop;
    }
  }, {
    key: "columnAbscissa",
    value: function columnAbscissa(genderIndex) {
      if (genderIndex === 0) {
        return this.firstColumnAbscissa;
      } else {
        return this.secondColumnAbscissa;
      }
    }
  }, {
    key: "addHover",
    value: function addHover(discipline) {
      if (discipline === this.highlightedDiscipline) {
        return;
      }

      this.$(".".concat(discipline, "-connection")).classed('hover', true);
      this.$(".".concat(discipline, "-rank-dot")).classed('hover', true);
    }
  }, {
    key: "removeHover",
    value: function removeHover() {
      this.$('.connection, .rank-dot').classed('hover', false);
    }
  }]);
  return EducationChart;
}(BaseChart); // Method binding
// --------------


EducationChart.prototype.boundMethods = ['rankDotMouseenter', 'rankDotMouseleave'];
module.exports = EducationChart;

},{"../i18n":82,"./base-chart":40,"./chart-labels":44,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"d3":27,"lodash":"lodash"}],48:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var d3 = require('d3');

var methodBinding = require('../util/method-binding'); // Service for managing the highlighting in a chart.
// Manages adding and removing of highlighted locations.
// Sets highlight and baseline comparison classes on elements.


var HighlightService = /*#__PURE__*/function () {
  // Property declarations
  // ---------------------
  //
  // model: ChartData

  /**
   * @param {import('../models/chart-data')} model
   */
  function HighlightService(model) {
    (0, _classCallCheck2.default)(this, HighlightService);
    this.model = model;
    this.bindMethods();
  } // Helpers for checking the highlight status
  // -----------------------------------------

  /**
   * Returns whether any locations are actually highlighted.
   */


  (0, _createClass2.default)(HighlightService, [{
    key: "hasHighlightedLocations",
    value: function hasHighlightedLocations() {
      return this.model.actualHighlightedLocations().length > 0;
    }
    /**
     * Returns whether a location id is highlighted.
     *
     * @param {string} id
     */

  }, {
    key: "isHighlighted",
    value: function isHighlighted(id) {
      return this.model.get('highlightedLocations').indexOf(id) >= 0;
    }
    /**
     * Returns whether the given location id is the current baseline comparison
     *
     * @param {string} id
     */

  }, {
    key: "isBaselineComparison",
    value: function isBaselineComparison(id) {
      return id === this.model.get('baselineComparison');
    } // Changing highlighted locations
    // ------------------------------

    /**
     * Add / remove highlight for the given location id
     *
     * @param {string} id
     */

  }, {
    key: "toggle",
    value: function toggle(id) {
      if (this.isBaselineComparison(id)) {
        return;
      }

      if (this.isHighlighted(id)) {
        this._remove(id);
      } else {
        this._add(id);
      }
    }
    /**
     * @param {string} id
     */

  }, {
    key: "add",
    value: function add(id) {
      if (this.isBaselineComparison(id)) {
        return;
      }

      if (!this.isHighlighted(id)) {
        this._add(id);
      }
    }
    /**
     * @param {string} id
     */

  }, {
    key: "_add",
    value: function _add(id) {
      // Create a new array so Backbone recognizes the attribute change
      var locations = this.model.get('highlightedLocations').concat(id);
      this.model.set('highlightedLocations', locations);
    }
    /**
     * @param {string} id
     */

  }, {
    key: "remove",
    value: function remove(id) {
      if (this.isBaselineComparison(id)) {
        return;
      }

      if (this.isHighlighted(id)) {
        this._remove(id);
      }
    }
    /**
     * @param {string} id
     */

  }, {
    key: "_remove",
    value: function _remove(id) {
      var locations = _.without(this.model.get('highlightedLocations'), id);

      this.model.set('highlightedLocations', locations);
    } // Setting highlight and baseline classes on elements
    // --------------------------------------------------

    /**
     * Updates the highlight/baseline classes for a given element and location id.
     *
     * @param {Element} element
     * @param {string} id
     */

  }, {
    key: "update",
    value: function update(element, id) {
      var selection = d3.select(element);
      this.updateHighlight(selection, id);
      this.updateBaselineComparison(selection, id);
    }
    /**
     * Updates the highlight class for a given D3 selection and id.
     * Sets highlight-{1..n} and is-highlighted classes.
     *
     * @param {d3.Selection} selection
     * @param {string} id
     */

  }, {
    key: "updateHighlight",
    value: function updateHighlight(selection, id) {
      var highlightNumber = this.model.highlightNumber(id);
      var highlighted = highlightNumber !== false;
      var classes = {
        'is-highlighted': highlighted
      };
      var highlightLimit = this.model.get('highlightLimit');

      for (var i = 1, end = highlightLimit + 1; i <= end; i++) {
        classes["highlight-".concat(i)] = i === highlightNumber;
      }

      selection.classed(classes);
    }
    /**
     * Toggles the baseline class for a given element and id
     *
     * @param {d3.Selection} selection
     * @param {string} id
     */

  }, {
    key: "updateBaselineComparison",
    value: function updateBaselineComparison(selection, id) {
      selection.classed('baseline-comparison', this.isBaselineComparison(id));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      this.disposed = true;
      delete this.model;
    }
  }]);
  return HighlightService;
}();

_.assign(HighlightService.prototype, methodBinding);

HighlightService.prototype.boundMethods = ['updateBaselineComparison']; // Disposal
// --------

HighlightService.prototype.disposed = false;
module.exports = HighlightService;

},{"../util/method-binding":134,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"d3":27,"lodash":"lodash"}],49:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var $ = require('jquery');

var d3 = require('d3');

var Hammer = require('../vendor/hammer-2.0.4.js');

var _require = require('../util/chart'),
    selector = _require.selector;

var BaseChart = require('./base-chart');

var HighlightService = require('./highlight-service');

var InteractiveTooltipService = require('./interactive-tooltip-service');

var AnnotationService = require('./annotation-service');
/** @typedef {import('../types/types').IdAndName} IdAndName */

/** @typedef {import('./tooltip')} Tooltip */

/** @typedef {import('./tooltip-service').TooltipOptions} TooltipOptions */
// Constants
// ---------
// Show annotations in these modes


var ANNOTATION_MODES = ['normal', 'big', 'large'];
/**
 * Interactive charts have a central event dispatcher and
 * show tooltips and annotations.
 *
 * Using event delegation, all mouse and touch input events are handled
 * at the base element. If the event target is an item or a tooltip,
 * the event is dispatched.
 *
 * A tap on an item is toggling the hover state,
 * a click or long-tap on an item toggles the highlight state.
 *
 * Item elements must have a `data-id` attribute with the location id
 * to allow location highlighting.
 *
 * @template Data
 */

var InteractiveChart = /*#__PURE__*/function (_BaseChart) {
  (0, _inherits2.default)(InteractiveChart, _BaseChart);

  var _super = _createSuper(InteractiveChart);

  function InteractiveChart() {
    (0, _classCallCheck2.default)(this, InteractiveChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(InteractiveChart, [{
    key: "initialize",
    value: // Property declarations
    // ---------------------
    //
    // itemClass: String
    //   The class name of the element that represents a datum.
    function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(InteractiveChart.prototype), "initialize", this).call(this, options); // The model controls the interactivity

      var interactive = this.model.get('interactive');

      if (interactive != null) {
        this.interactive = interactive;
      } // Highlighting is always possible


      this.highlightService = new HighlightService(this.model); // Tooltips require interactivity

      if (this.interactive) {
        this.initInteractiveTooltipService();
        this.initAnnotationService();
        this.initInteraction();
      }
    }
  }, {
    key: "initInteractiveTooltipService",
    value: function initInteractiveTooltipService() {
      this.interactiveTooltipService = new InteractiveTooltipService({
        container: this.container()
      });
    }
  }, {
    key: "initAnnotationService",
    value: function initAnnotationService() {
      this.annotationService = new AnnotationService({
        container: this.container()
      });
    } // Mouse and touch interaction
    // ---------------------------

  }, {
    key: "initInteraction",
    value: function initInteraction() {
      this.base.on('mouseover', this.d3EventHandler).on('mousemove', this.d3EventHandler).on('mouseout', this.d3EventHandler);
      var h = new Hammer.Manager(this.base.node(), {
        recognizers: [[Hammer.Tap], [Hammer.Press]]
      });
      this.hammerManager = h;
      h.on('tap', this.eventHandler);
      h.on('press', this.eventHandler);
    }
  }, {
    key: "d3EventHandler",
    value: function d3EventHandler() {
      return this.eventHandler(d3.event);
    }
    /**
     * Central event handler for event delegation
     *
     * @param {Event} event
     */

  }, {
    key: "eventHandler",
    value: function eventHandler(event) {
      var target = event.target;
      var targetTooltip = this.interactiveTooltipService.tooltipForElement(target); // Dispatch event

      var item;

      if (this.itemClass) {
        item = $(target).closest(selector(this.itemClass)).get(0);
      }

      var itemTooltip;

      if (item) {
        var $item = d3.select(item);
        this.dispatchItemEvent(event, $item);
        itemTooltip = this.interactiveTooltipService.tooltipForElement(item);
      } else {
        this.dispatchChartEvent(event);
      } // Dispatch tooltip


      var tooltip = targetTooltip || itemTooltip;

      if (tooltip) {
        this.dispatchTooltipEvent(event, tooltip);
      }
    }
    /**
     * Dispatches item interactivity events.
     *
     * @param {Event} event
     * @param {d3.Selection} target
     */

  }, {
    key: "dispatchItemEvent",
    value: function dispatchItemEvent(event, target) {
      switch (event.type) {
        case 'mouseover':
          this.itemMouseover(event, target);
          break;

        case 'mouseout':
          this.itemMouseout(event, target);
          break;

        case 'tap':
          this.itemTap(event, target);
          break;

        case 'press':
          this.itemPress(event, target);
          break;
      }
    }
    /**
     * Dispatches chart-wide events.
     *
     * @param {Event} event
     */

  }, {
    key: "dispatchChartEvent",
    value: function dispatchChartEvent(event) {
      switch (event.type) {
        case 'tap':
          this.interactiveTooltipService.endHover();
          break;
      }
    }
    /**
     * Dispatches chart-wide events to a tooltip.
     *
     * @param {Event} event
     * @param {Tooltip} tooltip
     */

  }, {
    key: "dispatchTooltipEvent",
    value: function dispatchTooltipEvent(event, tooltip) {
      switch (event.type) {
        case 'mouseover':
          tooltip.mouseenterHandler(event);
          break;

        case 'mousemove':
          tooltip.mousemoveHandler(event);
          break;

        case 'mouseout':
          tooltip.mouseleaveHandler(event);
          break;

        case 'tap':
          tooltip.tapHandler(event);
          break;
      }
    } // Item event handlers
    // -------------------

    /**
     * Handles a mouseover event at an item.
     *
     * @param {Event} event
     * @param {d3.Selection} item
     */

  }, {
    key: "itemMouseover",
    value: function itemMouseover(_event, item) {
      this.enterItemHover(item);
    }
    /**
     * Handles a mouseout event at an item.
     *
     * @param {Event} _event
     * @param {d3.Selection} item
     */

  }, {
    key: "itemMouseout",
    value: function itemMouseout(_event, item) {
      this.leaveItemHover(item);
    }
    /**
     * Handles a Hammer.js tap event at an item.
     * Changes to hover on tap, adds highlight on mouse click.
     *
     * @param {Event} event
     * @param {d3.Selection} item
     */

  }, {
    key: "itemTap",
    value: function itemTap(event, item) {
      if (event.pointerType === 'touch') {
        // Touch tap: Add hover class, remove from other items
        this.leaveAllItemsHover();
        this.enterItemHover(item);
      } else {
        // Mouse click: Highlight
        this.highlightService.toggle(this.idForItem(item));
      }
    }
    /**
     * Handles a Hammer.js press event at an item.
     * Highlights the location.
     *
     * @param {Event} _event
     * @param {d3.Selection} item
     */

  }, {
    key: "itemPress",
    value: function itemPress(_event, item) {
      this.highlightService.toggle(this.idForItem(item));
    }
    /**
     * Returns the location id for an item.
     * Items MUST have a `data-id` attribute for this purpose.
     * Throws an exception if `data-id` cannot be read.
     *
     * @param {d3.Selection} item
     */

  }, {
    key: "idForItem",
    value: function idForItem(item) {
      var id = item.attr('data-id');

      if (!id) {
        throw new Error('ID to highlight not found');
      }

      return id;
    } // Item hover logic
    // ----------------

    /**
     * Enters the hover state for a given item.
     *
     * @param {d3.Selection} item
     */

  }, {
    key: "enterItemHover",
    value: function enterItemHover(item) {
      return item.classed('hover', true);
    }
    /**
     * Leaves the hover state for a given item.
     *
     * @param {d3.Selection} item
     */

  }, {
    key: "leaveItemHover",
    value: function leaveItemHover(item) {
      return item.classed('hover', false);
    }
    /**
     * Makes all items to leave the hover state.
     */

  }, {
    key: "leaveAllItemsHover",
    value: function leaveAllItemsHover() {
      this.allItems().classed('hover', false);
    }
    /**
     * Returns all items in the chart.
     */

  }, {
    key: "allItems",
    value: function allItems() {
      return this.base.selectAll(selector(this.itemClass));
    } // Drawing
    // -------

    /**
     * @param {Data} data
     */

  }, {
    key: "draw",
    value: function draw(data) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(InteractiveChart.prototype), "draw", this).call(this, data);

      if (this.interactive) {
        // Hide hover tooltips
        this.interactiveTooltipService.endHover(); // Layouting annotations after the drawing is completed

        this.annotationService.layoutInNextTick();
      }

      return this;
    } // Tooltip service shortcuts
    // -------------------------
    // These wrappers allow us to disable interactivity.

    /**
     * @param {TooltipOptions} options
     */

  }, {
    key: "addTooltip",
    value: function addTooltip(options) {
      if (this.interactive) {
        return this.interactiveTooltipService.add(options);
      }
    }
    /**
     * @param {Element} element
     */

  }, {
    key: "removeTooltip",
    value: function removeTooltip(element) {
      if (this.interactive) {
        return this.interactiveTooltipService.remove(element);
      }
    } // Annotation service shortcuts
    // ----------------------------

    /**
     * Adds an annotation to an element.
     * The d option is stored at the Annotation and passed to the render function.
     * @param {TooltipOptions} options
     */

  }, {
    key: "addAnnotation",
    value: function addAnnotation(options) {
      if (this.interactive) {
        this.annotationService.add(options);
      }
    }
    /**
     * Removes an annotation from the given element, if any present.
     * @param {Element} element
     */

  }, {
    key: "removeAnnotation",
    value: function removeAnnotation(element) {
      if (this.interactive) {
        this.annotationService.remove(element);
      }
    }
    /**
     * Adds or removes an annotation depending on the locations highlight status.
     * Expects { target: Element, render: Function, d: Object (opt) }
     * d is stored at the Annotation and passed to the render function.
     * @param {TooltipOptions} options
     */

  }, {
    key: "toggleAnnotation",
    value: function toggleAnnotation(options) {
      if (!this.interactive) {
        return;
      }

      if (this.isAnnotationVisible(options.d.id)) {
        this.annotationService.add(options);
      } else {
        this.annotationService.remove(options.target);
      }
    } // Highlight service shortcuts
    // ---------------------------

    /**
     * @param {Element} element
     * @param {IdAndName} d
     */

  }, {
    key: "updateHighlight",
    value: function updateHighlight(element, d) {
      return this.highlightService.update(element, d.id);
    }
    /**
     * @param {string} id
     */

  }, {
    key: "toggleHighlight",
    value: function toggleHighlight(id) {
      return this.highlightService.toggle(id);
    } // Highlight query methods
    // -----------------------

    /**
     * Returns whether a location is a foreground location
     * i.e. the location is highlighted or baseline comparison.
     */

  }, {
    key: "isForegroundLocation",
    value: function isForegroundLocation(id) {
      return this.highlightService.isHighlighted(id) || this.highlightService.isBaselineComparison(id);
    }
    /**
     * Returns whether a location is a background location
     * i.e. there are highlights and this location is not highlighted.
     */

  }, {
    key: "isBackgroundLocation",
    value: function isBackgroundLocation(id) {
      return this.highlightService.hasHighlightedLocations() && !this.isForegroundLocation(id);
    }
  }, {
    key: "isAnnotationVisible",
    value: function isAnnotationVisible(id) {
      return this.areAnnotationsVisible && (this.highlightService.isBaselineComparison(id) && !this.highlightService.hasHighlightedLocations() || this.highlightService.isHighlighted(id));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      this.highlightService.dispose();

      if (this.interactive) {
        this.interactiveTooltipService.dispose();
      }

      if (this.interactive) {
        this.annotationService.dispose();
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(InteractiveChart.prototype), "dispose", this).call(this);
    }
  }]);
  return InteractiveChart;
}(BaseChart); // Method binding
// --------------


InteractiveChart.prototype.boundMethods = ['d3EventHandler', 'eventHandler', 'itemTap', 'itemPress'];
/**
 * Whether events are handled. Set to false to disable interactivity.
 */

InteractiveChart.prototype.interactive = true;
InteractiveChart.prototype.annotationModes = ANNOTATION_MODES;
/** @type {import('../types/types').Dependents} */

InteractiveChart.prototype.dependents = {
  areAnnotationsVisible: {
    after: ['mode'],
    recipe: function recipe() {
      return this.annotationModes.indexOf(this.mode) >= 0;
    }
  }
}; // Disposal
// --------

InteractiveChart.prototype.disposedProperties = ['highlightService', 'tooltipService', 'annotationService'];
module.exports = InteractiveChart;

},{"../util/chart":119,"../vendor/hammer-2.0.4.js":149,"./annotation-service":36,"./base-chart":40,"./highlight-service":48,"./interactive-tooltip-service":50,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"d3":27,"jquery":"jquery"}],50:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var Backbone = require('backbone');

var TooltipService = require('./tooltip-service');

var InteractiveTooltip = require('./interactive-tooltip'); // Service for managing interactive tooltips that are shown on hover/touch.
// Ensures that only one tooltip is in the hover state.


var InteractiveTooltipService = /*#__PURE__*/function (_TooltipService) {
  (0, _inherits2.default)(InteractiveTooltipService, _TooltipService);

  var _super = _createSuper(InteractiveTooltipService);

  function InteractiveTooltipService() {
    (0, _classCallCheck2.default)(this, InteractiveTooltipService);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(InteractiveTooltipService, [{
    key: "_add",
    value: // Property declarations
    // ---------------------
    //
    // hoverTooltip: Tooltip
    //   The tooltip that is currently hovered.
    function _add(options) {
      var tooltip = (0, _get2.default)((0, _getPrototypeOf2.default)(InteractiveTooltipService.prototype), "_add", this).call(this, options);
      this.listenTo(tooltip, 'hoverEnter', this.hoverEnterHandler);
      this.listenTo(tooltip, 'hoverLeave', this.hoverLeaveHandler);
      return tooltip;
    } // Tooltip event handling
    // ----------------------
    //
    // Keep track of the tooltip that is currently hovered.
    // Ensure that there is only one hovered tooltip.

  }, {
    key: "hoverEnterHandler",
    value: function hoverEnterHandler(tooltip) {
      if (this.hoverTooltip) {
        this.hoverTooltip.endHover();
      }

      this.hoverTooltip = tooltip;
    }
  }, {
    key: "hoverLeaveHandler",
    value: function hoverLeaveHandler() {
      delete this.hoverTooltip;
    } // Removes the current hover if any.

  }, {
    key: "endHover",
    value: function endHover() {
      if (this.hoverTooltip) {
        this.hoverTooltip.endHover();
      }

      delete this.hoverTooltip;
    } // Disposal
    // --------

  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(InteractiveTooltipService.prototype), "dispose", this).call(this);
      this.stopListening();
      delete this.hoverTooltip;
    }
  }]);
  return InteractiveTooltipService;
}(TooltipService);

_.assign(InteractiveTooltipService.prototype, Backbone.Events);

InteractiveTooltipService.prototype.boundMethods = ['hoverEnterHandler', 'hoverLeaveHandler'];
InteractiveTooltipService.prototype.tooltipConstructor = InteractiveTooltip;
module.exports = InteractiveTooltipService;

},{"./interactive-tooltip":51,"./tooltip-service":64,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"backbone":"backbone","lodash":"lodash"}],51:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var Backbone = require('backbone');

var animation = require('../util/animation');

var Tooltip = require('./tooltip'); // Tooltip that provides handlers for mouse and touch interaction
//
// Does not attach event handlers directly but relies on the central event
// dispatching.
//
// Expects the data object d and a render function. When the tooltip
// is shown, the render function is called with the data object. It should
// produce HTML code which is shown in the tooltip.
//
// Triggers hoverEnter and hoverLeave events.
// Constants
// ---------
// In interactive mode (mouse over, tap), position the tooltip
// with a slight offset against the event position


var TARGET_DISTANCE = 5;

var InteractiveTooltip = /*#__PURE__*/function (_Tooltip) {
  (0, _inherits2.default)(InteractiveTooltip, _Tooltip);

  var _super = _createSuper(InteractiveTooltip);

  function InteractiveTooltip() {
    (0, _classCallCheck2.default)(this, InteractiveTooltip);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(InteractiveTooltip, [{
    key: "tapHandler",
    value: // Property declarations
    // ---------------------
    //
    // Modes:
    //      hoverMode: Boolean
    //    showDelay: Number
    // setTimeout handle
    // showHandle: Number
    //   setTimeout handle
    // positionHandle: Number
    //   requestAnimationFrame handle
    // nextPosition: { x: Number, y: Number, pointerType: String }
    //   Saves the next position for hover mode.
    // Event handling
    // --------------
    // These methods are called from the central event dispatcher.
    function tapHandler(event) {
      this.bringToFront(); // Only start hover on touch events

      if (event.pointerType !== 'touch') {
        return;
      }

      var point = _.last(event.pointers);

      this.startHover({
        x: point.pageX,
        y: point.pageY
      });
    }
  }, {
    key: "mouseenterHandler",
    value: function mouseenterHandler(event) {
      this.bringToFront(); // Show the tooltips with a slight delay. This prevents visual flicker
      // when hovering over a number of chart element.

      this.startHover({
        x: event.pageX,
        y: event.pageY,
        delay: this.showDelay
      });
    }
  }, {
    key: "mousemoveHandler",
    value: function mousemoveHandler(event) {
      if (!this.hoverMode) {
        return;
      }

      this.nextPosition = {
        x: event.pageX,
        y: event.pageY
      }; // Position immediately if the delay isnt active

      if (!this.showHandle) {
        this.applyNextPositionInNextFrame();
      }
    }
  }, {
    key: "mouseleaveHandler",
    value: function mouseleaveHandler() {
      this.removeFromFront();
      this.endHover();
    } // Hover mode
    // ----------
    // Enter the hover mode
    // Expects { x: Number, y: Number, pointerType: String delay: Number (opt) }
    // x and y are the raw mouse/tap coordinates relative to the document
    // Emits a hoverEnter event

  }, {
    key: "startHover",
    value: function startHover(options) {
      if (this.hoverMode) {
        return;
      }

      this.hoverMode = true;
      this.trigger('hoverEnter', this);
      this.nextPosition = {
        x: options.x,
        y: options.y
      };

      if (options.delay) {
        clearTimeout(this.showHandle);
        this.showHandle = setTimeout(this.applyNextPositionInNextFrame, options.delay);
      } else {
        this.applyNextPositionInNextFrame();
      }
    } // Leave the hover mode
    // Emits a hoverLeave event

  }, {
    key: "endHover",
    value: function endHover() {
      if (!this.hoverMode) {
        return;
      }

      this.hoverMode = false;
      this.trigger('hoverLeave', this);
      this.clearHandles();
      this.removeElement();
    }
  }, {
    key: "applyNextPositionInNextFrame",
    value: function applyNextPositionInNextFrame() {
      delete this.showHandle;

      if (this.positionHandle) {
        animation.cancelAnimationFrame(this.positionHandle);
      }

      this.positionHandle = animation.requestAnimationFrame(this.applyNextPosition);
    } // Move the tooltip to the saved this.nextPosition,
    // corrected by container offset.

  }, {
    key: "applyNextPosition",
    value: function applyNextPosition() {
      this.createElement(); // nextPosition is relative to the document, but the tooltip
      // is positioned relative to the container

      var containerOffset = this.container.offset();
      var x = this.nextPosition.x - containerOffset.left;
      var y = this.nextPosition.y - containerOffset.top; // Determine placement

      var halfContainerWidth = this.container.width() / 2;
      var xPlacement = x < halfContainerWidth ? 'right' : 'left';
      var thirdContainerHeight = this.container.height() / 4;
      var yPlacement = y < thirdContainerHeight ? 'bottom' : y < thirdContainerHeight * 2 ? 'center' : 'top';
      this.setPlacement(xPlacement, yPlacement); // Move tooltip away from pointer

      if (yPlacement === 'bottom') {
        y += TARGET_DISTANCE * 3;
      } else if (yPlacement === 'top') {
        y -= TARGET_DISTANCE;
      } else if (xPlacement === 'right') {
        x += TARGET_DISTANCE;
      } else {
        x -= TARGET_DISTANCE;
      }

      this.calculatePositionAt(x, y);
      this.applyPosition();
    }
  }, {
    key: "clearHandles",
    value: function clearHandles() {
      if (this.showHandle) {
        clearTimeout(this.showHandle);
        delete this.showHandle;
      }

      if (this.positionHandle) {
        animation.cancelAnimationFrame(this.positionHandle);
        delete this.positionHandle;
      }
    } // Disposal
    // --------

  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(InteractiveTooltip.prototype), "dispose", this).call(this);
      this.clearHandles();
    }
  }]);
  return InteractiveTooltip;
}(Tooltip);

_.assign(InteractiveTooltip.prototype, Backbone.Events);

InteractiveTooltip.prototype.boundMethods = ['applyNextPositionInNextFrame', 'applyNextPosition'];
InteractiveTooltip.prototype.hoverMode = false;
InteractiveTooltip.prototype.showDelay = 200;
module.exports = InteractiveTooltip;

},{"../util/animation":117,"./tooltip":66,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"backbone":"backbone","lodash":"lodash"}],52:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BaseLineChart = require('./base-line-chart');

var ChartLabels = require('./chart-labels');

var LineChart = /*#__PURE__*/function (_BaseLineChart) {
  (0, _inherits2.default)(LineChart, _BaseLineChart);

  var _super = _createSuper(LineChart);

  function LineChart() {
    (0, _classCallCheck2.default)(this, LineChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(LineChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(LineChart.prototype), "initialize", this).call(this, options);
      var labels = this.base.append('g').classed('chart-labels', true);
      this.attach('labels', new ChartLabels(labels, {
        model: this.model,
        x: this.x,
        xAxis: this.xAxis,
        yAxis: this.yAxis,
        interactiveTooltipService: this.interactiveTooltipService,
        showForecastMarker: true
      }));
      this.lineGroups = this.base.append('g').classed("".concat(this.itemClass, "s"), true);
      this.layer('lines', this.lineGroups, this.linesLayerConfig);
    }
  }, {
    key: "applyDependents",
    value: function applyDependents(data) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(LineChart.prototype), "applyDependents", this).call(this, data);
      this.lineGroups.attr({
        transform: "translate(".concat(this.paddingLeft, ", ").concat(this.paddingTop, ")")
      });
    }
  }]);
  return LineChart;
}(BaseLineChart);

module.exports = LineChart;

},{"./base-line-chart":41,"./chart-labels":44,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],53:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var I18n = require('../i18n');

var _require = require('../util/chart'),
    hasValue = _require.hasValue,
    idKey = _require.idKey,
    selector = _require.selector;

var BaseLineChart = require('./base-line-chart');

var ChartLabels = require('./chart-labels');

var tooltipTemplates = require('./tooltip-templates');

var _require2 = require('./tooltip-templates'),
    locationSubject = _require2.locationSubject;
/** @typedef {import('../types/types').DataPoint} DataPoint */

/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').Dependents} Dependents */

/**
 * @typedef {{
 * id: string,
 * name: string,
 * locationId: string,
 * locationName: string,
 * values: DataPoint[],
 * latestValue: DataPoint | undefined,
 * }} LineMultipleSubjectsDatum
 */

/** @typedef {LineMultipleSubjectsDatum[]} LineMultipleSubjectsData */
// Constants
// ---------
// Show the annotations in these modes


var ANNOTATION_MODES = ['reduced', 'normal', 'big', 'large']; // Classes
// -------

var CLASS_NAME = 'line-multiple-subjects-chart';
var LINE_GROUP_CLASS = 'line-group';
var LINE_CLASS = 'line';
var LINE_DESC_CLASS = 'line-desc';
var LINE_INTERPOLATOR_CLASS = 'line-interpolator';
var LINE_HOVER_HELPER_CLASS = 'line-hover-helper';
var MARKERS_CLASS = 'markers';
var MARKER_DOT_CLASS = 'marker-dot';
var LINE_ANNOTATION_TARGET_CLASS = 'line-annotation-target'; // The class of the element that represents a datum

var ITEM_CLASS = LINE_GROUP_CLASS;

var LineMultipleSubjectsChart = /*#__PURE__*/function (_BaseLineChart) {
  (0, _inherits2.default)(LineMultipleSubjectsChart, _BaseLineChart);

  var _super = _createSuper(LineMultipleSubjectsChart);

  function LineMultipleSubjectsChart(selection, options) {
    var _this;

    (0, _classCallCheck2.default)(this, LineMultipleSubjectsChart);
    _this = _super.call(this, selection, options);
    /** @type {LineMultipleSubjectsData} */

    _this.subjectsWithValuesForFirstLocation;
    return _this;
  }

  (0, _createClass2.default)(LineMultipleSubjectsChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(LineMultipleSubjectsChart.prototype), "initialize", this).call(this, options);
      this.base.classed(CLASS_NAME, true);
      var labels = this.base.append('g').classed('chart-labels', true);
      this.attach('labels', new ChartLabels(labels, {
        model: this.model,
        x: this.x,
        xAxis: this.xAxis,
        yAxis: this.yAxis,
        interactiveTooltipService: this.interactiveTooltipService,
        showForecastMarker: true
      }));
      this.lineGroups = this.base.append('g').classed("".concat(this.itemClass, "s"), true);
      this.layer('lines', this.lineGroups, this.subjectLinesLayerConfig);
    }
  }, {
    key: "applyDependents",
    value: function applyDependents(data) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(LineMultipleSubjectsChart.prototype), "applyDependents", this).call(this, data);
      this.lineGroups.attr({
        transform: "translate(".concat(this.paddingLeft, ", ").concat(this.paddingTop, ")")
      });
    } // Event handling
    // --------------
    // Override method from InteractiveChart, remove the highlighting behavior

  }, {
    key: "itemTap",
    value: function itemTap(event, item) {
      if (event.pointerType === 'touch') {
        // Touch tap: Add hover class, remove from other items
        this.leaveAllItemsHover();
        this.enterItemHover(item);
      }
    } // Override method from InteractiveChart, remove the highlighting behavior

  }, {
    key: "itemPress",
    value: function itemPress() {// Do nothing
    } // Tooltip content
    // ---------------
    // Line tooltip
    // ------------

    /**
     * @param {LineMultipleSubjectsDatum} d
     */

  }, {
    key: "lineTooltipContent",
    value: function lineTooltipContent(d) {
      return locationSubject.render(this.lineTooltipData(d));
    }
    /**
     * @param {LineMultipleSubjectsDatum} d
     */

  }, {
    key: "lineTooltipData",
    value: function lineTooltipData(d) {
      return {
        location: d.locationName,
        subject: d.name
      };
    } // Marker tooltip
    // --------------

    /**
     * @param {DataPoint} d
     */

  }, {
    key: "markerTooltipContent",
    value: function markerTooltipContent(d) {
      return tooltipTemplates.fullWithSubject.render(this.markerTooltipData(d));
    }
    /**
     * @param {DataPoint} d
     */

  }, {
    key: "markerTooltipData",
    value: function markerTooltipData(d) {
      /** @type {{ abbr: string, description: string } | null} */
      var obsInfo = d.status ? I18n.t('observationStatus')[d.status.id] : null;
      return {
        location: d.name,
        timePeriod: d.timePeriodName,
        subject: d.subjectName,
        value: this.formatLabel(d.value),
        measure: this.measure.name,
        observationStatusAbbr: obsInfo ? obsInfo.abbr : null,
        observationStatusDescription: obsInfo ? obsInfo.description : null
      };
    } // Line annotation
    // ---------------

  }, {
    key: "isAnnotationVisible",
    value: function isAnnotationVisible() {
      return this.areAnnotationsVisible;
    }
    /**
     * @param {LineMultipleSubjectsDatum} d
     */

  }, {
    key: "lineAnnotationContent",
    value: function lineAnnotationContent(d) {
      return tooltipTemplates.subject.render(this.lineAnnotationData(d));
    }
    /**
     * @param {LineMultipleSubjectsDatum} d
     */

  }, {
    key: "lineAnnotationData",
    value: function lineAnnotationData(d) {
      return {
        subject: d.subjectName
      };
    } // Highlighting
    // ------------

    /**
     * Updates the highlight class for a given element.
     * Sets highlight-{1..n} and is-highlighted classes.
     *
     * @param {Element} element
     * @param {number} subjectIndex
     */

  }, {
    key: "updateHighlight",
    value: function updateHighlight(element, subjectIndex) {
      var classes = {
        'is-highlighted': true
      };
      var highlightLimit = this.model.get('highlightLimit');

      for (var i = 1, end = highlightLimit; i <= end; i++) {
        classes["highlight-".concat(i)] = i === subjectIndex + 1;
      }

      d3.select(element).classed(classes);
    }
  }]);
  return LineMultipleSubjectsChart;
}(BaseLineChart);

LineMultipleSubjectsChart.prototype.annotationModes = ANNOTATION_MODES; // Dependents
// ----------

/** @type {import('../types/types').Dependents<RawChartData, LineMultipleSubjectsChart>} */

LineMultipleSubjectsChart.prototype.dependents = {
  // Overwrite InteractiveChart dependent, check for mode and width
  areAnnotationsVisible: {
    after: ['width', 'mode'],
    recipe: function recipe() {
      return this.width > 250 && this.annotationModes.indexOf(this.mode) >= 0;
    }
  },
  subjectsWithValuesForFirstLocation: {
    recipe: function recipe(data) {
      /** @type {LineMultipleSubjectsData} */
      var result = data.subjectsWithValues.map(function (subjectWithValues) {
        var location = subjectWithValues.locationsWithValues[0];
        /** @type {LineMultipleSubjectsDatum} */

        return {
          id: subjectWithValues.id,
          name: subjectWithValues.name,
          locationId: location.id,
          locationName: location.name,
          values: location.values,
          latestValue: _.findLast(location.values, hasValue)
        };
      });
      return result;
    }
  },
  // The extent of the visualized data as [min: Number, max: Number]
  dataExtent: {
    after: ['subjectsWithValuesForFirstLocation'],
    recipe: function recipe() {
      var subjectsWithValuesForFirstLocation = this.subjectsWithValuesForFirstLocation; // Aggregate values of all subjects

      /** @type number[] */

      var allValues = [];
      subjectsWithValuesForFirstLocation.forEach(function (datum) {
        datum.values.forEach(function (dataPoint) {
          allValues.push(dataPoint.value);
        });
      });
      return d3.extent(allValues);
    }
  }
}; // Layers
// ------

/**
 * @type {import('../types/types').DataBoundLayerOptions<
 * LineMultipleSubjectsDatum,
 * LineMultipleSubjectsDatum,
 * LineMultipleSubjectsChart
 * >}
 */

LineMultipleSubjectsChart.prototype.subjectLinesLayerConfig = {
  // Context: the layer base (g.line-groups element)
  // Returns: bound selection with g.line-group
  dataBind: function dataBind() {
    var chart = this.chart();
    return this.selectAll(selector(ITEM_CLASS)).data(chart.subjectsWithValuesForFirstLocation, idKey);
  },
  // Context: Bound selection with g.line-group
  // Returns: Bound selection with g.line-group
  insert: function insert() {
    return this.append('g').attr('class', ITEM_CLASS);
  },
  events: {
    // Context: Entering selection with g.lineGroup
    enter: function enter() {
      // Transparent circle that sits on the end of the line and
      // serves as target for the annotation
      this.append('circle').attr('class', LINE_ANNOTATION_TARGET_CLASS); // First line: Main visible line

      this.append('path').attr('class', LINE_CLASS) // Accessible description
      .append('desc').attr('class', LINE_DESC_CLASS); // Second line: Dashed interpolator segments

      this.append('path').attr('class', LINE_INTERPOLATOR_CLASS); // Third line: Transparent hover helper for mouse/touch interaction
      // Draw a continuous line ignoring undefined values

      this.append('path').attr('class', LINE_HOVER_HELPER_CLASS); // Marker dots

      this.append('g').attr('class', MARKERS_CLASS);
    },
    // Context: Bound selection with g.line-group
    merge: function merge() {
      var chart = this.chart(); // Line annotation target

      this.select(selector(LINE_ANNOTATION_TARGET_CLASS)).attr('r', function () {
        return chart.markerDotsVisible ? chart.markerDotRadius : 3;
      }).attr('cx', function (d) {
        return d.latestValue ? chart.x(d.latestValue.date) : 0;
      }).attr('cy', function (d) {
        return d.latestValue ? chart.y(d.latestValue.value) : 0;
      }).each(function (d) {
        chart.toggleLineAnnotation(this, d);
      }); // Lines
      // -----
      // First line: Main visible line

      this.select(selector(LINE_CLASS)).attr('d', chart.linePath); // First line: Accessible description

      this.select(selector(LINE_DESC_CLASS)).text(function (d) {
        return d.subjectName;
      }); // Second line: Dashed interpolator segments
      // through undefined data points

      this.select(selector(LINE_INTERPOLATOR_CLASS)).attr('d', chart.dashedLinePath); // Third line: Transparent hover helper for mouse/touch interaction

      this.select(selector(LINE_HOVER_HELPER_CLASS)).attr('d', chart.hoverHelperPath).each(function (d) {
        chart.addLineTooltip(this, d);
      });
      this.each(function (d, index) {
        // Highlight the line group
        chart.updateHighlight(this, index); // Markers for defined values

        var definedValues = d.values.filter(hasValue);
        chart.createOrUpdateMarkers(this, definedValues, []);
      });
    },
    // Context: Exiting selection
    exit: function exit() {
      var chart = this.chart(); // Remove tooltips and annotation

      this.select(selector(LINE_ANNOTATION_TARGET_CLASS)).each(function () {
        chart.removeAnnotation(this);
      });
      this.select(selector(LINE_HOVER_HELPER_CLASS)).each(function () {
        chart.removeTooltip(this);
      });
      this.selectAll(selector(MARKER_DOT_CLASS)).each(function () {
        chart.removeTooltip(this);
      });
      this.remove();
    }
  }
};
module.exports = LineMultipleSubjectsChart;

},{"../i18n":82,"../util/chart":119,"./base-line-chart":41,"./chart-labels":44,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"d3":27,"lodash":"lodash"}],54:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BaseChart = require('./base-chart');

var _require = require('../util/chart'),
    selector = _require.selector;

var I18n = require('../i18n');
/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').IdAndName} IdAndName */

/** @typedef {import('../types/types').LocationWithValues} LocationWithValues */

/** @typedef {import('../types/types').LocationsWithValues} LocationsWithValues */

/** @typedef {import('./highlight-service')} HighlightService */
// Constants
// ---------


var BASE_CLASS = 'locations-label';
var LOCATION_LABEL_CLASS = 'location-label';
/**
 * Attached chard for drawing the rotated location labels for the x axis
 */

var LocationLabels = /*#__PURE__*/function (_BaseChart) {
  (0, _inherits2.default)(LocationLabels, _BaseChart);

  var _super = _createSuper(LocationLabels);

  function LocationLabels() {
    (0, _classCallCheck2.default)(this, LocationLabels);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(LocationLabels, [{
    key: "initialize",
    value:
    /**
     * @param {{
     * model: import('../models/chart-data'),
     * x: d3.scale.Ordinal<string, number>,
     * xAxisModes: string[],
     * highlightService: HighlightService,
     * dataForLocationLabels: (data: RawChartData) => IdAndName[],
     * isLabelVisible: (locationWithValues: LocationWithValues) => boolean,
     * highlightLocationLabels: boolean
     * }} options
     */
    function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(LocationLabels.prototype), "initialize", this).call(this, options);
      this.x = options.x;
      this.xAxisModes = options.xAxisModes;
      this.highlightService = options.highlightService;
      this.dataForLocationLabels = options.dataForLocationLabels;
      this.isLabelVisible = options.isLabelVisible;
      this.highlightLocationLabels = options.highlightLocationLabels;
    }
    /**
     * @param {RawChartData} data
     */

  }, {
    key: "draw",
    value: function draw(data) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(LocationLabels.prototype), "draw", this).call(this, data); // Data bind
      // ---------

      var dataForLabels = this.dataForLocationLabels(data);
      /** @type {d3.selection.Update<IdAndName>} */

      var labels = this.base.selectAll(selector(LOCATION_LABEL_CLASS)).data(dataForLabels);
      var showLabels = this.xAxisModes.indexOf(this.mode) >= 0; // Enter
      // -----

      labels.enter().append('text').attr('class', LOCATION_LABEL_CLASS); // Merge
      // -----

      labels.text(I18n.shortLocation).style('display', showLabels ? '' : 'none');

      if (showLabels) {
        this.positionLabels(labels);

        if (this.highlightLocationLabels) {
          var chart = this;
          labels.each(function (locationWithValues) {
            chart.highlightService.update(this, locationWithValues.id);
          });
        }
      } // Exit
      // ----


      labels.exit().remove();
    }
    /**
     * Rotate and position the labels (text elements)
     *
     * @param {d3.selection.Update<LocationsWithValues>} labels
     */

  }, {
    key: "positionLabels",
    value: function positionLabels(labels) {
      var chart = this;
      labels // Reading and setting are separated to prevent layout thrashing
      // Read heights in one batch, compute properties
      .property({
        ddp_computedHeight: function ddp_computedHeight() {
          return this.getBBox().height;
        },
        ddp_x: function ddp_x(d) {
          return chart.x(d.id) + chart.x.rangeBand() / 2 + this.ddp_computedHeight / 2;
        },
        ddp_y: function ddp_y() {
          return this.ddp_computedHeight;
        }
      }) // Apply properties in one batch
      .attr({
        x: function x() {
          return this.ddp_x;
        },
        y: function y() {
          return this.ddp_y;
        },
        // Rotate by 45 degrees to prevent overlaps
        transform: function transform() {
          // Read the result of x and y
          return "rotate(-45 ".concat(this.ddp_x, " ").concat(this.ddp_y, ")");
        },
        visibility: function visibility(d) {
          return chart.isLabelVisible(d) ? 'visible' : 'hidden';
        }
      });
    }
  }]);
  return LocationLabels;
}(BaseChart);
/**
 * Static function to determine the height of the longest location label.
 * This value is used as marginBottom in the chart that uses LocationLabels.
 *
 * @param {d3.Selection<any>} base
 * @param {RawChartData} data
 */


var locationLabelHeight = function locationLabelHeight(base, data) {
  // Find the longest location label
  var locationNames = data.filteredLocationsWithValues.map(function (locationWithValues) {
    return I18n.shortLocation(locationWithValues);
  });
  /**
   * @param {string} result
   * @param {string} location
   */

  var findLongest = function findLongest(result, name) {
    return name.length > result.length ? name : result;
  };

  var longestName = locationNames.reduce(findLongest, ''); // Measure the height of the longest label. Create a hidden test element.

  var text = base.append('text').attr('class', LOCATION_LABEL_CLASS).text(longestName).style({
    visibility: 'hidden'
  });
  var boundingBox = text.node().getBBox();
  text.remove(); // Take 45 rotation into account

  var degrees = Math.PI / 4;
  var height = boundingBox.width * Math.sin(degrees) + boundingBox.height + 2;
  return height;
};
/**
 * @type {import('../types/types').Dependent<RawChartData, number, import('./padded-chart')>}
 */


var marginBottomDependent = {
  after: ['mode', 'height'],
  recipe: function recipe(data) {
    if (this.xAxisModes.indexOf(this.mode) >= 0) {
      var bottomLegendHeight = typeof this.bottomLegendHeight === 'number' ? this.bottomLegendHeight : 0;
      return locationLabelHeight(this.base, data) + bottomLegendHeight;
    } else {
      return 0;
    }
  }
}; // Make constant public

LocationLabels.BASE_CLASS = BASE_CLASS;
module.exports = {
  LocationLabels: LocationLabels,
  locationLabelHeight: locationLabelHeight,
  marginBottomDependent: marginBottomDependent
};

},{"../i18n":82,"../util/chart":119,"./base-chart":40,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],55:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var topojson = require('topojson');

require('../vendor/d3.geo.projection.van-der-grinten3.js');

var Hammer = require('../vendor/hammer-2.0.4.js');

var WORLD_MAP = require('../../data/world-capitals-110m.js');

var COUNTRY_NEIGHBORS = require('../../data/country-neighbors.js');

var LOCATION_GROUP_IDS = require('../constants/location-group-ids');

var _require = require('../util/chart'),
    absoluteExtremum = _require.absoluteExtremum,
    dataWithLastValue = _require.dataWithLastValue,
    dataWithLatestValue = _require.dataWithLatestValue,
    dValue = _require.dValue,
    hasValue = _require.hasValue,
    idKey = _require.idKey,
    singleDSelector = _require.singleDSelector,
    singleValueSelector = _require.singleValueSelector;

var mathUtil = require('../util/math');

var numberFormatter = require('../util/number-formatter');

var geom = require('../util/geom');

var timePeriodNavigation = require('../models/time-period-navigation');

var InteractiveChart = require('./interactive-chart');

var ChartLabels = require('./chart-labels');

var tooltipTemplates = require('./tooltip-templates');
/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {{
 * id: string,
 * name: string,
 * x: number,
 * y: number,
 * targetX: number,
 * targetY: number,
 * timePeriod: Date,
 * timePeriodName: string,
 * value: number,
 * radius: number
 * }} CountryPoint */

/** @typedef {CountryPoint[]} CountryPoints */

/** @typedef {{ source: CountryPoint, target: CountryPoint }} Link */

/** @typedef {Link[]} Links */

/*
The Map chart attributes quantities to countries on a map by placing circles
on or close to the country areas which possess a value. Circles are scaled so
that their area corresponds to the quantity in question. This means a sqrt
scale.

The chart accepts either all positive or all negative values. The behaviour
for data sets with mixed positive and negative values is the following:

- The extremum is determined
  (minimum or maximum, biggest absolute value wins)
- Only values possessing the sign of the extremum or 0 as their sign are
  displayed
*/
// Constants
// ---------
// The class of the element that represents a datum


var ITEM_CLASS = 'country-mark';
var MAP_TRANSLATE_X = 0.373;
var MAP_TRANSLATE_Y = 0.63; // Maximum marker size in pixels

var MIN_RADIUS = 1; // Maximum marker size in percent of the width

var MAX_RADIUS_PERCENT = 0.018;

var MapChart = /*#__PURE__*/function (_InteractiveChart) {
  (0, _inherits2.default)(MapChart, _InteractiveChart);

  var _super = _createSuper(MapChart);

  function MapChart() {
    (0, _classCallCheck2.default)(this, MapChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(MapChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(MapChart.prototype), "initialize", this).call(this, options);
      /** @type {CountryPoints} */

      this.countryPoints;
      /** @type {Links} */

      this.links;
      this.base.classed('map-chart', true);
      var labels = this.base.append('g').attr('class', 'chart-labels');
      this.attach('labels', new ChartLabels(labels, {
        model: this.model
      }));
      this.layer('worldMap', this.base.append('g').classed('world-map', true), this.worldMapLayerConfig);
      this.layer('countryMarks', this.base.append('g').classed("".concat(ITEM_CLASS, "s"), true), this.countryMarksLayerConfig);
    } // Data transformation
    // -------------------

    /**
     * @param {RawChartData} data
     */

  }, {
    key: "transform",
    value: function transform(data) {
      var _this = this;

      var transformed = this.model.get('useLatestData') ? dataWithLatestValue(data) : dataWithLastValue(data); // In small mode, show only highlighted and baseline

      var showForegroundLocationsOnly = this.model.get('mode') === 'small' && this.highlightService.hasHighlightedLocations();
      transformed.filteredLocationsWithValues = transformed.filteredLocationsWithValues.filter(function (locationWithValues) {
        return (// Filter out country groups.
          // They do not have a geo position and should not affect the scale.
          LOCATION_GROUP_IDS.indexOf(locationWithValues.id) === -1 && // Filter missing values
          hasValue(singleDSelector(locationWithValues)) && (!showForegroundLocationsOnly || _this.isForegroundLocation(locationWithValues.id))
        );
      });
      return transformed;
    } // Interaction
    // -----------

  }, {
    key: "initInteraction",
    value: function initInteraction() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(MapChart.prototype), "initInteraction", this).call(this);
      var h = this.hammerManager;
      h.add(new Hammer.Swipe({
        direction: Hammer.DIRECTION_HORIZONTAL
      }));
      h.on('swipeleft swiperight', _.debounce(this.touchNavigation, 300, {
        leading: true,
        trailing: false
      }));
    }
  }, {
    key: "touchNavigation",
    value: function touchNavigation(event) {
      switch (event.type) {
        case 'swipeleft':
          timePeriodNavigation.forward(this.model);
          break;

        case 'swiperight':
          timePeriodNavigation.back(this.model);
          break;
      }
    } // eslint-disable-next-line no-unused-vars

  }, {
    key: "layoutCountryPoints",
    value: function layoutCountryPoints(countryPoints, selection) {
      // geom.decollide (countryPoints, this.links, this.width, this.height, selection);
      geom.simpleDecollide(countryPoints, this.width, this.height);
    }
    /**
     * Returns whether a value has the sign of the extremum
     * and should be shown at all.
     */

  }, {
    key: "isDefined",
    value: function isDefined(value) {
      var sign = mathUtil.sign(value);
      return sign === 0 || sign === mathUtil.sign(this.extremum);
    } // Tooltips
    // --------

    /**
     * @param {CountryPoint} d
     */

  }, {
    key: "tooltipContent",
    value: function tooltipContent(d) {
      return tooltipTemplates.full.render({
        location: d.name,
        timePeriod: d.timePeriodName,
        value: this.formatLabel(d.value),
        measure: this.measure.name
      });
    }
  }]);
  return MapChart;
}(InteractiveChart); // Properties
// ----------


MapChart.prototype.animateLayout = false;
MapChart.prototype.itemClass = ITEM_CLASS; // Dependents
// ----------

/** @type {import('../types/types').Dependents<RawChartData, MapChart>} */

MapChart.prototype.dependents = {
  scale: {
    after: ['width', 'height'],
    recipe: function recipe() {
      if (this.width / this.height > 2.5) {
        // Fit vertically
        return this.height * 0.4;
      } else {
        // Fit horizontally
        return this.width * 0.205;
      }
    }
  },
  projection: {
    after: ['width', 'height', 'scale'],
    recipe: function recipe() {
      return d3.geo.vanDerGrinten3().translate([this.width * MAP_TRANSLATE_X, this.height * MAP_TRANSLATE_Y]).scale(this.scale);
    }
  },
  geoPath: {
    after: ['projection'],
    recipe: function recipe() {
      return d3.geo.path().projection(this.projection);
    }
  },
  extremum: {
    recipe: function recipe(data) {
      return absoluteExtremum(data.filteredLocationsWithValues, singleValueSelector);
    }
  },
  valueScale: {
    after: ['width', 'extremum'],
    initial: function initial() {
      return d3.scale.sqrt().nice();
    },
    recipe: function recipe(data, scale) {
      return scale.domain([0, this.extremum]).range([MIN_RADIUS, MAX_RADIUS_PERCENT * this.width]);
    }
  },
  // Whether the relevant data has changed. False on a minor redraw.
  // When the country points did not change, we can skip the expensive
  // layout calculation (decollision).
  dataChanged: {
    after: ['width', 'height'],
    recipe: function recipe(data) {
      // A cache string that contains all values.
      var linearizedData = "".concat(this.width, ":").concat(this.height);
      data.filteredLocationsWithValues.forEach(function (locationWithValue) {
        var d = singleDSelector(locationWithValue);
        linearizedData += "\n".concat(d.id, ":").concat(d.timePeriod, ":").concat(d.value);
      });
      var dataChanged = linearizedData !== this.linearizedData;
      this.linearizedData = linearizedData;
      return dataChanged;
    }
  },
  // Country points
  countryPoints: {
    after: ['dataChanged', 'width', 'height', 'projection', 'valueScale'],

    /**
     * @param {RawChartData} data
     * @param {CountryPoints} countryPoints
     */
    recipe: function recipe(data, countryPoints) {
      var _this2 = this;

      if (!this.dataChanged) {
        return countryPoints;
      }

      countryPoints = [];
      data.filteredLocationsWithValues.forEach(function (locationWithValue) {
        var countryCapital = _.find(WORLD_MAP.objects.capitals, {
          id: locationWithValue.id
        });

        if (!countryCapital) {
          return;
        }

        var _singleDSelector = singleDSelector(locationWithValue),
            value = _singleDSelector.value,
            timePeriod = _singleDSelector.timePeriod,
            timePeriodName = _singleDSelector.timePeriodName;

        if (!_this2.isDefined(value)) {
          return;
        }

        var _this2$projection = _this2.projection([countryCapital.long, countryCapital.lat]),
            _this2$projection2 = (0, _slicedToArray2.default)(_this2$projection, 2),
            x = _this2$projection2[0],
            y = _this2$projection2[1];

        countryPoints.push({
          id: locationWithValue.id,
          name: locationWithValue.name,
          x: x,
          y: y,
          targetX: x,
          targetY: y,
          timePeriod: timePeriod,
          timePeriodName: timePeriodName,
          value: value,
          radius: _this2.valueScale(value)
        });
      });
      return countryPoints;
    }
  },
  links: {
    after: ['dataChanged', 'countryPoints'],

    /**
     *
     * @param {RawChartData} data
     * @param {Link[]} links
     */
    recipe: function recipe(data, links) {
      var _this3 = this;

      if (!this.dataChanged) {
        return links;
      }

      links = [];
      this.countryPoints.forEach(function (countryPoint) {
        var neighbors = COUNTRY_NEIGHBORS[countryPoint.id];

        if (!neighbors) {
          return;
        }

        neighbors.forEach(function (id) {
          var other = _.find(_this3.countryPoints, {
            id: id
          });

          if (other) {
            links.push({
              source: countryPoint,
              target: other
            });
          }
        });
      });
      return links;
    }
  },
  measure: {
    recipe: function recipe(data) {
      return data.measure;
    }
  },
  countryPointValues: {
    after: ['countryPoints'],
    recipe: function recipe() {
      return this.countryPoints.map(dValue);
    }
  },
  formatLabel: {
    after: ['countryPointValues'],
    recipe: function recipe() {
      return numberFormatter.labelFormatter(this.countryPointValues, false, true);
    }
  }
}; // World map layer
// ---------------

MapChart.prototype.worldMapLayerConfig = {
  dataBind: function dataBind() {
    var land = topojson.feature(WORLD_MAP, WORLD_MAP.objects.land);
    return this.selectAll('.land').data([land]);
  },
  insert: function insert() {
    return this.append('path').classed('land', true);
  },
  events: {
    merge: function merge() {
      this.attr('d', this.chart().geoPath);
    }
  }
}; // Country marks layer
// -------------------

/** @type {import('../types/types').LayerOptions<RawChartData, CountryPoint, MapChart>} */

MapChart.prototype.countryMarksLayerConfig = {
  dataBind: function dataBind() {
    var chart = this.chart();
    var countryPoints = chart.countryPoints;
    var selection = this.selectAll(".".concat(ITEM_CLASS)).data(countryPoints, idKey);

    if (chart.dataChanged) {
      if (chart.animateLayout) {
        chart.layoutCountryPoints(countryPoints, selection);
      } else {
        chart.layoutCountryPoints(countryPoints);
      }
    }

    return selection;
  },
  insert: function insert() {
    return this.append('g').attr('class', ITEM_CLASS);
  },
  events: {
    enter: function enter() {
      this.append('circle').attr('class', 'marker-dot') // Accessible description
      .append('desc').attr('class', 'marker-dot-desc');
      this.append('text').attr('class', 'marker-label').attr('text-anchor', 'middle').attr('y', 3) // Hide the marker for screen readers, theres a better fallback
      .attr('aria-hidden', 'true');
    },
    merge: function merge() {
      var chart = this.chart();
      this.attr('data-id', idKey).attr('transform', function (d) {
        return "translate(".concat(d.x, ", ").concat(d.y, ")");
      }).each(function (d) {
        chart.updateHighlight(this, d);
        chart.addTooltip({
          target: this,
          render: chart.tooltipContent,
          d: d
        });
        chart.toggleAnnotation({
          target: this,
          render: function render(d2) {
            return d2.name;
          },
          d: d
        });
      }); // Circle

      this.select('.marker-dot').attr('r', function (d) {
        return d.radius;
      }); // Accessible description

      this.select('.marker-dot-desc').text(function (d) {
        var timePeriod = d.timePeriodName;
        var value = chart.formatLabel(d.value);
        var measure = chart.measure.name;
        return "".concat(d.name, ", ").concat(timePeriod, ": ").concat(value, " ").concat(measure);
      }); // Label

      this.select('.marker-label').text(function (d) {
        if (d.radius > 15) {
          return chart.formatLabel(d.value);
        } else {
          return '';
        }
      });
    },
    exit: function exit() {
      var chart = this.chart();
      this.each(function () {
        chart.removeTooltip(this);
        chart.removeAnnotation(this);
      });
      this.remove();
    }
  }
};
MapChart.prototype.boundMethods = ['touchNavigation', 'tooltipContent']; // Disposal
// --------

MapChart.prototype.disposedProperties = ['linearizedData'];
module.exports = MapChart;

},{"../../data/country-neighbors.js":33,"../../data/world-capitals-110m.js":34,"../constants/location-group-ids":73,"../models/time-period-navigation":114,"../util/chart":119,"../util/geom":127,"../util/math":132,"../util/number-formatter":135,"../vendor/d3.geo.projection.van-der-grinten3.js":148,"../vendor/hammer-2.0.4.js":149,"./chart-labels":44,"./interactive-chart":49,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/slicedToArray":20,"d3":27,"lodash":"lodash","topojson":"topojson"}],56:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var d3 = require('d3');

var ASPECT_RATIO = require('../constants/aspect-ratio');

var _require = require('../util/chart'),
    selector = _require.selector;

var BaseLineChart = require('./base-line-chart');

var chartMode = require('./chart-mode');

var ChartLabels = require('./chart-labels');

var AnnotationService = require('./annotation-service');

var tooltipTemplates = require('./tooltip-templates');
/** @typedef {import('../types/types').RawChartData} RawChartData */
// Constants
// ---------
// Fixed number of columns if the container size is <= threshold


var LIMIT_THRESHOLD = 360;
var CELLSPACING = 2; // The DOM attribute in which the tooltip data is stored as JSON

var TOOLTIP_ATTRIBUTE = 'data-tooltip'; // Show the annotations in these modes

var ANNOTATION_MODES = ['reduced', 'normal', 'big', 'large']; // Classes
// -------

var CLASS_NAME = 'multiple-line-chart';
var CONTAINER_CLASS = 'multiple-line-chart-container';
var INSTANCE_CLASSES = 'svg-chart multiple-line-chart-instance';
var LAST_COLUMN_CLASS = 'last-column';
var LAST_ROW_CLASS = 'last-row';

var MultipleLineChart = /*#__PURE__*/function (_BaseLineChart) {
  (0, _inherits2.default)(MultipleLineChart, _BaseLineChart);

  var _super = _createSuper(MultipleLineChart);

  function MultipleLineChart() {
    (0, _classCallCheck2.default)(this, MultipleLineChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(MultipleLineChart, [{
    key: "initialize",
    value: function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(MultipleLineChart.prototype), "initialize", this).call(this, options);
      this.$container().classed(CONTAINER_CLASS, true);
      this.base.classed(CLASS_NAME, true);
    } // Override the TooltipService creation to force placement

  }, {
    key: "initAnnotationService",
    value: function initAnnotationService() {
      this.annotationService = new AnnotationService({
        container: this.container(),
        forcedPlacement: {
          x: 'left',
          y: 'center'
        }
      });
    } // Visibility
    // ----------

  }, {
    key: "isVisible",
    value: function isVisible(id) {
      // Only show lines that are highlighted or baseline
      return this.isForegroundLocation(id);
    } // Background lines arent visible, so no background-line class necessary

  }, {
    key: "isBackgroundLocation",
    value: function isBackgroundLocation() {
      return false;
    } // Line labels are never visible

  }, {
    key: "isLocationLabelVisible",
    value: function isLocationLabelVisible() {
      return false;
    } // Override base size setting

  }, {
    key: "setBaseSize",
    value: function setBaseSize() {} // Empty. Do not force a fixed size since the chart height may grow.
    // Drawing
    // -------

  }, {
    key: "draw",
    value: function draw(data) {
      var _this = this;

      (0, _get2.default)((0, _getPrototypeOf2.default)(MultipleLineChart.prototype), "draw", this).call(this, data);
      this.reset(); // Create original chart

      var original = this.original(data); // Create instances off-DOM

      var instances = this.highlightedLocations.map(function (locationWithValues, index) {
        return _this.instance(original, locationWithValues, index);
      }); // Append them to the DOM in one go

      var baseNode = this.base.node();

      for (var i = 0, l = instances.length; i < l; i++) {
        var svg = instances[i];
        baseNode.appendChild(svg.node());
      }
    } // Resets the chart so it can be drawn from scratch

  }, {
    key: "reset",
    value: function reset() {
      // Empty the element
      this.base.html(''); // Override the chart mode class.
      // Normally the mode class reflects the full chart size,
      // here it needs to reflect the instance size.

      chartMode.setClass(this.container(), this.mode); // Remove all existing tooltips and annotations

      if (this.interactiveTooltipService) {
        this.interactiveTooltipService.removeAll();
      }

      if (this.annotationService) {
        this.annotationService.removeAll();
      } // Throw away all existing layers


      this._layers = [];
    } // Creates an original chart off-DOM that is cloned
    // to create the small multiples.

  }, {
    key: "original",
    value: function original(data) {
      var svg = document.createElementNS(d3.ns.prefix.svg, 'svg');
      svg = d3.select(svg).attr({
        class: INSTANCE_CLASSES,
        width: this.tickWidth,
        height: this.tickHeight
      }); // Chart labels (background, y axis)

      var labels = svg.append('g').attr('class', 'chart-labels');
      var chartLabels = new ChartLabels(labels, {
        model: this.model,
        yAxis: this.yAxis
      });
      var dataForLabels = this.demuxDataForLabels(data);
      chartLabels.draw(dataForLabels); // Line groups

      var lineGroups = svg.append('g').attr({
        class: "".concat(this.itemClass, "s"),
        transform: "translate(".concat(this.paddingLeft, ", ").concat(this.paddingTop, ")")
      }); // Create and render the lines layer

      var layer = this.layer('lines', lineGroups, this.linesLayerConfig);
      layer.draw(data); // Find and highlight the baseline comparison

      var baselineComparison = this.model.get('baselineComparison');

      if (baselineComparison) {
        this.lineGroupById(svg, baselineComparison).classed('baseline-comparison', true);
      }

      return svg;
    } // Creates and returns an instance from the original.
    // Returns a D3 selection with an SVG element.

  }, {
    key: "instance",
    value: function instance(original, locationWithValues, index) {
      var id = locationWithValues.id; // Layouting classes

      var lastColumn = (index + 1) % this.columns === 0;
      var lastRow = index >= this.columns * this.rows - this.columns; // Deep DOM clone

      var svg = original.node().cloneNode(true);
      svg = d3.select(svg).attr('data-id', id).classed(LAST_COLUMN_CLASS, lastColumn).classed(LAST_ROW_CLASS, lastRow); // Append location name

      svg.append('text').attr({
        class: 'location-name',
        x: this.paddingLeft - 2,
        dy: this.headerTextPosition
      }).text(locationWithValues.name);
      var $highlightedLineGroup = this.updateHighlights(svg, id);
      this.addTooltipsAndAnnotations(svg, $highlightedLineGroup);
      return svg;
    } // Highlights the line. Expects an svg D3 selection and a location id.
    // Returns the highlighted line group as a D3 selection.

  }, {
    key: "updateHighlights",
    value: function updateHighlights(svg, id) {
      // Find the highlighted line group
      var $highlightedLineGroup = this.lineGroupById(svg, id);
      var highlightedLineGroup = $highlightedLineGroup.node(); // Manually highlight the line group

      this.highlightService.updateHighlight($highlightedLineGroup, id); // Change DOM order so the highlighted group is on top of the others

      highlightedLineGroup.parentNode.appendChild(highlightedLineGroup);
      return $highlightedLineGroup;
    } // Adds tooltips and annotations to a highlighted line group.
    // Expects an svg D3 selection and the highlighted line group
    // as a D3 selection.

  }, {
    key: "addTooltipsAndAnnotations",
    value: function addTooltipsAndAnnotations(svg, $highlightedLineGroup) {
      var chart = this; // Line hover helpers

      svg.selectAll(selector(MultipleLineChart.LINE_HOVER_HELPER_CLASS)).each(function () {
        chart.addManualLineTooltip(this);
      }); // Marker dots

      svg.selectAll(selector(MultipleLineChart.MARKER_DOT_CLASS)).each(function () {
        chart.addManualMarkerDotTooltip(this);
      }); // Line annotation

      if (this.areAnnotationsVisible) {
        $highlightedLineGroup.select(selector(MultipleLineChart.LINE_ANNOTATION_TARGET_CLASS)).each(function () {
          chart.addManualLineAnnotation(this);
        });
      }
    } // Finds the line group for a given location id in the DOM.
    // Expects an svg D3 selection and a location id.

  }, {
    key: "lineGroupById",
    value: function lineGroupById(svg, id) {
      return svg.select(".".concat(this.itemClass, "[data-id='").concat(id, "']"));
    } // Override method for highlighting

  }, {
    key: "updateHighlight",
    value: function updateHighlight() {// Do nothing. Were highlighting the lines manually.
    } // Tooltips and annotations
    // ------------------------
    //
    // Override methods for adding tooltips and annotations.
    // Do not create the tooltips here, only save the data in the DOM
    // as attributes. The methods for the tooltip content then read the data.
    // The reason for this is that element properties are not cloned
    // when the small multiples are created.

  }, {
    key: "addLineTooltip",
    value: function addLineTooltip(lineHoverHelper, d) {
      this.setTooltipData(lineHoverHelper, this.lineTooltipData(d));
    }
  }, {
    key: "addMarkerDotTooltip",
    value: function addMarkerDotTooltip(markerDot, d) {
      this.setTooltipData(markerDot, this.markerTooltipData(d));
    }
  }, {
    key: "toggleLineAnnotation",
    value: function toggleLineAnnotation(lineAnnotationTarget, d) {
      this.setTooltipData(lineAnnotationTarget, this.lineAnnotationData(d));
    } // Add tooltips manually with empty data, its read from the DOM

  }, {
    key: "addManualLineTooltip",
    value: function addManualLineTooltip(lineHoverHelper) {
      this.addTooltip({
        target: lineHoverHelper,
        render: this.lineTooltipContent
      });
    }
  }, {
    key: "addManualMarkerDotTooltip",
    value: function addManualMarkerDotTooltip(markerDot) {
      this.addTooltip({
        target: markerDot,
        render: this.markerTooltipContent
      });
    }
  }, {
    key: "addManualLineAnnotation",
    value: function addManualLineAnnotation(markerDot) {
      this.addAnnotation({
        target: markerDot,
        render: this.lineAnnotationContent
      });
    } // Tooltip content
    // ---------------

  }, {
    key: "lineTooltipContent",
    value: function lineTooltipContent(d, element) {
      return tooltipTemplates.location.render(this.getTooltipData(element));
    }
  }, {
    key: "markerTooltipContent",
    value: function markerTooltipContent(d, element) {
      return tooltipTemplates.full.render(this.getTooltipData(element));
    }
  }, {
    key: "lineAnnotationContent",
    value: function lineAnnotationContent(d, element) {
      return tooltipTemplates.timePeriodValue.render(this.getTooltipData(element));
    } // Tooltip data
    // ------------

  }, {
    key: "lineAnnotationData",
    value: function lineAnnotationData(d) {
      return this.markerTooltipData(d.latestValue);
    } // Helpers for saving/reading tooltip data to/from the DOM.

  }, {
    key: "setTooltipData",
    value: function setTooltipData(element, d) {
      element.setAttribute(TOOLTIP_ATTRIBUTE, JSON.stringify(d));
    }
  }, {
    key: "getTooltipData",
    value: function getTooltipData(element) {
      return JSON.parse(element.getAttribute(TOOLTIP_ATTRIBUTE));
    } // Line group sorting
    // ------------------
    // Override line group sorting

  }, {
    key: "highlightSorter",
    value: function highlightSorter(a, b) {
      // Skip highlight sorting, were doing it manually.
      // Only move the baseline to the end.
      return this.baselineSorter(a, b);
    }
  }]);
  return MultipleLineChart;
}(BaseLineChart);

MultipleLineChart.prototype.boundMethods = ['lineTooltipContent', 'markerTooltipContent', 'lineAnnotationContent']; // Properties
// ----------

MultipleLineChart.prototype.annotationModes = ANNOTATION_MODES; // Dependents
// ----------
// Padding
// -------

var xPaddingDependent = {
  after: ['tickWidth', 'basePadding'],
  recipe: function recipe(data) {
    if (data.timePeriods.length === 2) {
      // Two time periods: Slope chart
      return this.tickWidth * 0.2;
    } else {
      return this.basePadding;
    }
  }
};
/** @type {import('../types/types').Dependents<RawChartData, RawChartData, MultipleLineChart>} */

MultipleLineChart.prototype.dependents = {
  // Calculate the mode using the instance size, not the container size
  mode: {
    after: ['tickWidth', 'tickHeight'],
    recipe: function recipe() {
      return chartMode.get(this.tickWidth, this.tickHeight);
    }
  },
  basePadding: {
    after: ['tickWidth'],
    recipe: function recipe() {
      if (this.tickWidth < 200) {
        return 6;
      } else {
        return 10;
      }
    }
  },
  // Override padding
  paddingTop: {
    after: ['mode'],
    recipe: function recipe() {
      if (this.mode === 'small') {
        return 20;
      } else {
        return 24;
      }
    }
  },
  paddingRight: xPaddingDependent,
  paddingBottom: {
    after: ['basePadding'],
    recipe: function recipe() {
      return this.basePadding;
    }
  },
  paddingLeft: xPaddingDependent,
  // Data accessors
  // --------------
  // Array of highlighted locationWithValues
  highlightedLocations: {
    recipe: function recipe(data) {
      var highlightedLocations = this.model.get('highlightedLocations');
      return data.filteredLocationsWithValues.filter(function (locationWithValues) {
        return highlightedLocations.indexOf(locationWithValues.id) >= 0;
      });
    }
  },
  // Shortcut for the number of highlighted locations
  highlightedLength: {
    after: ['highlightedLocations'],
    recipe: function recipe() {
      return this.highlightedLocations.length;
    }
  },
  headerTextPosition: {
    after: ['mode', 'highlightedLength'],
    recipe: function recipe() {
      if (this.mode === 'small') {
        return 14;
      } else if (this.highlightedLength > 6) {
        return 16;
      } else {
        return 20;
      }
    }
  },
  // Column layout
  // -------------
  // There are two layouting modes:
  // 1. Fixed-height mode, automatic column count. The width and height is
  //    distributed among the small multiples.
  // 2. Flexible-height mode, fixed 2 columns. Each small multiple has a
  //    standard aspect ratio. The chart has an arbitrary height.
  twoColumnMode: {
    after: ['rawWidth'],
    recipe: function recipe() {
      return this.rawWidth <= LIMIT_THRESHOLD && !this.model.get('fixedHeight');
    }
  },
  columns: {
    after: ['twoColumnMode', 'highlightedLength'],
    recipe: function recipe() {
      if (this.twoColumnMode) {
        return 2;
      } else {
        return Math.ceil(Math.sqrt(this.highlightedLength));
      }
    }
  },
  rows: {
    after: ['columns', 'highlightedLength'],
    recipe: function recipe() {
      return Math.ceil(this.highlightedLength / this.columns);
    }
  },
  // Instance width as an integer
  tickWidth: {
    after: ['rawWidth', 'columns'],
    recipe: function recipe() {
      return Math.floor((this.rawWidth - CELLSPACING * (this.columns - 1)) / this.columns);
    }
  },
  // Instance height as an integer
  tickHeight: {
    after: ['twoColumnMode', 'tickWidth', 'rawHeight', 'rows'],
    recipe: function recipe() {
      if (this.twoColumnMode) {
        return this.tickWidth / ASPECT_RATIO;
      } else {
        return Math.floor((this.rawHeight - CELLSPACING * (this.rows - 1)) / this.rows);
      }
    }
  }
};
module.exports = MultipleLineChart;

},{"../constants/aspect-ratio":68,"../util/chart":119,"./annotation-service":36,"./base-line-chart":41,"./chart-labels":44,"./chart-mode":45,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"d3":27}],57:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var I18n = require('../i18n');

var _require = require('../util/chart'),
    dName = _require.dName,
    filterValues = _require.filterValues,
    idKey = _require.idKey,
    latestDataPoint = _require.latestDataPoint,
    selector = _require.selector,
    wrapValue = _require.wrapValue;

var numberFormatter = require('../util/number-formatter');

var locationsWithSubjectValues = require('../util/locations-with-subject-values');

var BaseChart = require('./base-chart');

var Table = require('./table');
/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').TableData} TableData */
// Constants
// ---------
// Block class name


var BLOCK = 'multiple-table';
var SCROLL_WRAPPER_CLASS = "".concat(BLOCK, "-scroll-wrapper");
var TABLES_CLASS = "".concat(BLOCK, "-tables");
var FOOTER_CLASS = "".concat(BLOCK, "-footer");
var STICKY_HEADER_CONTAINER_CLASS = "".concat(BLOCK, "-sticky-header-container");
var SUBJECT_HEADING_CLASS = "".concat(BLOCK, "-subject-heading");
var INSTANCE_CLASS = "".concat(BLOCK, "-instance");
var TABLE_NOTE_CLASS = "".concat(BLOCK, "-table-note");
var OBS_LEGEND_CLASS = "".concat(BLOCK, "-obs-legend");
var OBS_LEGEND_DT_CLASS = "".concat(BLOCK, "-obs-legend-dt");
var OBS_LEGEND_DD_CLASS = "".concat(BLOCK, "-obs-legend-dd");

var MultipleTable = /*#__PURE__*/function (_BaseChart) {
  (0, _inherits2.default)(MultipleTable, _BaseChart);

  var _super = _createSuper(MultipleTable);

  function MultipleTable() {
    (0, _classCallCheck2.default)(this, MultipleTable);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(MultipleTable, [{
    key: "initialize",
    value: // Property declarations
    // ---------------------
    //
    // stickyHeader: jQuery
    // tableInstances: Object
    //   Object with Table instances by subject id
    // scrollWrapper: D3 Selection
    // tables: D3 selection
    // footer: D3 selection
    function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(MultipleTable.prototype), "initialize", this).call(this, options);
      this.tableInstances = {};
      this.base.classed(BLOCK, true); // DOM setup

      this.scrollWrapper = this.base.append('div').classed(SCROLL_WRAPPER_CLASS, true);
      this.tables = this.scrollWrapper.append('div').classed(TABLES_CLASS, true);
      this.footer = this.scrollWrapper.append('div').classed(FOOTER_CLASS, true); // The sticky header needs to be OUTSIDE of the scrollWrapper
      // so that the fixed position works.

      this.stickyHeaderContainer = this.base.append('div').classed(STICKY_HEADER_CONTAINER_CLASS, true); // Layers

      this.layer('tables', this.tables, this.tablesLayerConfig);
      this.layer('footer', this.footer, this.footerLayerConfig); // Observation status legend needs to be drawn just once,
      // since it does not depend on model data

      this.drawObservationStatusLegend();
    } // Drawing
    // -------
    // Draws the observation status legend only once
    // since it does not depend on data

  }, {
    key: "drawObservationStatusLegend",
    value: function drawObservationStatusLegend() {
      var dl = this.footer.append('dl').classed(OBS_LEGEND_CLASS, true);
      var observationStatus = I18n.t('observationStatus');

      for (var id in observationStatus) {
        var info = observationStatus[id];
        dl.append('dt').classed(OBS_LEGEND_DT_CLASS, true).text(info.abbr);
        dl.append('dd').classed(OBS_LEGEND_DD_CLASS, true).text(info.description);
      }
    }
  }]);
  return MultipleTable;
}(BaseChart);
/**
 * Dependents shared between the individual tables
 *
 * @type {import('../types/types').Dependents<RawChartData, MultipleTable>}
 */


MultipleTable.prototype.dependents = {
  // The extent of the data as [min: Number, max: Number]
  dataExtent: {
    recipe: function recipe(data) {
      // Aggregate values of all subjects
      var allValues = [];
      data.subjectsWithValues.forEach(function (subjectWithValues) {
        subjectWithValues.filteredLocationsWithValues.forEach(function (locationWithValues) {
          locationWithValues.values.forEach(function (dataPoint) {
            allValues.push(dataPoint.value);
          });
        });
      });
      return d3.extent(allValues);
    }
  },
  // Create label formatter once, then pass it to the Table instances
  formatLabel: {
    after: ['dataExtent'],
    recipe: function recipe(data) {
      // Show as many decimals as needed so each location has
      // meaningful values. No suffix, force decimals.
      return numberFormatter.extensiveLabelFormatter(data, this.dataExtent, false, true);
    }
  },
  subjectColumnMode: {
    recipe: function recipe(data) {
      return data.subjectsWithValues.length > 1 && data.timePeriods.length === 1;
    }
  },
  multipleTablesMode: {
    recipe: function recipe(data) {
      return data.subjectsWithValues.length > 1 && data.timePeriods.length > 1;
    }
  },
  useLatestData: {
    recipe: function recipe() {
      return this.model.get('useLatestData');
    }
  }
}; // Layers
// ------

/** @type {import('../types/types').LayerOptions<RawChartData, TableData, MultipleTable>} */

MultipleTable.prototype.tablesLayerConfig = {
  dataBind: function dataBind(data) {
    /** @type {TableData[]} */
    var tableData;
    var chart = this.chart();

    if (chart.subjectColumnMode) {
      // One table with subject columns
      tableData = [{
        id: 'multipleSubjects',
        subjectColumnMode: true,
        multipleTablesMode: chart.multipleTablesMode,
        columns: data.subjects,
        locationsWithValues: locationsWithSubjectValues(data, false),
        formatLabel: chart.formatLabel
      }];
    } else {
      // n tables for each subject with time period columns
      tableData = data.subjectsWithValues.map(function (subjectWithValues) {
        var columns;
        var locationsWithValues = subjectWithValues.filteredLocationsWithValues;

        if (chart.useLatestData) {
          locationsWithValues = locationsWithValues.map(function (location) {
            return filterValues(location, function (values) {
              return wrapValue(latestDataPoint(values, true));
            });
          }).filter(function (location) {
            return location.values.length > 0;
          });
          columns = [{
            id: 'latest',
            name: I18n.t('chartHeader.latestTimePeriod')
          }];
        } else {
          columns = data.timePeriods;
        }

        return {
          id: subjectWithValues.id,
          name: subjectWithValues.name,
          subjectColumnMode: false,
          multipleTablesMode: chart.multipleTablesMode,
          columns: columns,
          locationsWithValues: locationsWithValues,
          formatLabel: chart.formatLabel
        };
      });
    }

    return this.selectAll(selector(INSTANCE_CLASS)).data(tableData, idKey);
  },
  insert: function insert() {
    return this.append('div').classed(INSTANCE_CLASS, true);
  },
  events: {
    enter: function enter() {
      var chart = this.chart(); // Subject heading

      this.append('h3').classed(SUBJECT_HEADING_CLASS, true); // Create a Table instance

      return this.each(function (d) {
        var element = d3.select(this);
        var tableBase = element.append('div');
        var table = new Table(tableBase, {
          model: chart.model,
          stickyHeaderContainer: chart.stickyHeaderContainer,
          scrollWrapper: chart.scrollWrapper
        });
        chart.tableInstances[d.id] = table;
      });
    },
    merge: function merge() {
      var chart = this.chart(); // Order the selection

      this.order(); // Subject heading

      this.select(selector(SUBJECT_HEADING_CLASS)).style('display', chart.multipleTablesMode ? '' : 'none').text(dName); // Draw the Table instance

      this.each(function (d) {
        var table = chart.tableInstances[d.id];
        table.draw(d);
      });
    },
    exit: function exit() {
      var chart = this.chart(); // Dispose the Table instance

      this.each(function (d) {
        var id = d.id;
        var table = chart.tableInstances[id];
        table.dispose();
        delete chart.tableInstances[id];
      }); // Remove the instance element

      this.remove();
    }
  }
};
/**
 * Footer with table note (depends on data)
 *
 * @type {import('../types/types').LayerOptions<TableData, TableData, MultipleTable>}
 */

MultipleTable.prototype.footerLayerConfig = {
  dataBind: function dataBind() {
    var chart = this.chart();
    var tableNote = chart.model.get('tableNote'); // Transform URLs to links

    tableNote = _.escape(tableNote).replace(/https?:\/\/[^\s"<>]+/g, '<a href="$&" target="_blank">$&</a>');
    return this.selectAll(selector(TABLE_NOTE_CLASS)).data([tableNote]);
  },
  insert: function insert() {
    return this.insert('p', selector(OBS_LEGEND_CLASS)).classed(TABLE_NOTE_CLASS, true);
  },
  events: {
    merge: function merge() {
      this.html(_.identity);
    }
  }
};
module.exports = MultipleTable;

},{"../i18n":82,"../util/chart":119,"../util/locations-with-subject-values":130,"../util/number-formatter":135,"./base-chart":40,"./table":63,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"d3":27,"lodash":"lodash"}],58:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var InteractiveChart = require('./interactive-chart');

var numberFormatter = require('../util/number-formatter');
/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').DataForLabels} DataForLabels */
// Chart with margin, padding and a y axis
// Constants
// ---------
// For the y axis labels, assume a fixed glyph size in pixels
// so we dont need to lay out and measure the text.


var Y_AXIS_GLYPH_SIZE = 6; // Axes visibility
// ---------------
// Show axes in these modes

var X_AXIS_MODES = ['normal', 'big', 'large'];
var Y_AXIS_MODES = ['reduced', 'normal', 'big', 'large']; // Axes size
// ---------

var X_AXIS_HEIGHT = 25;
/**
 * @template Data
 */

var PaddedChart = /*#__PURE__*/function (_InteractiveChart) {
  (0, _inherits2.default)(PaddedChart, _InteractiveChart);

  var _super = _createSuper(PaddedChart);

  /**
   * @param {d3.Selection<Data>} selection
   * @param {{ model: ChartData }} options
   */
  function PaddedChart(selection, options) {
    var _this;

    (0, _classCallCheck2.default)(this, PaddedChart);
    _this = _super.call(this, selection, options);
    /** @type {number} */

    _this.marginTop;
    /** @type {number} */

    _this.marginRight;
    /** @type {number} */

    _this.marginBottom;
    /** @type {number} */

    _this.marginLeft;
    /** @type {number} */

    _this.paddingTop;
    /** @type {number} */

    _this.paddingRight;
    /** @type {number} */

    _this.paddingBottom;
    /** @type {number} */

    _this.paddingLeft;
    /** @type {number} */

    _this.tickWidth;
    /** @type {number} */

    _this.tickHeight;
    /** @type {number} */

    _this.plotWidth;
    /** @type {number} */

    _this.plotHeight;
    return _this;
  } // Demux
  // -----

  /**
   * For the labels, augment data with dependents
   *
   * @param {Data} data
   * @returns {DataForLabels}
   */


  (0, _createClass2.default)(PaddedChart, [{
    key: "demuxDataForLabels",
    value: function demuxDataForLabels(data) {
      return _.assign((0, _get2.default)((0, _getPrototypeOf2.default)(PaddedChart.prototype), "demuxDataForLabels", this).call(this, data), {
        width: this.tickWidth,
        height: this.tickHeight,
        paddingLeft: this.paddingLeft,
        paddingRight: this.paddingRight,
        paddingTop: this.paddingTop,
        paddingBottom: this.paddingBottom
      });
    }
  }, {
    key: "draw",
    value: function draw(data) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(PaddedChart.prototype), "draw", this).call(this, data); // Render a rectangle for debugging

      if (this.renderDebugRect) {
        if (!this.debugRect) {
          this.debugRect = this.base.append('rect').attr({
            class: 'debug-rect',
            fill: 'none',
            stroke: 'red',
            'stroke-width': 1,
            'shape-rendering': 'crispEdges',
            opacity: 0.5
          });
        }

        this.debugRect.attr({
          x: this.paddingLeft,
          y: this.paddingTop,
          width: this.plotWidth,
          height: this.plotHeight
        });
      }

      return this;
    }
  }]);
  return PaddedChart;
}(InteractiveChart);

PaddedChart.prototype.xAxisModes = X_AXIS_MODES;
PaddedChart.prototype.yAxisModes = Y_AXIS_MODES; // Axes sizes
// ----------

PaddedChart.prototype.xAxisHeight = X_AXIS_HEIGHT;
PaddedChart.prototype.yTicksMin = 3;
PaddedChart.prototype.yTicksMax = 8;
PaddedChart.prototype.yTickHeight = 30; // Margin configuration
// --------------------

PaddedChart.prototype.marginBottomMap = {
  _default: X_AXIS_HEIGHT,
  small: 0,
  reduced: 0
};
/** @type {import('../types/types').Dependent<RawChartData, number, PaddedChart>} */

var marginDependent = {
  recipe: function recipe() {
    return 0;
  }
};
/** @type {import('../types/types').Dependent<RawChartData, number, PaddedChart>} */

var marginBottomDependent = {
  after: ['mode'],
  recipe: function recipe() {
    return this.marginBottomMap[this.mode] != null ? this.marginBottomMap[this.mode] : this.marginBottomMap._default;
  }
}; // Padding configuration
// ---------------------

/** @type {{ [key: string]: number }} */

PaddedChart.prototype.paddingMap = {
  _default: 20,
  small: 5,
  reduced: 10
}; // Helper functions

/** @this {PaddedChart} */

var paddingRecipe = function paddingRecipe() {
  return this.paddingMap[this.mode] != null ? this.paddingMap[this.mode] : this.paddingMap._default;
};
/** @this {PaddedChart} */


var paddingTopRecipe = function paddingTopRecipe() {
  // In reduced mode, the header overlaps. Force a big paddingTop.
  if (this.mode === 'reduced') {
    return this.paddingMap._default;
  } else {
    return this.paddingRecipe();
  }
};
/** @this {PaddedChart} */


var paddingLeftRecipe = function paddingLeftRecipe() {
  if (this.yAxisModes.indexOf(this.mode) >= 0) {
    return this.yAxisWidth;
  } else {
    return this.paddingRecipe();
  }
}; // Whether to render a transparent rectangle over the plot area for debugging purposes.


PaddedChart.prototype.renderDebugRect = false; // Save recipes on prototype for reuse in subclasses

PaddedChart.prototype.paddingRecipe = paddingRecipe;
PaddedChart.prototype.paddingLeftRecipe = paddingLeftRecipe; // Shortcuts for padding dependents

/** @type {import('../types/types').Dependent<RawChartData, number, PaddedChart>} */

var paddingDependent = {
  after: ['mode'],
  recipe: paddingRecipe
};
/** @type {import('../types/types').Dependent<RawChartData, number, PaddedChart>} */

var paddingTopDependent = {
  after: ['mode'],
  recipe: paddingTopRecipe
};
/** @type {import('../types/types').Dependent<RawChartData, number, PaddedChart>} */

var paddingLeftDependent = {
  after: ['mode', 'yAxisWidth'],
  recipe: paddingLeftRecipe
};
/** @type {import('../types/types').Dependents<RawChartData, PaddedChart>} */

PaddedChart.prototype.dependents = {
  // Margins
  // -------
  marginTop: marginDependent,
  marginRight: marginDependent,
  marginBottom: marginBottomDependent,
  marginLeft: marginDependent,
  // Padding
  // -------
  paddingTop: paddingTopDependent,
  paddingRight: paddingDependent,
  paddingBottom: paddingDependent,
  paddingLeft: paddingLeftDependent,
  // Widths and heights
  // ------------------
  tickWidth: {
    after: ['width', 'marginLeft', 'marginRight'],
    recipe: function recipe() {
      return this.width - this.marginLeft - this.marginRight;
    }
  },
  tickHeight: {
    after: ['height', 'marginTop', 'marginBottom'],
    recipe: function recipe() {
      return this.height - this.marginTop - this.marginBottom;
    }
  },
  plotWidth: {
    after: ['tickWidth', 'paddingLeft', 'paddingRight'],
    recipe: function recipe() {
      return this.tickWidth - this.paddingLeft - this.paddingRight;
    }
  },
  plotHeight: {
    after: ['tickHeight', 'paddingTop', 'paddingBottom'],
    recipe: function recipe() {
      return this.tickHeight - this.paddingTop - this.paddingBottom;
    }
  },
  // Axes
  // ----
  yAxisTickNumber: {
    after: ['plotHeight'],
    recipe: function recipe() {
      var tickNumber = Math.floor(this.plotHeight / this.yTickHeight);
      return Math.min(Math.max(this.yTicksMin, tickNumber), this.yTicksMax);
    }
  },
  yAxisTickValues: {
    after: ['y', 'yAxisTickNumber'],
    recipe: function recipe() {
      return this.y.ticks(this.yAxisTickNumber);
    }
  },
  yAxisFormatter: {
    after: ['yAxisTickValues'],
    recipe: function recipe() {
      // Number formatter: Suffixed, force decimals
      return numberFormatter.significantDecimalsFormatter(this.yAxisTickValues, true, true);
    }
  },
  // Padding around the y axis labels
  yAxisPadding: {
    recipe: function recipe() {
      return 16;
    }
  },
  yAxisWidth: {
    after: ['yAxisFormatter', 'yAxisPadding'],
    recipe: function recipe() {
      var _this2 = this;

      var maxLabelSize = d3.max(this.yAxisTickValues.map(function (value) {
        return _this2.yAxisFormatter(value).length;
      }));
      return maxLabelSize * Y_AXIS_GLYPH_SIZE + this.yAxisPadding;
    }
  },
  yAxisTickPadding: {
    after: ['yAxisWidth'],
    recipe: function recipe() {
      return -0.8 * this.yAxisWidth;
    }
  },
  yAxis: {
    after: ['y', 'yAxisTickNumber', 'yAxisTickPadding', 'yAxisTickValues', 'yAxisFormatter'],
    initial: function initial() {
      return d3.svg.axis().orient('left');
    },
    recipe: function recipe(data, axis) {
      axis.scale(this.y).ticks(this.yAxisTickNumber).tickPadding(this.yAxisTickPadding).tickSize(-this.width, 0).tickFormat(this.yAxisFormatter);
      return axis;
    }
  }
};
module.exports = PaddedChart;

},{"../util/number-formatter":135,"./interactive-chart":49,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"d3":27,"lodash":"lodash"}],59:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var Hammer = require('../vendor/hammer-2.0.4.js');

var _require = require('../util/chart'),
    hasValue = _require.hasValue,
    singleDSelector = _require.singleDSelector;

var numberFormatter = require('../util/number-formatter');

var timePeriodNavigation = require('../models/time-period-navigation');

var PaddedChart = require('./padded-chart');

var ChartLabels = require('./chart-labels');

var _require2 = require('./location-labels.js'),
    LocationLabels = _require2.LocationLabels,
    marginBottomDependent = _require2.marginBottomDependent;
/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').LocationWithValues} LocationWithValues */
// Constants
// ---------
// Range bands padding for the ordinal x scale
// Percent of the step width


var RANGE_PADDING = 0.33;
/**
 * Base class for charts that visualize a single time periods
 */

var SingleTimePeriodChart = /*#__PURE__*/function (_PaddedChart) {
  (0, _inherits2.default)(SingleTimePeriodChart, _PaddedChart);

  var _super = _createSuper(SingleTimePeriodChart);

  function SingleTimePeriodChart() {
    (0, _classCallCheck2.default)(this, SingleTimePeriodChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(SingleTimePeriodChart, [{
    key: "initialize",
    value: // Properties
    // ----------
    // itemClass: String, needs to be defined on a derived class
    // rangePadding: Number
    function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(SingleTimePeriodChart.prototype), "initialize", this).call(this, options); // Location labels

      this.locationLabels = this.base.append('g').attr('class', LocationLabels.BASE_CLASS);
      this.attach('locationLabels', new LocationLabels(this.locationLabels, {
        model: this.model,
        x: this.x,
        xAxisModes: this.xAxisModes,
        highlightService: this.highlightService,
        dataForLocationLabels: this.dataForLocationLabels,
        isLabelVisible: this.isLabelVisible,
        highlightLocationLabels: this.highlightLocationLabels
      })); // y axis

      var labels = this.base.append('g').attr('class', 'chart-labels');
      this.attach('labels', new ChartLabels(labels, {
        model: this.model,
        yAxis: this.yAxis,
        interactiveTooltipService: this.interactiveTooltipService
      })); // Main layer, `locationsLayerConfig` needs to be defined on a derived class

      this.locationsGroup = this.base.append('g').attr('class', 'locations');
      this.layer('locations', this.locationsGroup, this.locationsLayerConfig);
    } // Interaction
    // -----------

  }, {
    key: "initInteraction",
    value: function initInteraction() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(SingleTimePeriodChart.prototype), "initInteraction", this).call(this);
      var h = this.hammerManager;
      h.add(new Hammer.Swipe({
        direction: Hammer.DIRECTION_HORIZONTAL
      }));
      h.on('swipeleft swiperight', _.debounce(this.touchNavigation, 300, {
        leading: true,
        trailing: false
      }));
    }
  }, {
    key: "touchNavigation",
    value: function touchNavigation(event) {
      switch (event.type) {
        case 'swipeleft':
          timePeriodNavigation.forward(this.model);
          break;

        case 'swiperight':
          timePeriodNavigation.back(this.model);
          break;
      }
    } // Drawing
    // -------

  }, {
    key: "applyDependents",
    value: function applyDependents(data) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(SingleTimePeriodChart.prototype), "applyDependents", this).call(this, data);
      this.locationsGroup.attr('transform', "translate(".concat(this.paddingLeft, ", ").concat(this.paddingTop, ")"));
      this.locationLabels.attr('transform', "translate(".concat(this.paddingLeft, " ").concat(this.height - this.marginBottom, ")"));
    } // Location labels
    // ---------------

    /**
     * Function passed to LocationLabels to determine the visible locations.
     * @param {RawChartData} data
     */

  }, {
    key: "dataForLocationLabels",
    value: function dataForLocationLabels(data) {
      return data.filteredLocationsWithValues;
    }
    /**
     * Function passed to LocationLabels to determine whether a label is visible.
     * @param {LocationWithValues} locationWithValues
     */

  }, {
    key: "isLabelVisible",
    value: function isLabelVisible(locationWithValues) {
      return hasValue(singleDSelector(locationWithValues));
    }
  }]);
  return SingleTimePeriodChart;
}(PaddedChart);

SingleTimePeriodChart.prototype.boundMethods = ['touchNavigation', 'dataForLocationLabels', 'isLabelVisible'];
/**
 * Whether location names are highlighted by LocationLabels.
 */

SingleTimePeriodChart.prototype.highlightLocationLabels = true; // Save constants as prototype properties so
// derived classes can access them easily.

SingleTimePeriodChart.prototype.rangePadding = RANGE_PADDING; // Padding configuration
// ---------------------

var xPaddingRecipe = function xPaddingRecipe(side) {
  return function (data) {
    if (data.filteredLocationsWithValues.length === 1) {
      // One location: Center the viz
      return this.width * 0.3;
    } else if (side === 'left') {
      return this.paddingLeftRecipe();
    } else {
      return this.paddingRecipe();
    }
  };
};
/** @type {import('../types/types').Dependents<import('../types/types').RawChartData, SingleTimePeriodChart>} */


SingleTimePeriodChart.prototype.dependents = {
  // Scales
  // ------
  // dataExtent needs to be defined in a derived class
  // x scale needs to be defined in a derived class
  // y scale needs to be defined in a derived class
  // Margins
  // -------
  marginBottom: marginBottomDependent,
  // Padding
  // -------
  paddingRight: {
    after: ['width'],
    recipe: xPaddingRecipe('right')
  },
  paddingBottom: {
    after: ['mode'],
    recipe: function recipe() {
      if (this.xAxisModes.indexOf(this.mode) >= 0) {
        return this.paddingRecipe();
      } else {
        return 0;
      }
    }
  },
  paddingLeft: {
    after: ['width', 'mode', 'yAxisWidth'],
    recipe: xPaddingRecipe('left')
  },
  // Label formatting
  // ----------------
  measure: {
    recipe: function recipe(data) {
      return data.measure;
    }
  },
  // Full number without suffix
  formatLabel: {
    after: ['dataExtent'],
    recipe: function recipe() {
      return numberFormatter.labelFormatter(this.dataExtent, false, true);
    }
  }
};
module.exports = SingleTimePeriodChart;

},{"../models/time-period-navigation":114,"../util/chart":119,"../util/number-formatter":135,"../vendor/hammer-2.0.4.js":149,"./chart-labels":44,"./location-labels.js":54,"./padded-chart":58,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"lodash":"lodash"}],60:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var I18n = require('../i18n');

var _require = require('../util/chart'),
    hasValue = _require.hasValue,
    idKey = _require.idKey,
    latestDataPoint = _require.latestDataPoint,
    selector = _require.selector;

var SingleTimePeriodChart = require('./single-time-period-chart');

var _require2 = require('./location-labels'),
    marginBottomDependent = _require2.marginBottomDependent;

var tooltipTemplates = require('./tooltip-templates');
/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').IdAndName} IdAndName */

/** @typedef {import('../types/types').LocationWithValues} LocationWithValues */

/** @typedef {import('../types/types').SubjectWithValues} SubjectWithValues */

/** @typedef {import('../types/types').DataPoint} DataPoint */

/** @typedef {DataPoint & { y: number, y0: number }} DataPointForStack */
// Constants
// ---------


var LEGEND_HEIGHT = 16;
var SUBJECT_COLOR_CLASSES = ['highlight-2', 'highlight-4', 'highlight-5', 'highlight-6', 'highlight-7', 'highlight-8']; // Classes
// -------

var CLASS_NAME = 'stacked-bar-chart';
var SUBJECT_GROUP_CLASS = "".concat(CLASS_NAME, "-subject-group");
var BAR_CLASS = "".concat(CLASS_NAME, "-bar");
var BAR_DESC_CLASS = "".concat(CLASS_NAME, "-bar-desc");
var LEGEND_CLASS = "".concat(CLASS_NAME, "-legend");
var LEGEND_SUBJECT_CLASS = "".concat(CLASS_NAME, "-legend-subject"); // The class of the element that represents a datum

var ITEM_CLASS = BAR_CLASS;

var StackedBarChart = /*#__PURE__*/function (_SingleTimePeriodChar) {
  (0, _inherits2.default)(StackedBarChart, _SingleTimePeriodChar);

  var _super = _createSuper(StackedBarChart);

  function StackedBarChart() {
    (0, _classCallCheck2.default)(this, StackedBarChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(StackedBarChart, [{
    key: "initialize",
    value: function initialize() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(StackedBarChart.prototype), "initialize", this).call(this);
      /** @type {{ locations: IdAndName[], stack: DataPointForStack[][] }} */

      this.locationsAndStack;
      this.base.classed("single-time-period-chart ".concat(CLASS_NAME), true);
      this.legend = this.$container().append('ul').attr('class', LEGEND_CLASS);
      this.layer('legend', this.legend, this.legendLayerConfig);
    } // Tooltips
    // --------

    /**
     * @param {DataPointForStack} d
     */

  }, {
    key: "tooltipContent",
    value: function tooltipContent(d) {
      /** @type {{ abbr: string, description: string } | null} */
      var obsInfo = d.status ? I18n.t('observationStatus')[d.status.id] : null;
      return tooltipTemplates.fullWithSubject.render({
        location: d.name,
        timePeriod: d.timePeriodName,
        subject: d.subjectName,
        value: this.formatLabel(d.value),
        measure: this.measure.name,
        observationStatusAbbr: obsInfo ? obsInfo.abbr : null,
        observationStatusDescription: obsInfo ? obsInfo.description : null
      });
    } // Hover behavior
    // --------------
    // Highlight all items (symbols) in the chart for the same subject

  }, {
    key: "enterItemHover",
    value: function enterItemHover(item) {
      var subjectId = item.datum().subject;
      this.allItems().each(function () {
        var otherItem = d3.select(this);
        var d = otherItem.datum();
        var isMatch = d.subject === subjectId;
        otherItem.classed('hover', isMatch).classed('background-hover', !isMatch);
      });
    }
  }, {
    key: "leaveItemHover",
    value: function leaveItemHover() {
      this.allItems().classed('hover', false).classed('background-hover', false);
    } // Location labels
    // ---------------

    /**
     * Function passed to LocationLabels to determine the visible locations.
     * @param {RawChartData} data
     */

  }, {
    key: "dataForLocationLabels",
    value: function dataForLocationLabels() {
      return this.locationsAndStack.locations;
    }
    /**
     * Function passed to LocationLabels to determine whether a label is visible.
     */

  }, {
    key: "isLabelVisible",
    value: function isLabelVisible() {
      // Always visible since the locations is is already filtered.
      return true;
    } // Disposal
    // --------

  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(StackedBarChart.prototype), "dispose", this).call(this); // Remove the legend from the DOM. Its not nested in base.

      this.legend.remove();
    }
  }]);
  return StackedBarChart;
}(SingleTimePeriodChart); // Properties
// ----------


StackedBarChart.prototype.boundMethods = ['tooltipContent'];
StackedBarChart.prototype.itemClass = ITEM_CLASS;
/**
 * Do not highlight the location labels since the bars are not highlighted,
 * but colored using the highlighting colors.
 */

StackedBarChart.prototype.highlightLocationLabels = false;
StackedBarChart.prototype.bottomLegendHeight = LEGEND_HEIGHT; // Dependents
// ----------

/** @type {import('../types/types').Dependents<RawChartData, StackedBarChart>} */

StackedBarChart.prototype.dependents = {
  // Data
  // ----
  locationsAndStack: {
    after: ['mode'],
    recipe: function recipe(data) {
      var _this = this;

      var useLatestData = this.model.get('useLatestData');
      /**
       * Whether a location has defined values for any subject.
       * @type {{ [key: string]: boolean }}
       */

      var locationHasValues = {}; // In small mode, show only highlighted and baseline

      var showForegroundLocationsOnly = this.mode === 'small' && this.highlightService.hasHighlightedLocations(); // Map operations with side effects: Fill locationHasValues while mapping.

      /** @type {DataPointForStack[][]} */

      var dataForStack = data.subjectsWithValues.map(function (subjectWithValues) {
        return subjectWithValues.filteredLocationsWithValues.filter(function (locationWithValues) {
          return !showForegroundLocationsOnly || _this.isForegroundLocation(locationWithValues.id);
        }).map(function (locationWithValues) {
          var id = locationWithValues.id,
              name = locationWithValues.name; // Find data point

          var dataPoint = latestDataPoint(locationWithValues.values, useLatestData); // Create data point for stack with y value

          /** @type {DataPointForStack} */

          var dataPointForStack;

          if (dataPoint) {
            dataPointForStack = _.create(dataPoint, {
              y: dataPoint.value
            });

            if (hasValue(dataPoint)) {
              // Mark location as having defined values
              locationHasValues[id] = true;
            }
          } else {
            // Use placeholder data point
            dataPointForStack = {
              id: id,
              name: name,
              value: null,
              y: null
            };
          }

          return dataPointForStack;
        });
      }); // Filter locations without defined value

      var filteredDataForStack = dataForStack.map(function (dataPoints) {
        return dataPoints.filter(function (dataPoint) {
          return dataPoint.id in locationHasValues;
        });
      }); // Calculate y0 values

      d3.layout.stack()(filteredDataForStack); // Sort locations by stack sum

      var lastSubjectData = _.last(filteredDataForStack) || [];

      var locationsWithSum = _.orderBy(lastSubjectData.map(function (dataPointForStack) {
        return {
          id: dataPointForStack.id,
          name: dataPointForStack.name,
          sum: dataPointForStack.y + dataPointForStack.y0
        };
      }), 'sum', this.model.get('sorting')); // Sort data points in stack according to location order
      // Create index map

      /** @type {{ [key: string]: number }} */


      var indexById = locationsWithSum.reduce(function (result, locationWithSum, index) {
        result[locationWithSum.id] = index;
        return result;
      }, {}); // Sort data points in place

      filteredDataForStack.forEach(function (dataPoints) {
        dataPoints.sort(function (a, b) {
          return indexById[a.id] - indexById[b.id];
        });
      }); // Get plain locations, remove sum

      /** @type {IdAndName} */

      var locations = locationsWithSum.map(function (locationWithSum) {
        return _.pick(locationWithSum, 'id', 'name');
      });
      return {
        locations: locations,
        stack: filteredDataForStack
      };
    }
  },
  // The extent of the data as [min: Number, max: Number]
  dataExtent: {
    after: ['locationsAndStack'],
    recipe: function recipe() {
      var stack = this.locationsAndStack.stack;
      var stackLength = stack.length;
      var values = stackLength > 0 ? stack[stackLength - 1].map(function (d) {
        return d.y + d.y0;
      }) : [];

      var _d3$extent = d3.extent(values),
          _d3$extent2 = (0, _slicedToArray2.default)(_d3$extent, 2),
          min = _d3$extent2[0],
          max = _d3$extent2[1]; // The minimum must not be larger that 0


      if (min > 0) {
        min = 0;
      } // If min and max are identical, apply some scale


      if (min === max) {
        max = Math.abs(min * 5);
      }

      return [min, max];
    }
  },
  // Margin
  // ------
  marginBottom: marginBottomDependent,
  // Scales
  // ------
  // x scale
  x: {
    after: ['plotWidth', 'locationsAndStack'],
    initial: function initial() {
      return d3.scale.ordinal();
    },

    /**
     * @param {d3.scale.Ordinal<string>} scale
     */
    recipe: function recipe(_data, scale) {
      var locationIds = this.locationsAndStack.locations.map(idKey);
      return scale.rangeRoundBands([0, this.plotWidth], 0.2, 0).domain(locationIds);
    }
  },
  y: {
    after: ['plotHeight', 'dataExtent', 'yAxisTickNumber'],
    initial: function initial() {
      return d3.scale.linear();
    },
    recipe: function recipe(_data, scale) {
      return scale.range([this.plotHeight, 0]).domain(this.dataExtent).nice(this.yAxisTickNumber);
    }
  }
}; // Layers
// ------
// Legend
// ------

/** @type {import('../types/types').LayerOptions<RawChartData, SubjectWithValues, StackedBarChart>} */

StackedBarChart.prototype.legendLayerConfig = {
  dataBind: function dataBind(data) {
    return this.selectAll(selector(LEGEND_SUBJECT_CLASS)).data(data.subjectsWithValues, idKey);
  },
  insert: function insert() {
    return this.append('li').attr('class', LEGEND_SUBJECT_CLASS);
  },
  events: {
    enter: function enter() {
      return this;
    },
    merge: function merge() {
      this.order().attr({
        'data-id': idKey,
        class: function _class(_d, i) {
          return "".concat(LEGEND_SUBJECT_CLASS, " ").concat(SUBJECT_COLOR_CLASSES[i]);
        }
      }).text(function (d) {
        return d.name;
      });
    },
    exit: function exit() {
      this.remove();
    }
  }
}; // Locations
// ---------

/** @type {import('../types/types').LayerOptions<RawChartData, DataPointForStack[], StackedBarChart>} */

StackedBarChart.prototype.locationsLayerConfig = {
  dataBind: function dataBind() {
    var chart = this.chart();
    var stack = chart.locationsAndStack.stack;
    return this.selectAll(selector(SUBJECT_GROUP_CLASS)).data(stack);
  },
  insert: function insert() {
    return this.append('g').attr('class', SUBJECT_GROUP_CLASS);
  },
  events: {
    enter: function enter() {},
    merge: function merge() {
      var chart = this.chart();
      this.attr({
        'data-id': idKey,
        class: function _class(_d, i) {
          return "".concat(SUBJECT_GROUP_CLASS, " ").concat(SUBJECT_COLOR_CLASSES[i]);
        }
      });
      /**
       * @type {import('../types/types').ChartSelection<
       * DataPointForStack,
       * StackedBarChart
       * >}
       */

      var bars = this.selectAll(selector(BAR_CLASS)).data(function (d) {
        return d;
      });
      bars.enter().append('rect').attr('class', BAR_CLASS).append('desc').attr('class', BAR_DESC_CLASS);
      bars.attr({
        x: function x(d) {
          return chart.x(d.id);
        },
        y: function y(d) {
          return chart.y(d.y0 + d.y);
        },
        width: function width() {
          return chart.x.rangeBand();
        },
        height: function height(d) {
          return chart.y(d.y0) - chart.y(d.y0 + d.y);
        }
      }).each(function (d) {
        if (hasValue(d)) {
          chart.addTooltip({
            target: this,
            render: chart.tooltipContent,
            d: d
          });
        } else {
          chart.removeTooltip(this);
        }
      }).select(selector(BAR_DESC_CLASS)).text(function (d) {
        var name = d.name;
        var subject = d.subjectName;
        var timePeriod = d.timePeriodName;
        var value = chart.formatLabel(d.value);
        var measure = chart.measure.name;
        return "".concat(name, ", ").concat(subject, ", ").concat(timePeriod, ": ").concat(value, " ").concat(measure);
      });
      bars.exit().each(function () {
        chart.removeTooltip(this);
      }).remove();
    },
    exit: function exit() {
      this.remove();
    }
  }
};
module.exports = StackedBarChart;

},{"../i18n":82,"../util/chart":119,"./location-labels":54,"./single-time-period-chart":59,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/slicedToArray":20,"d3":27,"lodash":"lodash"}],61:[function(require,module,exports){
'use strict'; // SVG symbol functions adopted from D3.js (MIT-licensed)
// See https://github.com/mbostock/d3/blob/master/src/svg/symbol.js

var sqrt = Math.sqrt;
var sqrt2 = Math.sqrt(2);
var sqrt3 = Math.sqrt(3); // Some symbols will be filled and appear larger than others
// although they have the same geometric area.
// Adjust the size of filled symbols in relation to hollow symbols.
// Since were not visualizing a data value using the symbol size,
// the geometric area of the symbols may differ.

var scaling = {
  circle: 0.95,
  diamond: 1,
  cross: 1,
  square: 1,
  triangle: 0.65
};
var svgSymbols = {
  types: ['circle', 'diamond', 'cross', 'square', 'triangle'],
  circle: function circle(size) {
    size *= scaling.circle;
    var r = sqrt(size / Math.PI);
    return "M0,".concat(r, " A").concat(r, ",").concat(r, " 0 1,1 0,").concat(-r, " A").concat(r, ",").concat(r, " 0 1,1 0,").concat(r, " Z");
  },
  diamond: function diamond(size) {
    size *= scaling.diamond;
    var r = sqrt(size) / sqrt2;
    return "M0,".concat(-r, " L").concat(r, ",0 0,").concat(r, " ").concat(-r, ",0 Z");
  },
  cross: function cross(size) {
    size *= scaling.cross;
    var r = sqrt(size) / 2;
    return "M".concat(-r, ",").concat(r, " L").concat(r, ",").concat(-r, " M").concat(r, ",").concat(r, " L").concat(-r, ",").concat(-r);
  },
  square: function square(size) {
    size *= scaling.square;
    var r = sqrt(size) / 2;
    return "M".concat(-r, ",").concat(-r, " L").concat(r, ",").concat(-r, " ").concat(r, ",").concat(r, " ").concat(-r, ",").concat(r, " Z");
  },
  triangle: function triangle(size) {
    size *= scaling.triangle;
    var rx = sqrt(size / sqrt3);
    var ry = rx * sqrt3 / 2;
    return "M0,".concat(-ry, " L").concat(rx, ",").concat(ry, " ").concat(-rx, ",").concat(ry, " Z");
  }
};
module.exports = svgSymbols;

},{}],62:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var d3 = require('d3');

var I18n = require('../i18n');

var _require = require('../util/chart'),
    dValue = _require.dValue,
    extent = _require.extent,
    idKey = _require.idKey,
    selector = _require.selector,
    hasValue = _require.hasValue,
    singleValueSelector = _require.singleValueSelector;

var support = require('../util/support');

var locationsWithSubjectValues = require('../util/locations-with-subject-values');

var SingleTimePeriodChart = require('./single-time-period-chart');

var svgSymbols = require('./svg-symbols');

var tooltipTemplates = require('./tooltip-templates');
/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').SubjectWithValues} SubjectWithValues */

/** @typedef {import('../types/types').LocationWithValues} LocationWithValues */

/** @typedef {import('../types/types').LocationsWithValues} LocationsWithValues */
// Constants
// ---------


var LEGEND_HEIGHT = 16; // Min/max symbol size in square pixels

var SYMBOL_SIZE_MIN = 8;
var SYMBOL_SIZE_MAX = 85;
var Y_AXIS_PADDING_MAP = {
  small: 0,
  // No y axis visible
  reduced: 18,
  normal: 24,
  big: 28,
  large: 32
}; // Classes
// -------

var CLASS_NAME = 'symbol-chart';
var LOCATION_GROUP_CLASS = "".concat(CLASS_NAME, "-location-group");
var SYMBOL_GROUPS_CLASS = "".concat(CLASS_NAME, "-symbol-groups");
var SYMBOL_GROUP_CLASS = "".concat(CLASS_NAME, "-symbol-group");
var SYMBOL_CLASS = "".concat(CLASS_NAME, "-symbol");
var SYMBOL_DESC_CLASS = "".concat(CLASS_NAME, "-symbol-desc");
var SYMBOL_SHADOW_CLASS = "".concat(CLASS_NAME, "-symbol-shadow");
var HOVER_HELPER_CLASS = "".concat(CLASS_NAME, "-hover-helper");
var LEGEND_SYMBOL_CLASS = "".concat(CLASS_NAME, "-legend-symbol");
var AXIS_LINE_CLASS = "".concat(CLASS_NAME, "-axis-line");
var VALUE_LINE_CLASS = "".concat(CLASS_NAME, "-value-line");
var LEGEND_CLASS = "".concat(CLASS_NAME, "-legend");
var LEGEND_SVG_CLASS = "".concat(CLASS_NAME, "-legend-svg");
var LEGEND_SUBJECT_CLASS = "".concat(CLASS_NAME, "-legend-subject");
var LEGEND_TEXT_CLASS = "".concat(CLASS_NAME, "-legend-text"); // The class of the element that represents a datum

var ITEM_CLASS = SYMBOL_GROUP_CLASS;

var SymbolChart = /*#__PURE__*/function (_SingleTimePeriodChar) {
  (0, _inherits2.default)(SymbolChart, _SingleTimePeriodChar);

  var _super = _createSuper(SymbolChart);

  function SymbolChart() {
    (0, _classCallCheck2.default)(this, SymbolChart);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(SymbolChart, [{
    key: "initialize",
    value: function initialize() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(SymbolChart.prototype), "initialize", this).call(this);
      this.base.classed("single-time-period-chart ".concat(CLASS_NAME), true);
      this.legend = this.$container().append('ul').attr('class', LEGEND_CLASS);
      this.layer('legend', this.legend, this.legendLayerConfig);
    }
    /**
     * @param {RawChartData} data
     */

  }, {
    key: "transform",
    value: function transform(data) {
      var _this = this;

      var useLatestData = this.model.get('useLatestData'); // Create an array of locations with values for all subjects.
      // locationsWithSubjectValues returns locations with at least
      // one defined (non-null) value.

      var locations = locationsWithSubjectValues(data, useLatestData); // In small mode, show only highlighted and baseline

      if (this.model.get('mode') === 'small' && this.highlightService.hasHighlightedLocations()) {
        locations = locations.filter(function (location) {
          return _this.isForegroundLocation(location.id);
        });
      } // Remove null values


      if (!useLatestData) {
        locations.forEach(function (location) {
          // Change the location object in-place, it is a copy
          location.values = location.values.filter(hasValue);
        });
      } // Sort locations by the value for the first available subject
      // (in requested subjects order)


      locations = _.orderBy(locations, singleValueSelector, this.model.get('sorting')); // Sort values ascending for a proper z-index of the symbols.
      // The symbols overlap from bottom to top.

      locations.forEach(function (location) {
        // Change the location object in-place, it is a copy
        location.values = _.sortBy(location.values, dValue);
      });

      var transformed = _.create(data, {
        filteredLocationsWithValues: locations
      });

      return transformed;
    }
    /**
     * @param {Element} locationGroup
     * @param {LocationWithValues} locationWithValues
     */

  }, {
    key: "createOrUpdateSymbols",
    value: function createOrUpdateSymbols(locationGroup, locationWithValues) {
      var chart = this; // Data bind
      // ---------

      var symbolGroups = d3.select(locationGroup).select(selector(SYMBOL_GROUPS_CLASS)).selectAll(selector(SYMBOL_GROUP_CLASS)).data(locationWithValues.values, function (d) {
        return d.subject;
      }); // Enter
      // -----

      var enterSelection = symbolGroups.enter().append('g').attr('class', SYMBOL_GROUP_CLASS); // Symbol shadow

      enterSelection.append('path').attr('class', SYMBOL_SHADOW_CLASS);
      enterSelection // Symbol
      .append('path').attr('class', SYMBOL_CLASS) // Accessible description
      .append('desc').attr('class', SYMBOL_DESC_CLASS); // Hover helper

      enterSelection.append('path').attr('class', HOVER_HELPER_CLASS); // Merge
      // -----

      symbolGroups.order(); // Symbol group

      symbolGroups.attr('data-id', idKey); // Symbol shadow

      symbolGroups.select(selector(SYMBOL_SHADOW_CLASS)).attr({
        transform: function transform(d) {
          return chart.symbolTransform(d);
        },
        d: function d(_d) {
          return chart.symbolShadowPath(_d.subject);
        }
      }); // Symbol

      symbolGroups.select(selector(SYMBOL_CLASS)).attr({
        class: function _class(d) {
          return chart.symbolClass(d.subject);
        },
        transform: function transform(d) {
          return chart.symbolTransform(d);
        },
        d: function d(_d2) {
          return chart.symbolPath(_d2.subject);
        }
      }); // Accessible description

      symbolGroups.select(selector(SYMBOL_DESC_CLASS)).text(function (d) {
        return chart.symbolDescription(d);
      }); // Hover helper

      symbolGroups.select(selector(HOVER_HELPER_CLASS)).attr({
        transform: function transform(d) {
          return chart.symbolTransform(d);
        },
        d: chart.hoverHelperPath
      }).each(function (d) {
        chart.addSymbolTooltip(this, d);
      }); // Exit
      // ----

      var exitSelection = symbolGroups.exit();
      exitSelection.select(selector(HOVER_HELPER_CLASS)).each(function () {
        chart.removeTooltip(this);
      });
      exitSelection.remove();
    }
  }, {
    key: "symbolClass",
    value: function symbolClass(subjectId) {
      var type = this.symbolsBySubject[subjectId].type;
      return "".concat(SYMBOL_CLASS, " symbol-chart-").concat(type);
    }
  }, {
    key: "symbolTransform",
    value: function symbolTransform(d) {
      return "translate(0, ".concat(this.y(d.value), ")");
    }
  }, {
    key: "symbolPath",
    value: function symbolPath(subjectId) {
      return this.symbolsBySubject[subjectId].path;
    }
  }, {
    key: "symbolShadowPath",
    value: function symbolShadowPath(subjectId) {
      return this.symbolsBySubject[subjectId].shadowPath;
    }
  }, {
    key: "addSymbolTooltip",
    value: function addSymbolTooltip(symbol, d) {
      this.addTooltip({
        target: symbol,
        render: this.tooltipContent,
        d: d
      });
    }
  }, {
    key: "symbolDescription",
    value: function symbolDescription(d) {
      var name = d.name;
      var subject = d.subjectName;
      var timePeriod = d.timePeriodName;
      var value = this.formatLabel(d.value);
      var measure = this.measure.name;
      return "".concat(name, ", ").concat(subject, ", ").concat(timePeriod, ": ").concat(value, " ").concat(measure);
    } // Tooltips
    // --------

  }, {
    key: "tooltipContent",
    value: function tooltipContent(d) {
      /** @type {{ abbr: string, description: string } | null} */
      var obsInfo = d.status ? I18n.t('observationStatus')[d.status.id] : null;
      return tooltipTemplates.fullWithSubject.render({
        location: d.name,
        timePeriod: d.timePeriodName,
        subject: d.subjectName,
        value: this.formatLabel(d.value),
        measure: this.measure.name,
        observationStatusAbbr: obsInfo ? obsInfo.abbr : null,
        observationStatusDescription: obsInfo ? obsInfo.description : null
      });
    } // Hover behavior
    // --------------
    // Highlight all items (symbols) in the chart for the same subject

  }, {
    key: "enterItemHover",
    value: function enterItemHover(item) {
      var subjectId = item.datum().subject;
      this.allItems().each(function () {
        var otherItem = d3.select(this);
        var d = otherItem.datum();
        var isMatch = d.subject === subjectId;
        otherItem.classed('hover', isMatch).classed('background-hover', !isMatch);
      });
    }
  }, {
    key: "leaveItemHover",
    value: function leaveItemHover() {
      this.allItems().classed('hover', false).classed('background-hover', false);
    } // Disposal
    // --------

  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(SymbolChart.prototype), "dispose", this).call(this); // Remove the legend from the DOM. Its not nested in base.

      this.legend.remove();
    }
  }]);
  return SymbolChart;
}(SingleTimePeriodChart); // Properties
// ----------


SymbolChart.prototype.boundMethods = ['tooltipContent'];
SymbolChart.prototype.itemClass = ITEM_CLASS;
SymbolChart.prototype.bottomLegendHeight = LEGEND_HEIGHT; // Dependents
// ----------

/** @type {import('../types/types').Dependents<RawChartData, SymbolChart>} */

SymbolChart.prototype.dependents = {
  // Data
  // ----
  // The extent of the data as [min: Number, max: Number]
  dataExtent: {
    recipe: function recipe(data) {
      // Aggregate values of all subjects
      // eslint-disable-next-line prefer-const
      var _extent = extent(data.filteredLocationsWithValues),
          _extent2 = (0, _slicedToArray2.default)(_extent, 2),
          min = _extent2[0],
          max = _extent2[1]; // If min and max are identical, apply some scale


      if (min === max) {
        max = Math.abs(min * 5);
      }

      return [min, max];
    }
  },
  // Scales
  // ------
  x: {
    after: ['plotWidth'],
    initial: function initial() {
      return d3.scale.ordinal();
    },
    recipe: function recipe(data, scale) {
      var locationIds = data.filteredLocationsWithValues.map(idKey);
      return scale.rangePoints([0, this.plotWidth], this.rangePadding).domain(locationIds);
    }
  },
  y: {
    after: ['plotHeight', 'dataExtent', 'yAxisTickNumber'],
    initial: function initial() {
      return d3.scale.linear();
    },
    recipe: function recipe(_data, scale) {
      return scale.range([this.plotHeight, 0]).domain(this.dataExtent).nice(this.yAxisTickNumber);
    }
  },
  // Y axis
  // ------
  yAxisPadding: {
    after: ['mode'],
    recipe: function recipe() {
      return Y_AXIS_PADDING_MAP[this.mode];
    }
  },
  yAxisTickPadding: {
    after: ['yAxisWidth'],
    recipe: function recipe() {
      return -0.65 * this.yAxisWidth;
    }
  },
  // Symbols
  // -------
  // The area size of the symbol in square pixels
  symbolSize: {
    after: ['plotWidth'],
    recipe: function recipe(data) {
      var size = this.plotWidth / data.filteredLocationsWithValues.length * 2.5;
      size = Math.max(SYMBOL_SIZE_MIN, size);
      size = Math.min(size, SYMBOL_SIZE_MAX);
      return size;
    }
  },
  // Hash with symbol paths by subject id
  // { SUBJECT_A: { type: String, path: String, shadowPath: String },  }
  symbolsBySubject: {
    after: ['symbolSize'],
    recipe: function recipe() {
      var types = svgSymbols.types;
      var length = types.length;
      var size = this.symbolSize;

      var reducer = function reducer(result, subject, index) {
        var type = types[index % length];
        var createPath = svgSymbols[type];
        var path = createPath(size);
        var shadowPath = createPath(size * 2);
        result[subject] = {
          type: type,
          path: path,
          shadowPath: shadowPath
        };
        return result;
      }; // Use the configuration subject order, not the response order


      return this.model.get('subjects').reduce(reducer, {});
    }
  },
  // Rendering
  // ---------
  // The factor for the size of the hover helper vs. size of the symbol
  hoverHelperFactor: {
    recipe: function recipe() {
      // On touch devices, use a larger hover helper
      if (support.isTouchDevice) {
        return 6.5;
      } else {
        return 4;
      }
    }
  },
  hoverHelperPath: {
    after: ['symbolSize', 'hoverHelperFactor'],
    recipe: function recipe() {
      var size = this.symbolSize * this.hoverHelperFactor;
      return svgSymbols.square(size);
    }
  }
}; // Layers
// ------
// Legend
// ------

/** @type {import('../types/types').LayerOptions<RawChartData, SubjectWithValues, SymbolChart>} */

SymbolChart.prototype.legendLayerConfig = {
  dataBind: function dataBind(data) {
    return this.selectAll(selector(LEGEND_SUBJECT_CLASS)).data(data.subjectsWithValues, idKey);
  },
  insert: function insert() {
    return this.append('li').attr('class', LEGEND_SUBJECT_CLASS);
  },
  events: {
    enter: function enter() {
      this.append('svg').attr({
        class: LEGEND_SVG_CLASS,
        width: LEGEND_HEIGHT,
        height: LEGEND_HEIGHT
      }).append('path').attr('class', "".concat(SYMBOL_CLASS, " ").concat(LEGEND_SYMBOL_CLASS));
      this.append('span').attr('class', LEGEND_TEXT_CLASS);
    },
    merge: function merge() {
      var chart = this.chart();
      this.order().attr({
        'data-id': idKey
      });
      this.select(selector(LEGEND_TEXT_CLASS)).text(function (d) {
        return d.name;
      });
      var symbolTranslation = LEGEND_HEIGHT / 2;
      this.select(selector(SYMBOL_CLASS)).attr({
        class: function _class(d) {
          return "".concat(chart.symbolClass(d.id), " ").concat(LEGEND_SYMBOL_CLASS);
        },
        d: function d(_d3) {
          return chart.symbolPath(_d3.id);
        },
        transform: "translate(".concat(symbolTranslation, ", ").concat(symbolTranslation, ")")
      });
    },
    exit: function exit() {
      this.remove();
    }
  }
}; // Locations & symbols
// -------------------

/** @type {import('../types/types').LayerOptions<RawChartData, LocationWithValues, SymbolChart>} */

SymbolChart.prototype.locationsLayerConfig = {
  dataBind: function dataBind(data) {
    return this.selectAll(selector(LOCATION_GROUP_CLASS)).data(data.filteredLocationsWithValues, idKey);
  },
  insert: function insert() {
    return this.append('g').attr('class', LOCATION_GROUP_CLASS);
  },
  events: {
    enter: function enter() {
      // Connection lines
      this.append('line').attr('class', AXIS_LINE_CLASS);
      this.append('line').attr('class', VALUE_LINE_CLASS); // Group for all symbol groups

      this.append('g').attr('class', SYMBOL_GROUPS_CLASS);
    },
    merge: function merge() {
      var chart = this.chart();
      this.order();
      this.attr({
        'data-id': idKey,
        transform: function transform(d) {
          return "translate(".concat(chart.x(d.id), ", 0)");
        }
      }); // Connection line from lowest symbol to the minimum y axis
      // (so it touches to x axis)

      this.select(selector(AXIS_LINE_CLASS)).attr({
        x1: 0,
        y1: function y1(d) {
          return chart.y(singleValueSelector(d));
        },
        x2: 0,
        y2: function y2() {
          return chart.y(chart.yAxisTickValues[0]);
        }
      }); // Connection line from highest symbol to the lowest symbol

      this.select(selector(VALUE_LINE_CLASS)).attr({
        x1: 0,
        y1: function y1(d) {
          return chart.y(singleValueSelector(d));
        },
        x2: 0,
        y2: function y2(d) {
          return chart.y(_.last(d.values).value);
        }
      });
      this.each(function (d) {
        chart.updateHighlight(this, d);
        chart.createOrUpdateSymbols(this, d);
      });
    },
    exit: function exit() {
      this.remove();
    }
  }
};
module.exports = SymbolChart;

},{"../i18n":82,"../util/chart":119,"../util/locations-with-subject-values":130,"../util/support":140,"./single-time-period-chart":59,"./svg-symbols":61,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/slicedToArray":20,"d3":27,"lodash":"lodash"}],63:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var $ = require('jquery');

var d3 = require('d3');

var I18n = require('../i18n');

var _require = require('../util/chart'),
    hasValue = _require.hasValue,
    idKey = _require.idKey,
    selector = _require.selector,
    sortByNameDesc = _require.sortByNameDesc;

var domUtil = require('../util/dom');

var support = require('../util/support');

var BaseChart = require('./base-chart');

var HighlightService = require('./highlight-service');

var InteractiveTooltipService = require('./interactive-tooltip-service');

var tooltipTemplates = require('./tooltip-templates');
/** @typedef {import('../types/types').DataPoint} DataPoint */

/** @typedef {import('../types/types').LocationWithValues} LocationWithValues */

/** @typedef {import('../types/types').TableData} TableData */

/** @typedef {'SORT_BY_NAME' | 'SORT_BY_TIME_PERIOD' | 'SORT_BY_SUBJECT'} Sorting */

/** @typedef {'SORT_ORDER_ASC' | 'SORT_ORDER_DESC'} SortOrder */
// Constants
// ---------
// Sorting


var SORT_BY_NAME = 'SORT_BY_NAME';
var SORT_BY_TIME_PERIOD = 'SORT_BY_TIME_PERIOD';
var SORT_BY_SUBJECT = 'SORT_BY_SUBJECT';
var SORT_ORDER_ASC = 'SORT_ORDER_ASC';
var SORT_ORDER_DESC = 'SORT_ORDER_DESC'; // Classes
// -------

var CLASS_NAME = 'table-chart';
var TABLE_CLASS = "".concat(CLASS_NAME, "-table");
var CAPTION_CLASS = "".concat(CLASS_NAME, "-caption");
var THEAD_CLASS = "".concat(CLASS_NAME, "-thead");
var THEAD_TR_CLASS = "".concat(CLASS_NAME, "-thead-tr");
var THEAD_TH_CLASS = "".concat(CLASS_NAME, "-thead-th");
var SORT_LINK_CLASS = "".concat(CLASS_NAME, "-sort-link");
var SORT_LINK_ACTIVE_CLASS = "".concat(CLASS_NAME, "-sort-link-active");
var TBODY_CLASS = "".concat(CLASS_NAME, "-tbody");
var TBODY_TR_CLASS = "".concat(CLASS_NAME, "-tbody-tr");
var TBODY_TH_CLASS = "".concat(CLASS_NAME, "-tbody-th");
var TD_CLASS = "".concat(CLASS_NAME, "-td");
var VALUE_CLASS = "".concat(CLASS_NAME, "-value");
var MISSING_CLASS = "".concat(CLASS_NAME, "-is-missing");
var STATUS_BASE_CLASS = "".concat(CLASS_NAME, "-has-status-");
var STICKY_HEADER_CLASS = "".concat(CLASS_NAME, "-sticky-header");
var STICKY_HEADER_DISABLED_CLASS = "".concat(CLASS_NAME, "-sticky-header-disabled");
var STICKY_HEADER_TR_CLASS = "".concat(CLASS_NAME, "-sticky-header-tr");
var STICKY_HEADER_SPACER_CLASS = "".concat(CLASS_NAME, "-sticky-header-spacer"); // Property declarations
// ---------------------
//
// lastData: Object
//   The data object of the last draw operation
//
// $base: jQuery
// table: D3 selection
// $table: jQuery
// caption: D3 selection
// thead: D3 selection
// $thead: jQuery
// theadTr: D3 selection
// tbody: D3 selection
//
// stickyHeaderContainer: D3 selection
// scrollWrapper: D3 selection
// $scrollWrapper: jQuery
// stickyHeader: D3 selection
// $stickyHeader: jQuery
// stickyHeaderTr: D3 selection
//
// sorting: String
//   One of SORT_BY_NAME, SORT_BY_TIME_PERIOD or SORT_BY_SUBJECT
// sortId: String
//   Time period or subject id for sorting
// sortOrder: String
//   One of SORT_ORDER_ASC or SORT_ORDER_DESC
// interactive: Boolean
//   Whether events are handled. Set to false to disable interactivity.

var Table = /*#__PURE__*/function (_BaseChart) {
  (0, _inherits2.default)(Table, _BaseChart);

  var _super = _createSuper(Table);

  function Table() {
    (0, _classCallCheck2.default)(this, Table);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(Table, [{
    key: "initialize",
    value:
    /**
     * @param {{
     * model: import('../models/chart-data'),
     * stickyHeaderContainer: JQuery,
     * scrollWrapper: JQuery
     * }} options
     */
    function initialize(options) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Table.prototype), "initialize", this).call(this);
      /** @type {(number: number) => string} */

      this.formatLabel;
      /** @type {boolean} */

      this.subjectColumnMode;
      /** @type {boolean} */

      this.multipleTablesMode; // DOM setup

      this.base.classed(CLASS_NAME, true);
      this.$base = $(this.base.node());
      this.table = this.base.append('table').classed(TABLE_CLASS, true);
      this.$table = $(this.table.node());
      this.caption = this.table.append('caption').classed(CAPTION_CLASS, true);
      this.thead = this.table.append('thead').classed(THEAD_CLASS, true);
      this.$thead = $(this.thead.node());
      this.theadTr = this.thead.append('tr').classed(THEAD_TR_CLASS, true);
      this.tbody = this.table.append('tbody').classed(TBODY_CLASS, true); // Sticky header DOM setup

      this.initStickyHeader(options); // Layers

      this.layer('caption', this.table, this.captionLayerConfig);
      this.layer('thead', this.theadTr, this.theadLayerConfig);
      this.layer('tbody', this.tbody, this.tbodyLayerConfig); // Create a sticky header layer from the THEAD layer config

      this.layer('stickyHeader', this.stickyHeaderTr, this.theadLayerConfig);
      this.resetSorting();
      this.highlightService = new HighlightService(this.model); // The model controls the interactivity

      var interactive = this.model.get('interactive');

      if (interactive != null) {
        this.interactive = interactive;
      } // Interactive tooltips


      if (this.interactive) {
        this.initTooltips();
      }
    }
  }, {
    key: "resetSorting",
    value: function resetSorting() {
      /** @type {Sorting} */
      this.sorting = SORT_BY_NAME;
      /** @type {string} */

      this.sortId = SORT_BY_NAME;
      /** @type {SortOrder} */

      this.sortOrder = SORT_ORDER_ASC;
    } // Tooltip event handling
    // ----------------------

  }, {
    key: "initTooltips",
    value: function initTooltips() {
      this.interactiveTooltipService = new InteractiveTooltipService({
        container: this.container()
      }); // Handle all mouse events in a central event handler,
      // similar to InteractiveChart

      this.base.on('mouseover', this.mouseEventHandler).on('mousemove', this.mouseEventHandler).on('mouseout', this.mouseEventHandler);
    } // Central mouse event handler

  }, {
    key: "mouseEventHandler",
    value: function mouseEventHandler() {
      var event = d3.event; // Find a tooltip on the target

      var tooltip = this.interactiveTooltipService.tooltipForElement(event.target);

      if (!tooltip) {
        return;
      } // Dispatch tooltip event


      switch (event.type) {
        case 'mouseover':
          tooltip.mouseenterHandler(event);
          break;

        case 'mousemove':
          tooltip.mousemoveHandler(event);
          break;

        case 'mouseout':
          tooltip.mouseleaveHandler(event);
          break;
      }
    } // Data transformation
    // -------------------

    /**
     * @param {TableData} data
     */

  }, {
    key: "transform",
    value: function transform(data) {
      data = _.clone(data);
      var compare = this.makeCompare(data);

      if (compare) {
        // Sort a copy of the array
        data.locationsWithValues = data.locationsWithValues.slice().sort(compare);
      }

      return data;
    }
    /**
     * Creates a comparison function for sorting the locations.
     * Returns a function or null if no sorting is necessary
     * (sorting by name ascending is the default).
     *
     * @param {TableData} data
     */

  }, {
    key: "makeCompare",
    value: function makeCompare(data) {
      if (this.sorting === SORT_BY_NAME && this.sortOrder === SORT_ORDER_DESC) {
        // Sort by name descending
        return sortByNameDesc;
      } else if (this.sorting === SORT_BY_SUBJECT || this.sorting === SORT_BY_TIME_PERIOD) {
        // Sort by values of a subject or time period
        var isAscending = this.sortOrder === SORT_ORDER_ASC;
        var factor = isAscending ? 1 : -1;

        var index = _.findIndex(data.columns, {
          id: this.sortId
        }); // null values should always be at the end of the list


        var nullValue = isAscending ? 0 : Infinity;
        return function (locationWithValues1, locationWithValues2) {
          var a = locationWithValues1.values[index].value != null ? locationWithValues1.values[index].value : nullValue;
          var b = locationWithValues2.values[index].value != null ? locationWithValues2.values[index].value : nullValue;
          return factor * (b - a);
        };
      } else {
        return null;
      }
    }
    /**
     * Classes: value class + missing class + observation status classes
     *
     * @param {DataPoint} d
     */

  }, {
    key: "valueClassName",
    value: function valueClassName(d) {
      // Value class
      var classes = [VALUE_CLASS]; // Missing class

      if (!hasValue(d)) {
        classes.push(MISSING_CLASS);
      } // Observation status class


      var statusId = d.status != null ? d.status.id : undefined;

      if (statusId) {
        classes.push("".concat(STATUS_BASE_CLASS).concat(statusId.toLowerCase()));
      }

      return classes.join(' ');
    }
  }, {
    key: "updateValueTooltip",
    value: function updateValueTooltip(valueSpan, d) {
      if (hasValue(d)) {
        this.interactiveTooltipService.add({
          target: valueSpan,
          render: this.tooltipContent,
          d: d
        });
      } else {
        // Remove tooltip for undefined values
        this.interactiveTooltipService.remove(valueSpan);
      }
    }
    /**
     * @param {DataPoint} d
     * @returns {string | null}
     */

  }, {
    key: "observationStatusInfo",
    value: function observationStatusInfo(d) {
      return d.status ? I18n.t('observationStatus')[d.status.id] : null;
    }
    /**
     * @param {DataPoint} d
     */

  }, {
    key: "tooltipContent",
    value: function tooltipContent(d) {
      var obsInfo = this.observationStatusInfo(d);
      return tooltipTemplates.tableCell.render({
        location: d.name,
        timePeriod: d.timePeriodName,
        subject: this.subjectColumnMode ? d.subjectName : '',
        observationStatusAbbr: obsInfo ? obsInfo.abbr : null,
        observationStatusDescription: obsInfo ? obsInfo.description : null
      });
    } // Event handling
    // --------------
    // D3 event handler

  }, {
    key: "sortBy",
    value: function sortBy(d) {
      var nextSortOrder;
      d3.event.preventDefault();
      var nextSorting = d.id === SORT_BY_NAME ? SORT_BY_NAME : this.subjectColumnMode ? SORT_BY_SUBJECT : SORT_BY_TIME_PERIOD;
      var nextSortId = d.id; // Change sort order if the same column was clicked again

      if (nextSorting === this.sorting && nextSortId === this.sortId) {
        nextSortOrder = this.sortOrder === SORT_ORDER_DESC ? SORT_ORDER_ASC : SORT_ORDER_DESC;
      } // Switch to ASC sort order if name column was clicked


      if (nextSorting !== this.sorting && nextSorting === SORT_BY_NAME) {
        nextSortOrder = SORT_ORDER_ASC;
      }

      this.sorting = nextSorting;
      this.sortId = nextSortId;

      if (nextSortOrder) {
        this.sortOrder = nextSortOrder;
      } // Scroll to the top so the highest/lowest numbers are visible


      if (!this.multipleTablesMode) {
        this.$scrollWrapper.scrollTop(0);
      } // Re-draw parts of the table


      var sortedData = this.transform(this.lastData); // Re-draw the headers

      this.layer('thead').draw(sortedData);
      this.layer('stickyHeader').draw(sortedData); // Re-order the rows in the tbody layer. No need to re-draw the whole layer.
      // This is how d3.chart calls the dataBind function
      // See https://github.com/misoproject/d3.chart/blob/master/src/layer.js

      var trs = this.tbodyLayerConfig.dataBind.call(this.tbody, sortedData);
      trs.order();
    } // Drawing
    // -------

    /**
     * @param {TableData} data
     */

  }, {
    key: "draw",
    value: function draw(data) {
      // Save the untransformed data for re-drawing
      this.lastData = data; // Reset sorting if the id isnt present in the data any longer

      if ((this.sorting === SORT_BY_SUBJECT || this.sorting === SORT_BY_TIME_PERIOD) && _.findIndex(data.columns, {
        id: this.sortId
      }) === -1) {
        this.resetSorting();
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(Table.prototype), "draw", this).call(this, data); // Hide current tooltip

      if (this.interactive) {
        this.interactiveTooltipService.endHover();
      } // Sticky header


      if (!data.multipleTablesMode) {
        this.enableStickyHeader(data);
      } else {
        this.disableStickyHeader();
      }
    } // Override base size setting

  }, {
    key: "setBaseSize",
    value: function setBaseSize() {// Empty. Do not force a fixed size since the table height may grow.
    } // Sticky header
    // -------------
    // Sticky header DOM setup
    // The sticky header is yet another TABLE only with a THEAD.
    // Its not a child element of this.base,
    // but attached to stickyHeaderContainer.

  }, {
    key: "initStickyHeader",
    value: function initStickyHeader(options) {
      this.stickyHeaderContainer = options.stickyHeaderContainer;
      this.scrollWrapper = options.scrollWrapper;
      this.$scrollWrapper = $(this.scrollWrapper.node());
      this.stickyHeader = this.stickyHeaderContainer.append('table').classed(TABLE_CLASS, true).classed(STICKY_HEADER_CLASS, true).classed(STICKY_HEADER_DISABLED_CLASS, true) // Never show the sticky to assistive technologies
      .attr('aria-hidden', 'true');
      this.$stickyHeader = $(this.stickyHeader.node());
      this.stickyHeaderTr = this.stickyHeader.append('tr').classed(STICKY_HEADER_TR_CLASS, true);
    }
  }, {
    key: "enableStickyHeader",
    value: function enableStickyHeader() {
      this.$stickyHeader.removeClass(STICKY_HEADER_DISABLED_CLASS); // Get elements as jQuery objects

      var stickyHeader = this.$stickyHeader;
      var thead = this.$thead;
      var thClass = selector(THEAD_TH_CLASS); // Read widths from the original THs

      var widths = thead.find(thClass).toArray().map(function (originalTH) {
        return (// Read the sub-pixel width (content box) as floats.
          domUtil.innerSize(originalTH).width
        );
      }); // Transfer widths to the new THs.
      // Use spacer DIVs to ensure the correct widths.
      // Just setting the width on the THs does not suffice.

      stickyHeader.find(selector(STICKY_HEADER_SPACER_CLASS)).each(function (index, el) {
        $(el).css('width', widths[index]);
      }); // Install handler for x-axis scrolling where we need to manually set pos

      this.removeScrollWrapperListener();
      this.$scrollWrapper.on('scroll', this.scrollHandler); // Position the header in the next tick, after the D3 render cycle
      // has finished and old tables have exited.

      setTimeout(this.positionStickyHeader, 1);
    }
  }, {
    key: "disableStickyHeader",
    value: function disableStickyHeader() {
      this.$stickyHeader.addClass(STICKY_HEADER_DISABLED_CLASS);
      this.removeScrollWrapperListener();
    }
  }, {
    key: "removeScrollWrapperListener",
    value: function removeScrollWrapperListener() {
      this.$scrollWrapper.off('scroll', this.scrollHandler);
    }
  }, {
    key: "removeStickyHeader",
    value: function removeStickyHeader() {
      this.removeScrollWrapperListener();
      this.stickyHeader.remove();
    } // On horizontal scroll, move and clip off the sticky header

  }, {
    key: "scrollHandler",
    value: function scrollHandler() {
      this.positionStickyHeader();
    }
  }, {
    key: "positionStickyHeader",
    value: function positionStickyHeader() {
      var scrollWrapper = this.$scrollWrapper;
      var stickyHeader = this.$stickyHeader;
      var table = this.$table; // Read & calculate

      var scrollWrapperEl = scrollWrapper.get(0);
      var scrollbarVisible = scrollWrapperEl.scrollHeight > scrollWrapperEl.offsetHeight;
      var scrollbarWidth = scrollbarVisible ? support.scrollbarWidth : 0;
      var scrollWrapperWidth = scrollWrapperEl.offsetWidth;
      var scrollWrapperOffsetLeft = scrollWrapper.offset().left;
      var tableOffsetLeft = table.offset().left;
      var width = scrollWrapperWidth - scrollbarWidth;
      var left = tableOffsetLeft - scrollWrapperOffsetLeft;
      var clipLeft = -left;
      var clipRight = scrollWrapperOffsetLeft - tableOffsetLeft + scrollWrapperWidth - scrollbarWidth; // Write

      stickyHeader.css({
        width: width,
        left: left,
        clip: "rect(0 ".concat(clipRight, "px 100px ").concat(clipLeft, "px)")
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      this.removeStickyHeader();
      this.highlightService.dispose();

      if (this.interactive) {
        this.interactiveTooltipService.dispose();
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(Table.prototype), "dispose", this).call(this);
    }
  }]);
  return Table;
}(BaseChart);

Table.prototype.boundMethods = ['mouseEventHandler', 'tooltipContent', 'sortBy', 'scrollHandler', 'positionStickyHeader']; // Whether events are handled. Set to false to disable interactivity.

Table.prototype.interactive = true;
/** @type {import('../types/types').Dependents<TableData, Table>} */

Table.prototype.dependents = {
  formatLabel: {
    recipe: function recipe(data) {
      return data.formatLabel;
    }
  },
  subjectColumnMode: {
    recipe: function recipe(data) {
      return data.subjectColumnMode;
    }
  },
  multipleTablesMode: {
    recipe: function recipe(data) {
      return data.multipleTablesMode;
    }
  }
}; // Layers
// ------
// Caption
// -------

/** @type {import('../types/types').LayerOptions<TableData, string, Table>} */

Table.prototype.captionLayerConfig = {
  dataBind: function dataBind() {
    /** @type {Table} */
    var chart = this.chart();
    var caption = "Data table for: ".concat(chart.model.title());
    return this.selectAll(selector(CAPTION_CLASS)).data([caption]);
  },
  insert: function insert() {
    return this.insert('caption');
  },
  events: {
    merge: function merge() {
      this.text(_.identity);
    }
  }
}; // Header and sticky header
// ------------------------

/** @type {import('../types/types').LayerOptions<TableData, IdAndName, Table>} */

Table.prototype.theadLayerConfig = {
  dataBind: function dataBind(data) {
    var columns = [// First column for location
    {
      id: SORT_BY_NAME,
      name: I18n.t('table.locationColumn')
    }].concat((0, _toConsumableArray2.default)(data.columns));
    return this.selectAll(selector(THEAD_TH_CLASS)).data(columns, idKey);
  },
  insert: function insert() {
    var chart = this.chart();
    var th = this.append('th').classed(THEAD_TH_CLASS, true).attr('scope', 'column');
    th.append('a').attr('href', '').classed(SORT_LINK_CLASS, true).on('click', chart.sortBy); // Empty element that is used as a spacer in the sticky header

    th.append('div').classed(STICKY_HEADER_SPACER_CLASS, true);
    return th;
  },
  events: {
    merge: function merge() {
      var chart = this.chart();
      var sortId = chart.sortId,
          sortOrder = chart.sortOrder; // Order the selection

      this.order();
      return this.select(selector(SORT_LINK_CLASS)).classed(SORT_LINK_ACTIVE_CLASS, function (d) {
        return d.id === sortId;
      }).text(function (d) {
        var symbol = sortId === d.id && sortOrder === SORT_ORDER_DESC ? '' : '';

        if (d.id === SORT_BY_NAME) {
          return "".concat(d.name, "\xA0").concat(symbol);
        } else {
          return "".concat(symbol, "\xA0").concat(d.name);
        }
      });
    },
    exit: function exit() {
      return this.remove();
    }
  }
}; // Body
// ----

/** @type {import('../types/types').LayerOptions<TableData, LocationWithValues, Table>} */

Table.prototype.tbodyLayerConfig = {
  dataBind: function dataBind(data) {
    return this.selectAll(selector(TBODY_TR_CLASS)).data(data.locationsWithValues, idKey);
  },
  insert: function insert() {
    return this.append('tr').classed(TBODY_TR_CLASS, true);
  },
  events: {
    merge: function merge() {
      var chart = this.chart(); // TR element
      // ----------
      // Order the selection

      this.order(); // Highlighting

      this.each(function (d) {
        return chart.highlightService.update(this, d.id);
      }); // TH element
      // ----------

      var ths = this.selectAll(selector(TBODY_TH_CLASS)).data(function (d) {
        return [d];
      }); // Enter

      ths.enter().append('th').classed(TBODY_TH_CLASS, true).attr('scope', 'row').attr('title', I18n.t('table.highlightLocation')).on('click', function (d) {
        return chart.highlightService.toggle(d.id);
      }); // Merge

      ths.attr('data-id', idKey).text(function (d) {
        return I18n.shortLocation(d);
      }); // Exit

      ths.exit().remove(); // TD elements
      // -----------

      var tds = this.selectAll(selector(TD_CLASS)).data(function (locationWithValues) {
        return locationWithValues.values;
      }); // Enter

      tds.enter().append('td').classed(TD_CLASS, true).append('span').classed(VALUE_CLASS, true); // Merge

      tds.select(selector(VALUE_CLASS)).attr('class', function (d) {
        return chart.valueClassName(d);
      }).text(function (d) {
        return chart.formatLabel(d.value);
      }).each(function (d) {
        if (chart.interactive) {
          return chart.updateValueTooltip(this, d);
        }
      }); // Exit

      var exitSelection = tds.exit(); // Remove tooltips

      if (chart.interactive) {
        exitSelection.select(selector(VALUE_CLASS)).each(function () {
          chart.interactiveTooltipService.remove(this);
        });
      }

      exitSelection.remove();
    },
    exit: function exit() {
      this.remove();
    }
  }
}; // Disposal
// --------

Table.prototype.disposedProperties = ['lastData', 'highlightService', 'interactiveTooltipService'];
module.exports = Table;

},{"../i18n":82,"../util/chart":119,"../util/dom":124,"../util/support":140,"./base-chart":40,"./highlight-service":48,"./interactive-tooltip-service":50,"./tooltip-templates":65,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/toConsumableArray":23,"d3":27,"jquery":"jquery","lodash":"lodash"}],64:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var $ = require('jquery');

var logError = require('../util/logError');

var methodBinding = require('../util/method-binding');

var Tooltip = require('./tooltip');
/** @typedef {import('./tooltip')} Tooltip */

/**
 * @typedef {{
 * target: Element,
 * render: (d: { id: string }) => string,
 * d: { id: string },
 * }} TooltipOptions
 */
// Service for managing tooltips for several targets in one container element.
// Connects the tooltip with a target element.
// Constants
// ---------


var PROPERTY_NAME = 'ddpTooltip';

var TooltipService = /*#__PURE__*/function () {
  // Property declarations
  // ---------------------
  //
  // tooltips: Array
  // container: jQuery
  // tooltipConstructor: Function;
  // propertyName: String

  /**
   * @param {{ container: Element | JQuery<Element> }} options
   */
  function TooltipService(options) {
    (0, _classCallCheck2.default)(this, TooltipService);

    /** @type {Tooltip[]} */
    this.tooltips = [];
    this.container = $(options.container);
    this.bindMethods();
  } // Connecting tooltips with elements
  // ---------------------------------

  /**
   * Returns the tooltip connected to a given element
   *
   * @param {Element} element
   * @returns {Tooltip | undefined}
   */


  (0, _createClass2.default)(TooltipService, [{
    key: "tooltipForElement",
    value: function tooltipForElement(element) {
      return element[this.propertyName];
    }
    /**
     * Connects an element with a tooltip
     *
     * @param {Element} element
     * @param {Tooltip} tooltip
     */

  }, {
    key: "connect",
    value: function connect(element, tooltip) {
      element[this.propertyName] = tooltip;
    }
    /**
     * Disconnects an element from its tooltip
     *
     * @param {Tooltip} tooltip
     */

  }, {
    key: "disconnect",
    value: function disconnect(tooltip) {
      delete tooltip.target[this.propertyName];
    } // Adding and removing
    // -------------------

    /**
     * Creates or updates a tooltip for a given target element.
     * Expects an option object for the Tooltip constructor.
     * Associates the element and the tooltip for reuse.
     * Returns the tooltip.
     *
     * @param {TooltipOptions} options
     */

  }, {
    key: "add",
    value: function add(options) {
      var tooltip = this.tooltipForElement(options.target);

      if (tooltip) {
        // Update existing tooltip
        tooltip.setContent(options.render, options.d);
        return tooltip;
      } else {
        // Create a new tooltip
        return this._add(options);
      }
    }
    /**
     * Creates a new tooltip and returns it.
     *
     * @param {TooltipOptions} options
     * @returns {Tooltip}
     */

  }, {
    key: "_add",
    value: function _add(options) {
      var tooltip = new this.tooltipConstructor({
        container: this.container,
        target: options.target,
        render: options.render,
        d: options.d
      });
      this.tooltips.push(tooltip);
      this.connect(options.target, tooltip);
      return tooltip;
    }
    /**
     * Removes a tooltip from a target element.
     *
     * @param {Element} element
     */

  }, {
    key: "remove",
    value: function remove(element) {
      var tooltip = this.tooltipForElement(element);

      if (!tooltip) {
        return;
      }

      var position = this.tooltips.indexOf(tooltip);

      if (position === -1) {
        logError('Tooltip not registered', this, tooltip);
        return;
      }

      this.tooltips.splice(position, 1);
      this.disconnect(tooltip);
      tooltip.dispose();
    } // Removes all tooltips.

  }, {
    key: "removeAll",
    value: function removeAll() {
      for (var i = 0, l = this.tooltips.length; i < l; i++) {
        var tooltip = this.tooltips[i];
        this.disconnect(tooltip);
        tooltip.dispose();
      }

      this.tooltips = [];
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      this.disposed = true;
      this.removeAll();
    }
  }]);
  return TooltipService;
}();

_.assign(TooltipService.prototype, methodBinding);

TooltipService.prototype.tooltipConstructor = Tooltip;
TooltipService.prototype.propertyName = PROPERTY_NAME; // Disposal
// --------

TooltipService.prototype.disposed = false;
module.exports = TooltipService;

},{"../util/logError":131,"../util/method-binding":134,"./tooltip":66,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"jquery":"jquery","lodash":"lodash"}],65:[function(require,module,exports){
'use strict';

var createTemplate = require('../util/create-template');

module.exports = {
  full: createTemplate("<p class=\"location-and-time-period\">\n  <span class=\"location\">{{location}}</span>\n  <span class=\"time-period\">{{timePeriod}}</span>\n</p>\n<p class=\"value\">{{value}}</p>\n<p class=\"measure\">{{measure}}</p>\n<p class=\"observationStatus\">\n  <strong>{{observationStatusAbbr}}</strong>\n  {{observationStatusDescription}}\n</p>"),
  fullWithSubject: createTemplate("<p class=\"location-and-time-period\">\n  <span class=\"location\">{{location}}</span>\n  <span class=\"time-period\">{{timePeriod}}</span>\n</p>\n<p class=\"subject\">{{subject}}</p>\n<p class=\"value\">{{value}}</p>\n<p class=\"measure\">{{measure}}</p>\n<p class=\"observationStatus\">\n  <strong>{{observationStatusAbbr}}</strong>\n  {{observationStatusDescription}}\n</p>"),
  location: createTemplate("<p class=\"location-and-time-period\">\n  <span class=\"location\">{{location}}</span>\n</p>"),
  timePeriodValue: createTemplate("<p class=\"location-and-time-period\">\n  <span class=\"time-period\">{{timePeriod}}</span>\n</p>\n<p class=\"value\">{{value}}</p>"),
  valueMeasure: createTemplate("<p class=\"value\">{{value}}</p>\n<p class=\"measure\">{{measure}}</p>\n<p class=\"observationStatus\">\n  <strong>{{observationStatusAbbr}}</strong>\n  {{observationStatusDescription}}\n</p>"),
  tableCell: createTemplate("<p class=\"location-and-time-period\">\n  <span class=\"location\">{{location}}</span>\n  <span class=\"time-period\">{{timePeriod}}</span>\n</p>\n<p class=\"subject\">{{subject}}</p>\n<p class=\"observationStatus\">\n  <strong>{{observationStatusAbbr}}</strong>\n  {{observationStatusDescription}}\n</p>"),
  subject: createTemplate("<span class=\"subject\">{{subject}}</span>"),
  locationSubject: createTemplate("<p class=\"location\">{{location}}</p>\n<p class=\"subject\">{{subject}}</p>"),
  turningPoint: createTemplate("<p>{{label}}</p>\n<p class=\"location-and-time-period\">\n  <span class=\"location\">{{location}}</span>\n  <span class=\"time-period\">{{timePeriod}}</span>\n</p>")
};

},{"../util/create-template":121}],66:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var $ = require('jquery');

var methodBinding = require('../util/method-binding');
/** @typedef {'left' | 'right'} TooltipXPlacement */

/** @typedef {'top' | 'center' | 'bottom'} TooltipYPlacement */
// Tooltip that points to an element in the chart.


var PLACEMENT_CLASSES = 'right-top right-center right-bottom left-bottom left-center left-top'.split(/\s+/);
/**
 * @template Datum
 */

var Tooltip = /*#__PURE__*/function () {
  // Property declarations
  // ---------------------
  //
  // container: jQuery
  // target: Element
  // _$target: jQuery
  // element: jQuery
  // className: String
  // render: Function
  //   Render function
  // d: Object
  //   Data point object
  // placement: { x: String, y: String }
  //   Possible placements:
  //   left top, left center, left bottom,
  //   right top, right center, right bottom
  // position: { x: Number, y: Number }
  // _width: Number
  // _height: Number
  // arrowWidth: Number
  // arrowHeight: Number

  /**
   * Creates a new tooltip based on the given options
   *
   * @param {{
   * container: JQuery<Element>,
   * target: Element,
   * render: (d: Datum) => string,
   * d: Datum
   * }} options
   */
  function Tooltip(options) {
    (0, _classCallCheck2.default)(this, Tooltip);
    this.container = options.container;
    this.target = options.target;
    this.render = options.render;
    this.d = options.d;
    this.bindMethods();
  } // Target accessor
  // ---------------
  // Returns the target element wrapped in a jQuery instance.
  // Returns the cached value, calculates it if necessary.


  (0, _createClass2.default)(Tooltip, [{
    key: "$target",
    value: function $target() {
      return this._$target || (this._$target = $(this.target));
    } // Z-index
    // -------

  }, {
    key: "bringToFront",
    value: function bringToFront() {
      if (this.element) {
        this.element.addClass('is-focused');
      }
    }
  }, {
    key: "removeFromFront",
    value: function removeFromFront() {
      if (this.element) {
        this.element.removeClass('is-focused');
      }
    } // Element creation and updating
    // -----------------------------
    // Creates and inserts a new tooltip DOM element.
    // If there already is a DOM element, do not create another one.

  }, {
    key: "createElement",
    value: function createElement() {
      if (this.element) {
        return;
      } // Render the actual HTML now, pass the data and the target


      var html = this.render(this.d, this.target);
      this.element = $('<div>').addClass(this.className).html(html).hover(this.bringToFront, this.removeFromFront).appendTo(this.container);
    } // Removes the tooltip DOM element if available.

  }, {
    key: "removeElement",
    value: function removeElement() {
      if (!this.element) {
        return;
      }

      this.element.remove();
      delete this.element;
    }
    /**
     * Sets a new render function and data.
     * If the tooltip is visible, changes the content immediately.
     *
     * @param {render: (d: Datum) => string} render
     * @param {Datum} d
     */

  }, {
    key: "setContent",
    value: function setContent(render, d) {
      if (this.render === render && _.isEqual(this.d, d)) {
        return;
      }

      this.render = render;
      this.d = d;
      this.invalidateSize();

      if (this.element) {
        var html = render(d, this.target);
        this.element.html(html);
      }
    } // Positioning
    // -----------

    /**
     * Sets this.placement and the according placement HTML classes.
     * Touches the DOM.
     *
     * @param {TooltipXPlacement} x
     * @param {TooltipYPlacement} y
     */

  }, {
    key: "setPlacement",
    value: function setPlacement(x, y) {
      this.placement = {
        x: x,
        y: y
      };
      this.setPlacementClass();
    }
  }, {
    key: "setPlacementClass",
    value: function setPlacementClass() {
      if (!this.element) {
        return;
      }

      var className = "".concat(this.placement.x, "-").concat(this.placement.y);

      if (this.element.hasClass(className)) {
        return;
      }

      var otherClasses = _.without(PLACEMENT_CLASSES, className).join(' ');

      this.element.removeClass(otherClasses).addClass(className);
    } // Returns the width. Returns the cached value, calculates it if necessary.

  }, {
    key: "width",
    value: function width() {
      if (this._width == null) {
        this.calculateSize();
        return this._width;
      } else {
        return this._width;
      }
    } // Returns the height. Returns the cached value, calculates it if necessary.

  }, {
    key: "height",
    value: function height() {
      if (this._height == null) {
        this.calculateSize();
        return this._height;
      } else {
        return this._height;
      }
    } // Calculates the size caches this._width and this._height and
    // sets the size as inline styles.

  }, {
    key: "calculateSize",
    value: function calculateSize() {
      this.element.css({
        // Reset inline size
        width: '',
        height: '',
        // Calculates the element size within the boundaries of the positioned
        // container because the element collapses outside of it.
        top: 0,
        left: 0
      });
      this._width = this.element.outerWidth();
      this._height = this.element.outerHeight(); // Set inline size to prevent a collapse when the element is moved
      // outside of its positioned container. Assumes box-sizing: border-box.

      this.element.css({
        width: this._width,
        height: this._height
      });
    } // Invalidates the size caches this._width and this._height

  }, {
    key: "invalidateSize",
    value: function invalidateSize() {
      delete this._width;
      delete this._height;
    } // Sets this.position according to the placement and target position/size

  }, {
    key: "calculatePositionAtTarget",
    value: function calculatePositionAtTarget() {
      var targetRect = this.target.getBoundingClientRect();
      var targetPosition = this.targetPosition(targetRect);
      var targetSize = this.targetSize(targetRect);
      this.calculatePositionAt(targetPosition.x, targetPosition.y, targetSize.width, targetSize.height);
    }
    /**
     * Sets this.position according to the placement and given position
     *
     * @param {number} x
     * @param {number} y
     * @param {number} targetWidth
     * @param {number} targetHeight
     */

  }, {
    key: "calculatePositionAt",
    value: function calculatePositionAt(x, y) {
      var targetWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var targetHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      this.position = {
        x: x + this.xOffset(targetWidth),
        y: y + this.yOffset(targetHeight)
      };
    }
    /**
     * Returns the tooltips x offset relative to the target position
     *
     * @param {number} targetWidth
     */

  }, {
    key: "xOffset",
    value: function xOffset(targetWidth) {
      var placement = "".concat(this.placement.x, "-").concat(this.placement.y);
      var arrowWidth = this.arrowWidth;

      switch (placement) {
        case 'right-top':
        case 'right-bottom':
          return targetWidth / 2;

        case 'right-center':
          return targetWidth + arrowWidth;

        case 'left-bottom':
        case 'left-top':
          return -this.width() + targetWidth / 2;

        case 'left-center':
          return -this.width() - arrowWidth;

        default:
          return 0;
      }
    }
    /**
     * Returns the tooltips y offset relative to the target position
     * @param {number} targetHeight
     */

  }, {
    key: "yOffset",
    value: function yOffset(targetHeight) {
      var placement = "".concat(this.placement.x, "-").concat(this.placement.y);
      var arrowHeight = this.arrowHeight;

      switch (placement) {
        case 'right-top':
        case 'left-top':
          return -this.height() - arrowHeight;

        case 'right-center':
        case 'left-center':
          return targetHeight / 2 - this.height() / 2 - 1;
        // Magic y offset

        case 'right-bottom':
        case 'left-bottom':
          return targetHeight + arrowHeight;

        default:
          return 0;
      }
    }
    /**
     * Returns the target position relative to the container
     * (the offset parent of the tooltip).
     * Returns { x: Number, y: Number }
     *
     * @param {DOMRect} targetRect
     */

  }, {
    key: "targetPosition",
    value: function targetPosition(targetRect) {
      if (targetRect == null) {
        targetRect = this.target.getBoundingClientRect();
      }

      var targetPosition = this.absoluteTargetPosition(targetRect);
      var containerPosition = this.absoluteContainerPosition();
      return {
        x: targetPosition.x - containerPosition.x,
        y: targetPosition.y - containerPosition.y
      };
    }
    /**
     * Returns the position of the target relative to the viewport
     * (NOT the document).
     * Returns { x: Number, y: Number }
     * @param {DOMRect} targetRect
     */

  }, {
    key: "absoluteTargetPosition",
    value: function absoluteTargetPosition(targetRect) {
      // getBoundingClientRect does not take stroke-width into account,
      // subtract it manually
      var stroke = this.targetStrokeWidth();
      return {
        x: targetRect.left - stroke,
        y: targetRect.top - stroke
      };
    }
    /**
     * Returns the position of the container relative to the viewport
     * (NOT the document).
     * Returns { x: Number, y: Number }
     */

  }, {
    key: "absoluteContainerPosition",
    value: function absoluteContainerPosition() {
      var rect = this.container.get(0).getBoundingClientRect();
      return {
        x: rect.left,
        y: rect.top
      };
    }
    /**
     * Returns the dimensions of the target element.
     * Returns { width: Number, height: Number }
     * @param {DOMRect} targetRect
     */

  }, {
    key: "targetSize",
    value: function targetSize(targetRect) {
      if (targetRect == null) {
        targetRect = this.target.getBoundingClientRect();
      }

      var _targetRect = targetRect,
          width = _targetRect.width,
          height = _targetRect.height; // getBoundingClientRect does not take stroke-width into account,
      // add it manually

      var stroke = 2 * this.targetStrokeWidth();
      width += stroke;
      height += stroke;
      return {
        width: width,
        height: height
      };
    }
    /**
     * Returns the targets stroke-width as a Number
     */

  }, {
    key: "targetStrokeWidth",
    value: function targetStrokeWidth() {
      return parseFloat(getComputedStyle(this.target).strokeWidth);
    }
    /**
     * Returns the bounding box of the tooltip.
     * Returns { x: Number, y: Number, width: Number, height: Number }
     */

  }, {
    key: "boundingBox",
    value: function boundingBox() {
      return {
        x: this.position.x,
        y: this.position.y,
        width: this.width(),
        height: this.height()
      };
    }
    /**
     * Sets the position of the tooltip to this.position, shows the tooltip
     */

  }, {
    key: "applyPosition",
    value: function applyPosition() {
      this.element.css({
        left: this.position.x,
        top: this.position.y,
        // Fade in using a CSS transition
        opacity: 1
      });
    } // Hides the tooltip.

  }, {
    key: "hide",
    value: function hide() {
      if (this.element) {
        this.element.css('opacity', 0);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      this.disposed = true;
      this.removeElement();
    }
  }]);
  return Tooltip;
}(); // Method binding
// --------------


_.assign(Tooltip.prototype, methodBinding); // Properties
// ----------


Tooltip.prototype.boundMethods = ['bringToFront', 'removeFromFront'];
Tooltip.prototype.className = 'tooltip';
Tooltip.prototype.placement = {
  x: 'right',
  y: 'center'
};
Tooltip.prototype.arrowWidth = 10;
Tooltip.prototype.arrowHeight = 10; // Disposal
// --------

Tooltip.prototype.disposed = false;
module.exports = Tooltip;

},{"../util/method-binding":134,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"jquery":"jquery","lodash":"lodash"}],67:[function(require,module,exports){
'use strict';
/** @typedef {import('./types/types').LocaleTree} LocaleTree */
// Wrapper object for the application-wide configuration

var Configuration = {
  load: function load(config) {
    this.config = config;
  },
  get: function get(key) {
    if (this.config) {
      return this.config[key];
    } else {
      return {};
    }
  },
  // Returns all locales
  locales: function locales() {
    return this.config.locales;
  },

  /**
   * Returns the given locale
   *
   * @param {string} code
   * @returns {LocaleTree}
   */
  locale: function locale(code) {
    return this.config.locales[code];
  }
};
module.exports = Configuration;

},{}],68:[function(require,module,exports){
"use strict";

// Standard chart aspect ratio
var ASPECT_RATIO = 16 / 10;
module.exports = ASPECT_RATIO;

},{}],69:[function(require,module,exports){
"use strict";

var CHART_MODES = [{
  name: 'small',
  threshold: 0
}, {
  name: 'reduced',
  threshold: 160
}, {
  name: 'normal',
  threshold: 550
}, {
  name: 'big',
  threshold: 850
}, {
  name: 'large',
  threshold: 1200
}];

if (typeof Object.freeze === 'function') {
  Object.freeze(CHART_MODES);
}

module.exports = CHART_MODES;

},{}],70:[function(require,module,exports){
'use strict'; // Actual chart classes

var BarChart = require('../charts/bar-chart');

var BarPointChart = require('../charts/bar-point-chart');

var BinChart = require('../charts/bin-chart');

var BubbleChart = require('../charts/bubble-chart');

var ClusteredBarChart = require('../charts/clustered-bar-chart');

var EducationChart = require('../charts/education-chart');

var LineChart = require('../charts/line-chart');

var LineMultipleSubjectsChart = require('../charts/line-multiple-subjects-chart');

var MapChart = require('../charts/map-chart');

var MultipleLineChart = require('../charts/multiple-line-chart');

var MultipleTable = require('../charts/multiple-table');

var StackedBarChart = require('../charts/stacked-bar-chart');

var SymbolChart = require('../charts/symbol-chart');
/**
 * @typedef {import('../types/types').ChartDefinition} ChartDefinition
 */

/** @type {{ [key: string]: ChartDefinition }} */


var CHART_TYPES = {
  line: {
    name: 'Line chart',
    constructor: LineChart,
    containerType: 'svg',
    showsMultipleLocations: true,
    shownTimePeriods: Infinity,
    showsMultipleSubjects: false,
    supportsUseLatestData: false,
    supportsSorting: false
  },
  multipleLine: {
    name: 'Line chart with small multiples',
    constructor: MultipleLineChart,
    containerType: 'html',
    showsMultipleLocations: true,
    shownTimePeriods: Infinity,
    showsMultipleSubjects: false,
    supportsUseLatestData: false,
    supportsSorting: false
  },
  lineMultipleSubjects: {
    name: 'Line chart with multiple subjects for one location',
    constructor: LineMultipleSubjectsChart,
    containerType: 'svg',
    showsMultipleLocations: false,
    shownTimePeriods: Infinity,
    showsMultipleSubjects: true,
    supportsUseLatestData: false,
    supportsSorting: false
  },
  bar: {
    name: 'Bar chart',
    constructor: BarChart,
    containerType: 'svg',
    showsMultipleLocations: true,
    shownTimePeriods: 1,
    showsMultipleSubjects: false,
    supportsUseLatestData: true,
    supportsSorting: true
  },
  clusteredBar: {
    name: 'Clustered bar chart',
    constructor: ClusteredBarChart,
    containerType: 'svg',
    showsMultipleLocations: false,
    shownTimePeriods: 2,
    showsMultipleSubjects: true,
    supportsUseLatestData: true,
    supportsSorting: false
  },
  barPoint: {
    name: 'Bar and point chart',
    constructor: BarPointChart,
    containerType: 'svg',
    showsMultipleLocations: true,
    shownTimePeriods: 2,
    showsMultipleSubjects: false,
    supportsUseLatestData: true,
    supportsSorting: true
  },
  stackedBar: {
    name: 'Stacked bar chart',
    constructor: StackedBarChart,
    containerType: 'svg',
    showsMultipleLocations: true,
    shownTimePeriods: 1,
    showsMultipleSubjects: true,
    supportsUseLatestData: true,
    supportsSorting: true
  },
  bin: {
    name: 'Bin chart',
    constructor: BinChart,
    containerType: 'svg',
    showsMultipleLocations: false,
    shownTimePeriods: 1,
    showsMultipleSubjects: false,
    supportsUseLatestData: false,
    supportsSorting: false
  },
  bubble: {
    name: 'Bubble',
    constructor: BubbleChart,
    containerType: 'svg',
    showsMultipleLocations: true,
    shownTimePeriods: 1,
    showsMultipleSubjects: false,
    supportsUseLatestData: false
  },
  education: {
    name: 'Education chart',
    constructor: EducationChart,
    containerType: 'svg',
    showsMultipleLocations: false,
    shownTimePeriods: 1,
    showsMultipleSubjects: false,
    supportsUseLatestData: false,
    supportsSorting: false
  },
  map: {
    name: 'Map',
    constructor: MapChart,
    containerType: 'svg',
    showsMultipleLocations: true,
    shownTimePeriods: 1,
    showsMultipleSubjects: false,
    supportsUseLatestData: true,
    supportsSorting: false
  },
  symbol: {
    name: 'Symbol chart',
    constructor: SymbolChart,
    containerType: 'svg',
    showsMultipleLocations: true,
    shownTimePeriods: 1,
    showsMultipleSubjects: true,
    supportsUseLatestData: true,
    supportsSorting: true
  },
  table: {
    name: 'Table',
    constructor: MultipleTable,
    containerType: 'html',
    showsMultipleLocations: true,
    shownTimePeriods: Infinity,
    showsMultipleSubjects: true,
    supportsUseLatestData: true,
    // The table is sortable but has its own sorting logic.
    supportsSorting: false
  }
};

if (typeof Object.freeze === 'function') {
  Object.freeze(CHART_TYPES);
}

module.exports = CHART_TYPES;

},{"../charts/bar-chart":38,"../charts/bar-point-chart":39,"../charts/bin-chart":42,"../charts/bubble-chart":43,"../charts/clustered-bar-chart":46,"../charts/education-chart":47,"../charts/line-chart":52,"../charts/line-multiple-subjects-chart":53,"../charts/map-chart":55,"../charts/multiple-line-chart":56,"../charts/multiple-table":57,"../charts/stacked-bar-chart":60,"../charts/symbol-chart":62}],71:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var ENV_API = require('env-api');

var FREQUENCIES = require('./frequencies');
/** @typedef {import('../types/types').ChartDataSchema} ChartDataSchema */
// Sources for chart configuration:
// 1. Global chart configuration: window.DDP_CHART_CONFIG.dataAPI
// 2. Defaults in this file
// 3. Environment (ENV_API)
// Subsequent sources will overwrite previous sources.

/**
 * @type {ChartDataSchema}
 */


var DEFAULTS = {
  locations: [],
  highlightedLocations: [],
  highlightLimit: 8,
  subjects: [],
  frequency: FREQUENCIES.ANNUAL,
  showBaseline: true,
  showNonBaseline: true,
  source: '',
  availableCombinations: [],
  storedConfiguration: 'accept',
  mode: 'normal',
  editable: true,
  interactive: true,
  compactHeader: true,
  fixedHeight: false,
  useLatestData: false,
  sorting: 'asc'
};
/**
 * @type {ChartDataSchema}
 */

var DEFAULT_CONFIGURATION = _.merge({}, window.DDP_CHART_CONFIG.dataAPI, ENV_API, DEFAULTS);

if (typeof Object.freeze === 'function') {
  Object.freeze(DEFAULT_CONFIGURATION);
}

module.exports = DEFAULT_CONFIGURATION;

},{"./frequencies":72,"env-api":"env-api","lodash":"lodash"}],72:[function(require,module,exports){
'use strict';
/** @typedef {import('../types/types').Frequency} Frequency */

var ANNUAL = 'A';
var QUARTERLY = 'Q';
var MONTHLY = 'M';
var ANNUAL_REGEXP = /^(\d{4})$/;
var QUARTERLY_REGEXP = /^(\d{4})-Q([1234])$/;
var MONTHLY_REGEXP = /^(\d{4})-(01|02|03|04|05|06|07|08|09|10|11|12)$/;
/**
 * Regular expressions by frequency code
 *
 * @type {{ [key: Frequency]: RegExp }}
 */

var REGEXPS = {};
REGEXPS[ANNUAL] = ANNUAL_REGEXP;
REGEXPS[QUARTERLY] = QUARTERLY_REGEXP;
REGEXPS[MONTHLY] = MONTHLY_REGEXP;
var FREQUENCIES = {
  /** @type {Frequency[]} */
  ALL: [ANNUAL, QUARTERLY, MONTHLY],
  ANNUAL: ANNUAL,
  QUARTERLY: QUARTERLY,
  MONTHLY: MONTHLY,
  ANNUAL_REGEXP: ANNUAL_REGEXP,
  QUARTERLY_REGEXP: QUARTERLY_REGEXP,
  MONTHLY_REGEXP: MONTHLY_REGEXP,
  REGEXPS: REGEXPS
};

if (typeof Object.freeze === 'function') {
  Object.freeze(FREQUENCIES);
}

module.exports = FREQUENCIES;

},{}],73:[function(require,module,exports){
"use strict";

// All location group ids
var LOCATION_GROUP_IDS = ['BRICS', 'EA', 'EA17', 'EA18', 'EA19', 'EU', 'EU21', 'EU27', 'EU27_2020', 'EU28', 'G7M', 'G-7', 'G20', 'G-20', 'G7M', 'NMEC', 'NORDIC', 'OAVG', 'OECD', 'OECDE', 'OEU', 'WLD'];

if (typeof Object.freeze === 'function') {
  Object.freeze(LOCATION_GROUP_IDS);
}

module.exports = LOCATION_GROUP_IDS;

},{}],74:[function(require,module,exports){
'use strict'; // A list of known location groups.
// This list is used to order location lists in the user interface.

var LOCATION_GROUPS = [{
  id: 'OECD',
  // Names here are just for code documentation.
  // The UI labels should come from .Stat / I18n.
  name: 'OECD member countries',
  locations: ['AUS', 'AUT', 'BEL', 'CAN', 'CHL', 'COL', 'CZE', 'DNK', 'EST', 'FIN', 'FRA', 'DEU', 'GRC', 'HUN', 'ISL', 'IRL', 'ISR', 'ITA', 'JPN', 'KOR', 'LUX', 'LVA', 'LTU', 'MEX', 'NLD', 'NZL', 'NOR', 'POL', 'PRT', 'SVK', 'SVN', 'ESP', 'SWE', 'CHE', 'TUR', 'GBR', 'USA', 'CRI']
}, {
  id: 'G7M',
  name: 'Group of 7',
  locations: ['CAN', 'DEU', 'FRA', 'GBR', 'ITA', 'JPN', 'USA']
}, {
  id: 'G20',
  name: 'G20 countries',
  locations: ['ARG', 'AUS', 'BRA', 'CAN', 'CHN', 'DEU', 'FRA', 'GBR', 'IDN', 'IND', 'ITA', 'JPN', 'KOR', 'MEX', 'RUS', 'SAU', 'TUR', 'USA', 'ZAF', 'EU28', 'EU', 'EU27_2020']
}, {
  id: 'BRIICS',
  name: 'BRIICS',
  locations: ['BRA', 'RUS', 'IDN', 'IND', 'CHN', 'ZAF']
}, {
  id: 'EU27',
  name: 'European Union (27 countries, 20072013)',
  locations: ['AUT', 'BEL', 'BGR', 'CYP', 'CZE', 'DEU', 'DNK', 'ESP', 'EST', 'FIN', 'FRA', 'GRC', 'HRV', 'HUN', 'IRL', 'ITA', 'LTU', 'LUX', 'LVA', 'MLT', 'NLD', 'POL', 'PRT', 'ROU', 'SVK', 'SVN', 'SWE']
}, {
  id: 'EU28',
  name: 'European Union (28 countries, 20132020)',
  locations: ['AUT', 'BEL', 'BGR', 'CYP', 'CZE', 'DEU', 'DNK', 'ESP', 'EST', 'FIN', 'FRA', 'GRC', 'GBR', 'HRV', 'HUN', 'IRL', 'ITA', 'LTU', 'LUX', 'LVA', 'MLT', 'NLD', 'POL', 'PRT', 'ROU', 'SVK', 'SVN', 'SWE']
}, {
  id: 'EU27_2020',
  name: 'European Union (27 countries, 2020)',
  locations: ['AUT', 'BEL', 'BGR', 'CYP', 'CZE', 'DEU', 'DNK', 'ESP', 'EST', 'FIN', 'FRA', 'GRC', 'HRV', 'HUN', 'IRL', 'ITA', 'LTU', 'LUX', 'LVA', 'MLT', 'NLD', 'POL', 'PRT', 'ROU', 'SVK', 'SVN', 'SWE']
}, {
  id: 'EA19',
  name: 'Euro zone (19 members, 2015)',
  locations: ['AUT', 'DEU', 'BEL', 'CYP', 'ESP', 'EST', 'FIN', 'FRA', 'GRC', 'IRL', 'ITA', 'LTU', 'LUX', 'LVA', 'MLT', 'NLD', 'PRT', 'SVK', 'SVN']
}, {
  id: 'NORDIC',
  name: 'The Nordic Region total',
  locations: ['DNK', 'FIN', 'ISL', 'NOR', 'SWE', 'ALA', 'FRO', 'GRL']
}];

if (typeof Object.freeze === 'function') {
  Object.freeze(LOCATION_GROUPS);
}

module.exports = LOCATION_GROUPS;

},{}],75:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var $ = require('jquery');

var ChartControl = require('../views/chart-control');

var DevChartControl = require('../views/dev-chart-control'); // Creates chart control for the current page


var ChartControlsController = /*#__PURE__*/function () {
  function ChartControlsController(options) {
    (0, _classCallCheck2.default)(this, ChartControlsController);

    if (options) {
      _.assign(this, options);
    }
  } // Creates chart controls for the given chart views.
  // Expects an array of ChartView instances.


  (0, _createClass2.default)(ChartControlsController, [{
    key: "create",
    value: function create(chartViews) {
      var _this = this;

      // Chart controls on indicator page
      $(this.controlsSelector).each(function (index, el) {
        _this.createChartControl(chartViews, el);
      }); // Chart controls for development

      $(this.devControlsSelector).each(function (index, el) {
        _this.createDevChartControl(chartViews, el);
      });
    }
  }, {
    key: "createChartControl",
    value: function createChartControl(chartViews, el) {
      // Find the corresponding chart view
      var chartEl = $(el).find(this.chartsSelector).get(0);

      if (!chartEl) {
        return;
      }

      var chartView = _.find(chartViews, {
        el: chartEl
      });

      if (!chartView) {
        return;
      }

      var model = chartView.model;
      var chartControl = new ChartControl({
        el: el,
        model: model,
        chartEl: chartEl
      });
      chartControl.render();
    }
  }, {
    key: "createDevChartControl",
    value: function createDevChartControl(chartViews, el) {
      // Use the first chart
      var model = chartViews[0].model;
      var chartControl = new DevChartControl({
        el: el,
        model: model
      });
      chartControl.render();
    }
  }]);
  return ChartControlsController;
}();

ChartControlsController.prototype.controlsSelector = '.indicator-chart-wrapper';
ChartControlsController.prototype.devControlsSelector = '.dev-chart-controls';
ChartControlsController.prototype.chartsSelector = '.ddp-chart';
module.exports = ChartControlsController;

},{"../views/chart-control":152,"../views/dev-chart-control":160,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"jquery":"jquery","lodash":"lodash"}],76:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var $ = require('jquery');

var Backbone = require('backbone');

var urlUtil = require('../util/url');

var I18n = require('../i18n');

var CountryDashboardView = require('../views/country-dashboard-view');

var CountryDashboardShareView = require('../views/country-dashboard-share-view'); // Controller that creates models and views for the country dashboard
// (e.g. https://data.oecd.org/france.htm) and the country dashboard standalone
// share view (currently at https://data.oecd.org/country-dashboard/)


var ALLOWED_CODE = /[^\w]/g;
var ALLOWED_NAME = /[^a-zA-Z ,']/g;

var CountryDashboardController = /*#__PURE__*/function () {
  function CountryDashboardController() {
    (0, _classCallCheck2.default)(this, CountryDashboardController);
  }

  (0, _createClass2.default)(CountryDashboardController, [{
    key: "create",
    value: function create() {
      var _this = this;

      $(this.dashboardSelector).each(function (index, el) {
        _this.createDashboard(el);
      });
      $(this.standaloneShareboxSelector).each(function (index, el) {
        _this.createStandaloneShareView(el);
      });
    }
  }, {
    key: "createDashboard",
    value: function createDashboard(el) {
      var $el = $(el); // Extract model data from the DOM

      var id = $('meta[itemprop="context-param"]').attr('content');
      var name = $el.find('.location-name').eq(0).text().trim();

      if (!id || !name) {
        return;
      }

      id = id.toUpperCase();
      var locale = I18n.locale.toUpperCase();
      var model = new Backbone.Model({
        id: id,
        name: name,
        locale: locale
      });
      new CountryDashboardView({
        el: el,
        model: model
      });
    } // Standalone

  }, {
    key: "createStandaloneShareView",
    value: function createStandaloneShareView(el) {
      // Read model data from query string
      var params = urlUtil.parseQueryString(location.search);
      var id = params.id,
          name = params.name,
          locale = params.locale;

      if (!id || !name || !locale) {
        return;
      } // Sanitize input (will be escaped later anyway)


      id = id.replace(ALLOWED_CODE, '').toUpperCase();
      locale = locale.replace(ALLOWED_CODE, '').toUpperCase();
      name = name.replace(ALLOWED_NAME, '');
      var model = new Backbone.Model({
        id: id,
        name: name,
        locale: locale
      });
      var view = new CountryDashboardShareView({
        el: el,
        model: model
      });
      view.render();
    }
  }]);
  return CountryDashboardController;
}();

CountryDashboardController.prototype.dashboardSelector = '.country-dashboard';
CountryDashboardController.prototype.standaloneShareboxSelector = '.country-dashboard-sharebox-standalone';
module.exports = CountryDashboardController;

},{"../i18n":82,"../util/url":143,"../views/country-dashboard-share-view":158,"../views/country-dashboard-view":159,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"backbone":"backbone","jquery":"jquery"}],77:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var $ = require('jquery');

var PinboardEditorView = require('../views/pinboard-editor-view');

var PinboardEditorController = /*#__PURE__*/function () {
  function PinboardEditorController() {
    (0, _classCallCheck2.default)(this, PinboardEditorController);
  }

  (0, _createClass2.default)(PinboardEditorController, [{
    key: "create",
    value: function create() {
      var el = $(this.selector);

      if (el.length) {
        new PinboardEditorView({
          el: el
        });
      }
    }
  }]);
  return PinboardEditorController;
}();

PinboardEditorController.prototype.selector = '.pinboard-editor';
module.exports = PinboardEditorController;

},{"../views/pinboard-editor-view":167,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"jquery":"jquery"}],78:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var $ = require('jquery');

var Backbone = require('backbone');

var SelectionMediator = require('../models/selection-mediator');

var SelectionsView = require('../views/selections-view');

var SelectionsController = /*#__PURE__*/function () {
  function SelectionsController() {
    (0, _classCallCheck2.default)(this, SelectionsController);
  }

  (0, _createClass2.default)(SelectionsController, [{
    key: "create",
    value: function create() {
      // Initialize mediator
      SelectionMediator.setContext.apply(SelectionMediator, (0, _toConsumableArray2.default)(this.getContext() || [])); // Create views

      var selections = SelectionMediator.selections();

      if (_.size(selections)) {
        // Filter out selections from embedded, for those only show
        // the general notice and remove all
        var filteredSelections = _.filter(selections, function (selection) {
          return selection.context !== 'embedded';
        });

        var model = new Backbone.Model({
          selections: selections,
          filteredSelections: filteredSelections
        });
        var el = $(this.selector).last();
        new SelectionsView({
          model: model,
          el: el
        });
      }
    } // Returns the page context from meta element.
    // Returns an array with the context as first element and
    // optional options as second element.

  }, {
    key: "getContext",
    value: function getContext() {
      var context = $('meta[itemprop="context"]').attr('content');

      switch (context) {
        // Default context if none is set
        case undefined:
          return ['default'];
        // Context-param for country context

        case 'country':
          var location = $('meta[itemprop="context-param"]').attr('content');
          return ['country', {
            highlightedLocations: [location]
          }];
        // Any other context

        default:
          return [context];
      }
    }
  }]);
  return SelectionsController;
}();

SelectionsController.prototype.selector = '.notifications';
module.exports = SelectionsController;

},{"../models/selection-mediator":112,"../views/selections-view":171,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/toConsumableArray":23,"backbone":"backbone","jquery":"jquery","lodash":"lodash"}],79:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var $ = require('jquery');

var urlUtil = require('../util/url');

var ChartData = require('../models/chart-data');

var StandaloneShareView = require('../views/standalone-share-view');

var CODE_REGEXP = /^\w+$/;

var StandaloneShareController = /*#__PURE__*/function () {
  function StandaloneShareController() {
    (0, _classCallCheck2.default)(this, StandaloneShareController);
  }

  (0, _createClass2.default)(StandaloneShareController, [{
    key: "create",
    value: function create() {
      $(this.shareboxSelector).each(function (index, el) {
        var params = urlUtil.parseQueryString(location.search);

        if (!params.id || !params.title || !CODE_REGEXP.test(params.id)) {
          return;
        } // Set up a minimal model


        var model = new ChartData({
          id: params.id,
          title: params.title
        });
        var view = new StandaloneShareView({
          el: el,
          model: model
        });
        view.render();
      });
    }
  }]);
  return StandaloneShareController;
}();

StandaloneShareController.prototype.shareboxSelector = '.sharebox-standalone';
module.exports = StandaloneShareController;

},{"../models/chart-data":92,"../util/url":143,"../views/standalone-share-view":173,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"jquery":"jquery"}],80:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var $ = require('jquery');

var StickyElement = require('../views/sticky-element');

var ProgressMenu = require('../views/progress-menu');

var StickyElementsController = /*#__PURE__*/function () {
  function StickyElementsController() {
    (0, _classCallCheck2.default)(this, StickyElementsController);
    this.init = this.init.bind(this);
  }

  (0, _createClass2.default)(StickyElementsController, [{
    key: "create",
    value: function create() {
      return $(window).load(this.init);
    }
  }, {
    key: "init",
    value: function init() {
      // Sticky header
      var headerStatistics = $(this.stickyHeaderSelector).each(function (index, el) {
        return new StickyElement({
          el: el,
          fixScrollPosition: true
        });
      }); // Sticky sidebars

      var belowSticky = $(this.belowStickySelector);
      var sticky = null;
      $(this.stickySelector).each(function (index, el) {
        return sticky = new StickyElement({
          el: el,
          belowSticky: belowSticky,
          referenceTop: headerStatistics,
          retainSize: true
        });
      }); // Progress menus

      $(this.progressMenuSelector).each(function (_index, el) {
        return new ProgressMenu({
          el: el,
          referenceTop: headerStatistics,
          sticky: sticky
        });
      });
    }
  }]);
  return StickyElementsController;
}();

StickyElementsController.prototype.stickyHeaderSelector = '.header-statistics';
StickyElementsController.prototype.stickySelector = '.sticky';
StickyElementsController.prototype.belowStickySelector = '.below-sticky';
StickyElementsController.prototype.progressMenuSelector = '.topic-aspects .list-filters, .topic-segments .list-filters';
module.exports = StickyElementsController;

},{"../views/progress-menu":169,"../views/sticky-element":174,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"jquery":"jquery"}],81:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var $ = require('jquery');

var Configuration = require('./configuration');

var ERROR_PROPERTIES = [// Native Error properties
'message', 'fileName', 'lineNumber', 'columnNumber', 'stack', // RequestError properties
'responseFromCache', 'responseStatus', 'requestURL', 'responseId', // ChartDataError properties
'chartConfiguration']; // Native error objects do not have enumerable properties,
// so we need to pick the properties manually.

var errorToObject = function errorToObject(error) {
  return _.pick(error, ERROR_PROPERTIES);
};

var errorReducer = function errorReducer(mergedError, error) {
  var errorObject = errorToObject(error);

  _.assign(mergedError, errorObject);

  return mergedError;
}; // Reduces a chain of linked errors to one object that has


var reduceErrorChain = function reduceErrorChain(error) {
  var errors = [error]; // Walk the error chain. An error may reference an original error.

  while (error = error.originalError) {
    errors.push(error);
  } // Merge properties, let the original win


  var mergedError = errors.reduce(errorReducer, {}); // Concat the messages

  mergedError.message = errors.map(function (e) {
    return e.message;
  }).join('\n');
  return mergedError;
};

var ErrorReporter = {
  init: function init() {
    var config = Configuration.get('errorReporting');
    this.enabled = config && config.enabled;
    this.reportURL = config && config.reportURL;

    if (this.enabled) {
      // Add global error handler
      window.onerror = this.globalErrorHandler.bind(this);
    }
  },
  globalErrorHandler: function globalErrorHandler(message, url, lineNumber, columnNumber, error) {
    var mergedError;
    console.log('ErrorReporter.globalErrorHandler', message, url, lineNumber, columnNumber, error); // Internet Explorer fix

    if (!columnNumber) {
      columnNumber = window.event && window.event.errorCharacter;
    }

    if (error) {
      // Do not report errors twice that were reported manually
      if (error.reported) {
        // console.log '\talready reported'
        return;
      }

      mergedError = reduceErrorChain(error);
    }

    this.report({
      message: message,
      scriptURL: url,
      lineNumber: lineNumber,
      columnNumber: columnNumber,
      error: mergedError
    }); // Let the browser handle the error normally, dont swallow it

    return false;
  },
  // Reports an error manually if the browser does not support
  // proper global error handling.
  reportManually: function reportManually(error) {
    if (!this.enabled) {
      return;
    } // console.log 'ErrorReporter.reportManually', error


    error.reported = true;
    this.report({
      message: error.message,
      error: reduceErrorChain(error)
    });
  },
  report: function report(data) {
    if (!this.enabled) {
      return;
    }

    var augmentedData = {
      type: 'failure',
      url: location.href,
      userAgent: navigator.userAgent
    };

    _.assign(augmentedData, data); // console.log(
    //   'ErrorReporter.report\n',
    //   JSON.stringify(augmentedData, null, 2)
    // );


    $.ajax(this.reportURL, {
      type: 'post',
      contentType: 'application/json',
      data: JSON.stringify(augmentedData)
    });
  }
};
module.exports = ErrorReporter;

},{"./configuration":67,"jquery":"jquery","lodash":"lodash"}],82:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var d3 = require('d3');

var Configuration = require('./configuration');

var logError = require('./util/logError');

var memoize = require('./util/memoize');

var stringUtil = require('./util/string');
/** @typedef {import('./types/types').IdAndName} IdAndName */

/** @typedef {import('./types/types').LocaleTree} LocaleTree */
// Internal helpers
// ----------------


var DEFAULT_LOCALE = 'en';

var getLocale = function getLocale() {
  // Read the locale from <html lang="">,
  // fall back to the browser / OS language
  var input = document.documentElement.lang || navigator.language || navigator.userLanguage || navigator.browserLanguage;
  var matches = /^\w+/.exec(input);

  if (!matches) {
    return DEFAULT_LOCALE;
  }

  input = matches[0].toLowerCase();

  for (var locale in Configuration.locales()) {
    if (input === locale) {
      return locale;
    }
  }

  return DEFAULT_LOCALE;
};

var init = function init() {
  var locale = getLocale();
  var localeTree = Configuration.locale(locale);
  I18n.locale = locale;
  I18n.localeTree = localeTree; // Create d3 locale and formatters
  // -------------------------------

  var d3Locale = d3.locale(localeTree.general);
  I18n.d3Locale = d3Locale; // This is taken from the d3 source with changes.
  // We need to create it in the custom locale context.

  I18n.d3TimeFormatter = d3Locale.timeFormat.multi([// Skip milliseconds, seconds, minutes and hours
  ['%a %d', function (d) {
    return d.getDay() && d.getDate() !== 1;
  }], ['%b %d', function (d) {
    return d.getDate() !== 1;
  }], // Use the abbreviated instead of the full month
  ['%b', function (d) {
    return d.getMonth();
  }], ['%Y', function () {
    return true;
  }]]); // Quarterly time formatter

  I18n.d3QuarterlyTimeFormatter = d3Locale.timeFormat.multi([['%Y', function (d) {
    return d.getMonth() === 0;
  }], ['Q2', function (d) {
    return d.getMonth() === 3;
  }], ['Q3', function (d) {
    return d.getMonth() === 6;
  }], ['Q4', function (d) {
    return d.getMonth() === 9;
  }], ['%Y', function () {
    return true;
  }]]);

  if (typeof Object.freeze === 'function') {
    Object.freeze(I18n);
  }

  return I18n;
};
/**
 * Returns the translation for a list of keys. Returns first found translation.
 * Supports [ 'foo.bar.qux', ['foo', 'bar', 'qux'],  ]
 *
 * @param {(string | string[])[]} keys
 */


var translateMultiple = function translateMultiple(keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i]; // Due to memoization, `keys` contains undefined values after
    // the actual values. Stop when encountering undefined.

    if (key === undefined) {
      break;
    }

    var translation = translateSingle(key);

    if (translation != null) {
      return translation;
    }
  }

  return null;
};
/**
 * Returns the translation for a key.
 * Supports 'foo.bar.qux' and ['foo', 'bar', 'qux']
 * @param {string | string[]} key
 */


var translateSingle = function translateSingle(key) {
  if (typeof key === 'string') {
    key = key.split('.');
  }

  var tree = I18n.localeTree;
  var lastIndex = key.length - 1;

  for (var index = 0; index < key.length; index++) {
    var keyPart = key[index];
    tree = tree[keyPart];

    if (tree == null) {
      return null;
    }

    if (index === lastIndex) {
      return tree;
    }
  }

  return null;
};
/**
 * Returns the translation for a given key. Keys are hierarchy paths.
 * Possible calls:
 * t('foo.bar.qux')
 * t(['foo', 'bar', 'qux'])
 * Multiple keys are allowed. If a key cannot be found, the next will be used.
 * t('foo.bar.qux', ['foo', 'bar', 'qux'], )
 * Returns an error string if the translation wasnt found.
 *
 * @param {string | string[]} keys
 */


var t = function t() {
  for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
    keys[_key] = arguments[_key];
  }

  var translation = translateMultiple(keys);

  if (translation == null) {
    var compactKeys = _.compact(keys);

    logError('I18n: Missing translation:', compactKeys);
    return "Missing translation: ".concat(compactKeys);
  }

  return translation;
};
/**
 * Memoize t
 *
 * @type {typeof t}
 */


var memoizedT = memoize(t);
/**
 * Like t() but returns the fallback if the translation wasnt found.
 *
 * @param {string | string[]} args
 */

var translateFallback = function translateFallback() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var adjustedLength = Math.max(args.length, 1);
  var keys = args.slice(0, adjustedLength - 1);
  var val = args[adjustedLength - 1];
  var fallback = val != null ? val : '';
  var left = translateMultiple(keys);
  return left != null ? left : fallback;
}; // Cache the template functions


var templateFunctions = {}; // Gets a template function from the translations and calls it with data.
// Possible calls:
// template('foo.bar.qux', {})
// template(['foo', 'bar', 'qux'], {})

var template = function template(key, data, partials) {
  var cacheKey;

  if (typeof key === 'string') {
    cacheKey = key;
  } else {
    cacheKey = key.join('.');
  }

  var templateFunction = templateFunctions[cacheKey];

  if (!templateFunction) {
    var templateString = translateSingle(key);

    if (templateString == null) {
      logError('I18n: Missing template:', key);
      return function () {
        return "Missing template: ".concat(key);
      };
    }

    templateFunction = stringUtil.createTemplate(templateString);
    templateFunctions[cacheKey] = templateFunction;
  }

  return templateFunction.render(data, partials);
};
/**
 * Shortens a location. Tries to get a special short name from the locale.
 *
 * @param {IdAndName} location
 */


var shortLocation = function shortLocation(location) {
  var id = location.id,
      name = location.name;

  if (id) {
    // Look for a translation
    return translateFallback(['locations', id], name);
  } else {
    return name;
  }
}; // Public interface
// ----------------


var I18n = {
  init: init,

  /** @type {string | null} */
  locale: null,

  /** @type {LocaleTree | null} } */
  localeTree: null,

  /** @type {d3.Locale} | null} */
  d3Locale: null,

  /** @type {d3.time.Format} | null} */
  d3TimeFormatter: null,
  t: memoizedT,
  translateFallback: translateFallback,
  template: template,
  shortLocation: shortLocation
};
module.exports = I18n;

},{"./configuration":67,"./util/logError":131,"./util/memoize":133,"./util/string":139,"d3":27,"lodash":"lodash"}],83:[function(require,module,exports){
"use strict";

var RSVP = require('rsvp');

var logError = require('../util/logError'); // Report all Promise errors if no rejected handler is given


RSVP.on('error', function (reason) {
  logError('Uncaught Promise rejection', reason);

  if (reason instanceof Error) {
    // Find the original error
    var candidate;
    var error = reason;

    while (candidate = error.originalError) {
      if (candidate) {
        error = candidate;
      }
    }

    throw error;
  }
});

},{"../util/logError":131,"rsvp":32}],84:[function(require,module,exports){
'use strict'; // Returns all locations from given model and metadata as { id, name }.
// Expects model: ChartData and metadata: IndicatorMetadata.
// This method is called at least two times:
// 1. data available, metadata not available
// 2. data available, metadata available
// It returns all locations that are known at the time of call.

/**
 * @param {import('./chart-data')} model
 * @param {import('./indicator-metadata')} metadata
 */

var allLocations = function allLocations(model, metadata) {
  var rawMetadata = metadata.get('data');

  if (rawMetadata) {
    return rawMetadata.locations;
  }

  var data = model.get('data');

  if (!data) {
    throw new Error('allLocations: model data not available');
  }

  return data.locationsWithValues;
};

module.exports = allLocations;

},{}],85:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var timePeriodConversion = require('../util/time-period-conversion');
/** @typedef {import('../types/types').Frequency} Frequency */

/** @typedef {import('../types/types').SMFCombinations} SMFCombinations */
// Available combinations
//
// Querying available indicator-subject-measure-frequency-timePeriod
// combinations for given data and metadata models


var AvailableCombinations = /*#__PURE__*/function () {
  // Property declarations
  // ---------------------
  //
  // model: ChartData
  // metadata: IndicatorMetadata
  // smfCombinations: SMFCombinations

  /**
   *
   * @param {import('./chart-data')} model
   * @param {import('./indicator-metadata')} metadata
   */
  function AvailableCombinations(model, metadata) {
    (0, _classCallCheck2.default)(this, AvailableCombinations);
    this.model = model;
    this.metadata = metadata;
  } // Read the available combinations from the model configuration.
  // Converts the availableCombinations array of strings into
  // a usable object format.


  (0, _createClass2.default)(AvailableCombinations, [{
    key: "getSMFCombinations",
    value: function getSMFCombinations() {
      if (this.smfCombinations) {
        return this.smfCombinations;
      }
      /** @type {SMFCombinations} */


      var smfCombinations = this.model.get('availableCombinations').map(function (combination) {
        var array = combination.split('-');
        return {
          subject: array[0],
          measure: array[1],
          frequency: array[2]
        };
      });
      this.smfCombinations = smfCombinations;
      return smfCombinations;
    }
    /**
     * Sets the SMF combinations from another source as the model configuration.
     * @param {SMFCombinations} smfCombinations
     */

  }, {
    key: "setSMFCombinations",
    value: function setSMFCombinations(smfCombinations) {
      this.smfCombinations = smfCombinations;
    } // Measures
    // --------

    /**
     * Returns the available measures for a given subject.
     * Returns an array of measure ids (strings).
     *
     * @param {string} subject
     */

  }, {
    key: "measures",
    value: function measures(subject) {
      var measures = this.getSMFCombinations().filter(function (c) {
        return c.subject === subject;
      }).map(function (c) {
        return c.measure;
      });
      return _.uniq(measures);
    }
    /**
     * Returns matching measures for a given subject and a desired measure.
     * Returns { matches: Array, match: String, fulfilled: Boolean }
     * matches: All matching
     * match: The desired or the first matching
     * fulfilled: Whether the desire could be fulfilled
     *
     * @param {string} subject
     * @param {string} desiredMeasure
     */

  }, {
    key: "matchingMeasure",
    value: function matchingMeasure(subject, desiredMeasure) {
      var matches = this.measures(subject);
      var fulfilled = matches.indexOf(desiredMeasure) >= 0;
      var match = fulfilled ? desiredMeasure : matches[0];
      return {
        matches: matches,
        match: match,
        fulfilled: fulfilled
      };
    } // Frequencies
    // -----------

    /**
     * Returns the available frequencies for a given subject and measure.
     * Returns an array of frequency ids (strings).
     *
     * @param {string} subject
     * @param {string} measure
     */

  }, {
    key: "frequencies",
    value: function frequencies(subject, measure) {
      var frequencies = this.getSMFCombinations().filter(function (c) {
        return c.subject === subject && c.measure === measure;
      }).map(function (c) {
        return c.frequency;
      });
      return _.uniq(frequencies);
    }
    /**
     * Returns matching frequencies for a given subject, measure and
     * a desired frequency.
     * Returns { matches: Array, match: String, fulfilled: Boolean }
     * matches: All matching
     * match: The desired or the first matching
     * fulfilled: Whether the desire could be fulfilled
     *
     * @param {string} subject
     * @param {string} measure
     * @param {Frequency} desiredFrequency
     */

  }, {
    key: "matchingFrequency",
    value: function matchingFrequency(subject, measure, desiredFrequency) {
      var matches = this.frequencies(subject, measure);
      var fulfilled = matches.indexOf(desiredFrequency) >= 0;
      var match = fulfilled ? desiredFrequency : matches[0];
      return {
        matches: matches,
        match: match,
        fulfilled: fulfilled
      };
    } // Time periods
    // These functions do not take SMF combinations into account.
    // ----------------------------------------------------------

    /**
     * Returns the time periods for a given frequency (for all subjects and measures).
     * Returns an array if time period objects
     * or false if the metadata isnt available yet.
     * *
     * @param {Frequency} frequency
     */

  }, {
    key: "timePeriodsForFrequency",
    value: function timePeriodsForFrequency(frequency) {
      var data = this.metadata.get('data');

      if (!data) {
        return false;
      }

      var timePeriods = data.sortedTimePeriods;
      var regExp = timePeriodConversion.regExp(frequency);
      return timePeriods.filter(function (timePeriod) {
        return regExp.test(timePeriod.id);
      });
    }
    /**
     * Returns the first and last time period for a given frequency.
     * (for all subjects and measures).
     * Returns { startTime: Object, endTime: Object }
     * or false if the metadata isnt available yet.
     *
     * @param {Frequency} frequency
     */

  }, {
    key: "timePeriodBoundsForFrequency",
    value: function timePeriodBoundsForFrequency(frequency) {
      var timePeriods = this.timePeriodsForFrequency(frequency);

      if (!timePeriods || !timePeriods.length) {
        return false;
      }

      return {
        startTime: timePeriods[0],
        endTime: _.last(timePeriods)
      };
    }
  }]);
  return AvailableCombinations;
}();

module.exports = AvailableCombinations;

},{"../util/time-period-conversion":141,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"lodash":"lodash"}],86:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var Request = require('./request');

var AvailableDataRequest = /*#__PURE__*/function (_Request) {
  (0, _inherits2.default)(AvailableDataRequest, _Request);

  var _super = _createSuper(AvailableDataRequest);

  function AvailableDataRequest() {
    (0, _classCallCheck2.default)(this, AvailableDataRequest);
    return _super.apply(this, arguments);
  }

  return AvailableDataRequest;
}(Request);

AvailableDataRequest.prototype.url = './data/dimension-combinations.csv';
AvailableDataRequest.prototype.parse = _.identity;
module.exports = AvailableDataRequest;

},{"./request":107,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"lodash":"lodash"}],87:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var d3 = require('d3'); // Create a nested object structure with
// indicators - subjects - measures - frequencies:
//{
//  'PPI': {
//    name: 'Human-readable name',
//    subjects: {
//      'TOT': {
//        name: 'Human-readable name',
//        measures: {
//          'IDX': {
//            name: 'Human-readable name',
//            frequencies: {
//              'A': { name: 'Annual' },
//              'Q': { name: 'Quarterly' },
//              'M': { name: 'Monthly' },
//            }
//          }
//          # 
//        }
//      }
//      # 
//    }
//  }
//  # 
//}


var transformAvailableData = function transformAvailableData(input) {
  return d3.csv.parseRows(input).slice(1).reduce(function (indicators, columns) {
    var _columns = (0, _slicedToArray2.default)(columns, 8),
        indicator = _columns[0],
        indicatorName = _columns[1],
        subject = _columns[2],
        subjectName = _columns[3],
        measure = _columns[4],
        measureName = _columns[5],
        frequency = _columns[6],
        frequencyName = _columns[7];

    if (!indicator) {
      return indicators;
    }

    var indicatorObj = indicators[indicator] || (indicators[indicator] = {
      name: indicatorName,
      subjects: {}
    });
    var subjectObj = indicatorObj.subjects[subject] || (indicatorObj.subjects[subject] = {
      name: subjectName,
      measures: {}
    });
    var measureObj = subjectObj.measures[measure] || (subjectObj.measures[measure] = {
      name: measureName,
      frequencies: {}
    });

    if (!measureObj.frequencies[frequency]) {
      measureObj.frequencies[frequency] = {
        name: frequencyName
      };
    }

    return indicators;
  }, {});
};

module.exports = transformAvailableData;

},{"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/slicedToArray":20,"d3":27}],88:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var AvailableDataRequest = require('./available-data-request');

var transformAvailableData = require('./available-data-transformation');

var AvailableData = /*#__PURE__*/function () {
  function AvailableData() {
    (0, _classCallCheck2.default)(this, AvailableData);
  }

  (0, _createClass2.default)(AvailableData, [{
    key: "fetch",
    value: // Returns a Promise.
    function fetch() {
      return new AvailableDataRequest().send().then(transformAvailableData);
    }
  }]);
  return AvailableData;
}();

module.exports = AvailableData;

},{"./available-data-request":86,"./available-data-transformation":87,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11}],89:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var ChartDataError = /*#__PURE__*/function (_Error) {
  (0, _inherits2.default)(ChartDataError, _Error);

  var _super = _createSuper(ChartDataError);

  function ChartDataError(options) {
    var _this;

    (0, _classCallCheck2.default)(this, ChartDataError);
    _this = _super.call(this, options.message);

    _.assign((0, _assertThisInitialized2.default)(_this), options);

    return _this;
  }

  return ChartDataError;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));

ChartDataError.prototype.name = 'ChartDataError';
module.exports = ChartDataError;

},{"@babel/runtime/helpers/assertThisInitialized":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/wrapNativeSuper":26,"lodash":"lodash"}],90:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var logError = require('../util/logError');

var stringUtil = require('../util/string');

var ChartDataSchema = require('./chart-data-schema');

var ChartData = require('./chart-data');

var ChartDataExtractor = {
  /**
   * Extracts a chart configuration from a given element `el`.
   * Returns a ChartData instance.
   *
   * @param {HTMLElement} el
   */
  fromElement: function fromElement(el) {
    var _this = this;

    var attributes = _.reduce(ChartDataSchema, function (result, type, key) {
      var value = el.getAttribute("data-".concat(stringUtil.dasherize(key)));

      if (value != null) {
        result[key] = _this.parseValue(type, value);
      }

      return result;
    }, {});

    return new ChartData(attributes);
  },

  /**
   * @param {string} type
   * @param {string} value
   */
  parseValue: function parseValue(type, value) {
    if (type === 'list') {
      return _.compact(value.split(/\s*,\s*/));
    } else if (type === 'boolean') {
      value = value.toLowerCase();

      if (value === 'true') {
        return true;
      } else {
        return false;
      }
    } else if (type === 'object') {
      try {
        return JSON.parse(value);
      } catch (e) {
        logError('ChartDataExtractor: Error while parsing a chart configuration', '\nError:', e, '\nValue:', value);
        return undefined;
      }
    } else {
      return value;
    }
  }
};
module.exports = ChartDataExtractor;

},{"../util/logError":131,"../util/string":139,"./chart-data":92,"./chart-data-schema":91,"lodash":"lodash"}],91:[function(require,module,exports){
'use strict'; // Chart configuration options that can be set with HTML data attributes.
// The order here is normative for HTML configuration as well.
// (The order does not matter technically but this is the convention.)
// Possible types: 'string', 'boolean', 'list' (list of strings), 'object'
//
// If you add or change an option here, make sure to adapt it in types.ts
// as well and add it to BASE_KEYS / FETCHED_KEYS / SAVED_KEYS in chart-data.js
// if necessary.

var ChartDataSchema = {
  type: 'string',
  baseUrl: 'string',
  agencyName: 'string',
  dataset: 'string',
  indicator: 'string',
  subject: 'list',
  measure: 'string',
  frequency: 'string',
  startTime: 'string',
  endTime: 'string',
  locations: 'list',
  highlightedLocations: 'list',
  baselineComparison: 'string',
  showBaseline: 'boolean',
  // Deprecated, should not be set in new charts
  showNonBaseline: 'boolean',
  title: 'string',
  subtitle: 'string',
  source: 'string',
  tableNote: 'string',
  referrer: 'string',
  useLatestData: 'boolean',
  forecastStartTime: 'string',
  sorting: 'string',
  context: 'string',
  storedConfiguration: 'string',
  pinboardEditMode: 'boolean',
  language: 'string',
  availableCombinations: 'list',
  externalHeaderId: 'string',
  externalFooterId: 'string',
  compactHeader: 'boolean',
  fixedHeight: 'boolean',
  interactive: 'boolean',
  editable: 'boolean',
  data: 'object'
};

if (typeof Object.freeze === 'function') {
  Object.freeze(ChartDataSchema);
}

module.exports = ChartDataSchema;

},{}],92:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var Backbone = require('backbone');

var RSVP = require('rsvp');

var I18n = require('../i18n');

var Configuration = require('../configuration');

var ErrorReporter = require('../error-reporter');

var CHART_TYPES = require('../constants/chart-types');

var DEFAULT_CONFIGURATION = require('../constants/default-configuration');

var chartUtil = require('../util/chart');

var createTemplate = require('../util/create-template');

var latestDataStartTime = require('../util/latest-data-start-time');

var methodBinding = require('../util/method-binding');

var timePeriodConversion = require('../util/time-period-conversion');

var timeRange = require('../util/time-range');

var urlUtil = require('../util/url');

var HighlightHistory = require('./highlight-history');

var DataRequest = require('./data-request');

var ChartDataError = require('./chart-data-error');

var _require = require('./data-transformation'),
    transformData = _require.transformData;

var _filterLocations = require('./filter-locations');

var ChartSaveRequest = require('./chart-save-request');
/** @typedef {import('../types/types').RawSDMXResponse} RawSDMXResponse */

/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').ChartDataSchema} ChartDataSchema */

/** @typedef {import('../types/types').FetchedKeys} FetchedKeys */

/** @typedef {import('../types/types').BaseKeys} BaseKeys */

/** @typedef {import('../types/types').ChartDataAttributes} ChartDataAttributes */

/** @typedef {import('../types/types').ChartDataFetchedAttributes} ChartDataFetchedAttributes */

/** @typedef {import('../types/types').ChartTitleAttributes} ChartTitleAttributes */
// The main model for chart data.
// Holds the configuration and the visualized data for a chart.
// Fetches data from SDMX JSON API, or uses data from the chart config.
// Options for `Backbone.Model#set`: silent and force


var setSilentAndForce = {
  silent: true,
  force: true
}; // Key configuration
// -----------------

/**
 * Minimal valid chart configuration
 *
 * @type {(keyof ChartDataSchema)[]}
 */

var MANDATORY_KEYS = ['type', 'indicator'];
/**
 * If a chart is not editable, only these keys may be changed.
 *
 * @type {(keyof ChartDataAttributes)[]}
 */

var PUBLIC_KEYS = ['data', 'width', 'height', 'rawWidth', 'rawHeight', 'mode', 'displayType', 'context', 'referrer'];
/**
 * Base keys for transferring (fetching and saving)
 *
 * @type {BaseKeys[]}
 */

var BASE_KEYS = ['dataset', 'language', 'type', 'indicator', 'subjects', 'measure', 'frequency', 'startTime', 'endTime', 'locations', 'highlightedLocations', 'baselineComparison', 'showBaseline', 'showNonBaseline', 'useLatestData', 'forecastStartTime', 'sorting', 'title', 'subtitle'];
/**
 * Keys that trigger a fetch
 *
 * @type {FetchedKeys[]}
 */

var FETCHED_KEYS = BASE_KEYS.concat(['baseUrl', 'agencyName']);
/**
 * Saved keys
 *
 * @type {(keyof ChartDataSchema)[]}
 */

var SAVED_KEYS = BASE_KEYS.concat(['editable', 'compactHeader', 'tableNote', 'source', 'context', 'referrer', 'storedConfiguration', // Saved locally, not remotely
'pinboardEditMode']);
/**
 * @extends {Backbone.Model<ChartDataAttributes>}
 */

var ChartData = /*#__PURE__*/function (_Backbone$Model) {
  (0, _inherits2.default)(ChartData, _Backbone$Model);

  var _super = _createSuper(ChartData);

  // Property declarations
  // ---------------------
  //
  // _fetchRequest: DataRequest
  // _actualHighlightedLocationsCache: Array
  //   Cache of the actual highlighted locations
  function ChartData() {
    var _this;

    (0, _classCallCheck2.default)(this, ChartData);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    /** @type {ChartDataAttributes} */

    _this.attributes;
    _this._actualHighlightedLocationsCache = [];

    _this.bindMethods();

    return _this;
  }

  (0, _createClass2.default)(ChartData, [{
    key: "defaults",
    value: function defaults() {
      var attributes = _.clone(DEFAULT_CONFIGURATION, true); // Add default language


      attributes.language = I18n.locale;
      return attributes;
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.normalizeAttributes(); // Fetch new data on each configuration change

      this.on('change', this.relevantChangeHandler); // Highlighting

      this.on('change:highlightedLocations', this.highlightedLocationsChanged, this);
      this.on('change:data', this.dataChanged, this);
      this.highlightHistory = new HighlightHistory(this);
    } // Normalizes the attributes the model was initialized with

  }, {
    key: "normalizeAttributes",
    value: function normalizeAttributes() {
      // subject/subjects duality: Translate singular `subject` to
      // plural `subjects`, remove singular.
      var subject = this.get('subject');

      if (subject) {
        this.set('subjects', subject, setSilentAndForce);
        this.unset('subject', setSilentAndForce);
      } // Activates use latest data. Calculate `startTime` and remove `endTime`.


      if (this.get('useLatestData')) {
        var startTime = latestDataStartTime(this.get('frequency'));
        this.set('startTime', startTime, setSilentAndForce);
        this.unset('endTime', setSilentAndForce);
      }
    } // Validation
    // ----------
    // Validates the attributes. According to the Backbone convention,
    // returns false when there is no error or a string with an error message.

  }, {
    key: "validate",
    value: function validate() {
      for (var i = 0, l = MANDATORY_KEYS.length; i < l; i++) {
        var key = MANDATORY_KEYS[i];
        var value = this.get(key);

        if (value === undefined || value === '') {
          return "Mandatory attribute ".concat(key, " is empty.");
        }
      } // No error:


      return false;
    } // Change listeners
    // ----------------
    // Fetches new data if relevant attributes have changed.
    // Ignores attributes that are set by the ChartView.
    // Triggers a specific `relevantChange` event.

  }, {
    key: "relevantChangeHandler",
    value: function relevantChangeHandler() {
      var changedAttributes = this.changedAttributes();

      var relevantChanges = _.pickBy(changedAttributes, function (_value, key) {
        return FETCHED_KEYS.indexOf(key) >= 0;
      });

      if (_.size(relevantChanges)) {
        this.trigger('relevantChange', this, relevantChanges);
        this.fetch();
      }
    }
  }, {
    key: "highlightedLocationsChanged",
    value: function highlightedLocationsChanged() {
      // Data can be absent when highlighted locations are set,
      // no need to throw an exception
      if (this.get('data')) {
        this.updateHighlightedLocations();
      }
    }
  }, {
    key: "dataChanged",
    value: function dataChanged() {
      this.updateHighlightedLocations();
    } // Configuration
    // -------------

    /**
     * Get or set the configuration.
     *
     * Setting will create a fresh configuration with default settings,
     * overridden by those passed. If you want to change only some settings,
     * set those directly using regular `set`.
     *
     * @param {ChartDataAttributes} config
     * @param {*} options
     */

  }, {
    key: "config",
    value: function config(_config, options) {
      if (_config != null) {
        // Ignore options with undefined/null values
        var reducer = function reducer(result, value, property) {
          if (value != null) {
            result[property] = value;
          }

          return result;
        };

        _config = _.reduce(_config, reducer, this.defaults()); // Reset settings

        this.clear({
          silent: true
        });
        return this.set(_config, options);
      } else {
        return this.pick(SAVED_KEYS);
      }
    }
    /**
     * Sets an attributes, performs a check if the chart is editable.
     * Only some attributes may be set on non-editable charts.
     * Pass the option { force: true } to bypass the editable check.
     *
     * @param {string | { [key: string]: any }} key
     * @param {any} val
     * @param {(
     * Backbone.ModelSetOptions & { force: boolean, fromChartControl: boolean } | null
     * )} options
     */

  }, {
    key: "set",
    value: function set(key, val, options) {
      /** @type [key: string]: any */
      var attributes;

      if ((0, _typeof2.default)(key) === 'object') {
        attributes = key;
        options = val;
      } else {
        attributes = {};
        attributes[key] = val;
      }

      if (options == null) {
        options = {};
      }

      if (this.attributes.editable === false && options.force !== true) {
        attributes = _.pickBy(attributes, function (_value, keyCandidate) {
          return PUBLIC_KEYS.indexOf(keyCandidate) >= 0;
        });
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(ChartData.prototype), "set", this).call(this, attributes, options);
    } // Attribute shortcuts
    // -------------------
    // Returns the id of the first subject

  }, {
    key: "subject",
    value: function subject() {
      return this.get('subjects')[0];
    } // Returns the URL for the chart.

  }, {
    key: "url",
    value: function url() {
      if (!this.id) {
        throw new Error('ChartData#save: Chart is not saved yet.');
      }

      var _Configuration$get = Configuration.get('chartSaving'),
          embedURL = _Configuration$get.embedURL;

      var url = createTemplate(embedURL).render({
        id: this.id
      });
      url = urlUtil.addCurrentProtocol(url);
      return url;
    } // Returns a full title. Mostly used for sharing.

  }, {
    key: "title",
    value: function title() {
      var singleLocation = this.getSingleLocation();

      var _this$titleAttributes = this.titleAttributes(),
          title = _this$titleAttributes.title,
          subtitle = _this$titleAttributes.subtitle,
          indicator = _this$titleAttributes.indicator,
          subjects = _this$titleAttributes.subjects,
          measure = _this$titleAttributes.measure,
          time = _this$titleAttributes.time;

      if (title) {
        var subtitleSuffix = subtitle ? " \u2013 ".concat(subtitle) : '';
        return "".concat(title).concat(subtitleSuffix);
      }

      return _.compact([indicator, singleLocation, subjects, measure, time]).join(', ');
    }
    /**
     * Returns the name of the first and only location,
     * if the chart types only shows one location.
     * @returns {string | undefined}
     */

  }, {
    key: "getSingleLocation",
    value: function getSingleLocation() {
      var showsMultipleLocations = this.showsMultipleLocations();
      if (showsMultipleLocations) return;
      var data = this.get('data');
      if (!data) return;
      var firstLocation = data.filteredLocationsWithValues[0];
      if (!firstLocation) return;
      return firstLocation.name;
    } // Returns whether the chart type is able to visualize multiple locations.

  }, {
    key: "showsMultipleLocations",
    value: function showsMultipleLocations() {
      var type = this.get('displayType') || this.get('type');
      return CHART_TYPES[type].showsMultipleLocations;
    }
    /**
     * Returns human-readable attributes that are used for various chart titles.
     * startTime, endTime and time reflect the actual start/end time of the chart.
     * time is an intelligent time range
     *
     * @returns {ChartTitleAttributes}
     */

  }, {
    key: "titleAttributes",
    value: function titleAttributes() {
      var data = this.get('data');

      if (!data) {
        throw new Error('ChartData#titleAttributes: data not available');
      } // Base attributes

      /** @type {ChartTitleAttributes} */


      var title = this.get('title');
      var indicator = data.indicator.name;
      var attrs = {
        title: title,
        subtitle: this.get('subtitle'),
        indicator: indicator,
        finalTitle: title || indicator,
        // Subject names separated by /
        subjects: data.subjects.map(function (subject) {
          return subject.name;
        }).join(' / '),
        measure: data.measure.name,
        frequency: data.frequency.name,
        singleLocation: this.getSingleLocation()
      }; // source and sourceWithPrefix: Data source, without or with prefix

      var source = this.get('source');
      attrs.source = source;
      var prefix = I18n.t('chartHeader.sourcePrefix');

      if (source && source.indexOf(prefix) === -1) {
        attrs.sourceWithPrefix = "".concat(prefix, " ").concat(source);
      } // startTime and endTime: Formatted time periods


      var _this$formattedTimes = this.formattedTimes(),
          startTime = _this$formattedTimes.startTime,
          endTime = _this$formattedTimes.endTime;

      attrs.startTime = startTime;
      attrs.endTime = endTime;

      var _timeRange = timeRange(startTime, endTime, this.shownTimePeriods(), this.get('useLatestData')),
          time = _timeRange.time,
          shortTime = _timeRange.shortTime;

      attrs.time = time;
      attrs.shortTime = shortTime;
      return attrs;
    }
    /**
     * Human-readable, actual start and end times
     */

  }, {
    key: "formattedTimes",
    value: function formattedTimes() {
      var frequency = this.get('frequency');
      var startTime = timePeriodConversion.longTimePeriod(frequency, this.actualStartTime().id);
      var endTime = timePeriodConversion.longTimePeriod(frequency, this.actualEndTime().id);
      return {
        startTime: startTime,
        endTime: endTime
      };
    } // Returns the first time period in the data response, not the request.
    // For example, the request might have a startTime of 1990 but the first
    // data point returned by .Stat might be from 1995.
    // Returns { id: String, name: String }

  }, {
    key: "actualStartTime",
    value: function actualStartTime() {
      var data = this.get('data');

      if (!data) {
        throw new Error('ChartData#actualStartTime: data not available');
      }

      return data.timePeriods[0];
    } // Returns the last time period in the data response, not the request.
    // Returns { id: String, name: String }

  }, {
    key: "actualEndTime",
    value: function actualEndTime() {
      var data = this.get('data');

      if (!data) {
        throw new Error('ChartData#actualEndTime: data not available');
      }

      return _.last(data.timePeriods);
    } // Returns how many time periods the chart type is able to visualize.

  }, {
    key: "shownTimePeriods",
    value: function shownTimePeriods() {
      var type = this.get('displayType') || this.get('type');
      return CHART_TYPES[type].shownTimePeriods;
    } // Highlighted locations
    // ---------------------
    // Updates objects depending on highlighted locations

  }, {
    key: "updateHighlightedLocations",
    value: function updateHighlightedLocations() {
      this.updateActualHighlightedLocations();
      this.highlightHistory.update();
    }
    /**
     * Returns the highlight number for a given location id.
     *
     * @param {string} id
     */

  }, {
    key: "highlightNumber",
    value: function highlightNumber(id) {
      return this.highlightHistory.highlightNumber(id);
    } // Returns the highlighted locations for which data was returned,
    // sorted by id. Caches its results for performance.
    // Returns an array of location ids.

  }, {
    key: "actualHighlightedLocations",
    value: function actualHighlightedLocations() {
      if (!this._actualHighlightedLocationsCache) {
        this.updateActualHighlightedLocations();
      }

      return this._actualHighlightedLocationsCache;
    } // Invalidates the actual highlighted locations cache.

  }, {
    key: "updateActualHighlightedLocations",
    value: function updateActualHighlightedLocations() {
      this._actualHighlightedLocationsCache = this._actualHighlightedLocations();
    } // Calculates the highlighted locations for which data was returned.
    // Returns an array of location ids.

  }, {
    key: "_actualHighlightedLocations",
    value: function _actualHighlightedLocations() {
      /** @type {string[]} */
      var highlighted = this.get('highlightedLocations');
      var data = this.get('data');

      if (!data) {
        throw new Error('ChartData#_actualHighlightedLocations: data not available');
      }

      var all = data.locationsWithValues;
      var actual;

      if (all) {
        // Regular charts
        actual = all.map(chartUtil.idKey).filter(function (id) {
          return highlighted.indexOf(id) >= 0;
        });
      } else {
        // Custom Country Dashboard charts: data is already an array.
        // Return a copy.
        actual = highlighted.slice();
      }

      return actual.sort();
    } // Fetching
    // --------
    // Returns a Promise.

  }, {
    key: "fetchInitially",
    value: function fetchInitially() {
      var data = this.get('data');

      if (data) {
        // Use the data from the HTML configuration.
        this.normalizeDataFromConfig();
        this.trigger('fetch:success');
        return RSVP.Promise.resolve(data);
      } else {
        // Fetch from remote
        return this.fetch();
      }
    } // Normalizes the data extracted from the HTML configuration.

  }, {
    key: "normalizeDataFromConfig",
    value: function normalizeDataFromConfig() {
      /** @type {RawSDMXResponse | string[] | RawChartData} */
      var data = this.get('data');

      if (!data) {
        return;
      } // Detect SDMX


      if (data.header && data.dataSets && data.structure) {
        // Transform SDMX
        data = transformData(data, this.get('subjects'));
        data = this.filterLocations(data);
        this.set('data', data);
      } else if (data.length) {
        // Data for custom Country Dashboard charts
        // (Income inequality and CO2 emissions)
        // Extract highlighted locations
        var highlightedLocations = data.filter(function (location) {
          return location.id && location.highlighted;
        }).map(chartUtil.idKey); // Avoid fetching

        this.set('highlightedLocations', highlightedLocations, {
          silent: true
        });
        this.updateHighlightedLocations();
      }
    }
    /**
     * Fetches the data for the current configuration from
     * the remote SDMX JSON API.
     *
     * @returns {RSVP.Promise<RawChartData>}
     */

  }, {
    key: "fetch",
    value: function fetch() {
      // Validation
      if (!this.isValid()) {
        this.trigger('config:invalid');
        return RSVP.Promise.reject("ChartData: Configuration invalid: ".concat(this.validationError));
      } // Abort running fetch request


      if (this._fetchRequest) {
        this._fetchRequest.abort(); // Trigger fetch:error synchronously before fetch:start.
        // The Promise is rejected asynchronously.


        this.trigger('fetch:error', 'aborted');
      } // Engage!


      this.trigger('fetch:start');
      this._fetchRequest = new DataRequest();
      return this._fetchRequest.send(this.attributesForFetch()).then(this.filterLocations).then(this.finishFetch).catch(this.fetchError);
    }
    /**
     * @returns {ChartDataFetchedAttributes}
     */

  }, {
    key: "attributesForFetch",
    value: function attributesForFetch() {
      return this.pick(FETCHED_KEYS);
    }
    /**
     * Filters locations according to the baseline configuration.
     * Returns a shallow copy of data. Creates data.filteredLocationsWithValues.
     *
     * @param {RawChartData} data
     */

  }, {
    key: "filterLocations",
    value: function filterLocations(data) {
      return _filterLocations(data, this.get('showBaseline'), this.get('showNonBaseline'), this.get('baselineComparison'), this.get('highlightedLocations'));
    }
    /**
     * Saves the data, triggers change:data and fetch:success events.
     *
     * @param {RawChartData} data
     */

  }, {
    key: "finishFetch",
    value: function finishFetch(data) {
      delete this._fetchRequest;
      this.set('data', data);
      this.trigger('fetch:success');
      return data;
    }
    /**
     * Triggers a fetch:error event and rejects the promise.
     *
     * @param {Error} error
     */

  }, {
    key: "fetchError",
    value: function fetchError(error) {
      // Ignore abort errors. These errors occur often
      // when using the chart interface.
      // If the request was aborted, _fetchRequest already points
      // to the new, running request.
      if (error.message === 'aborted') {
        return;
      }

      delete this._fetchRequest;
      this.trigger('fetch:error', error); // Wrap original error into ChartDataError

      var chartDataError = new ChartDataError({
        message: 'Chart data fetch error',
        chartConfiguration: this.attributesForFetch(),
        originalError: error
      }); // Report error if not handled globally

      ErrorReporter.reportManually(chartDataError); // Reject the promise returned by then().
      // Make sure errors are visible in the console.

      throw error;
    } // Saving
    // ------

    /**
     * Saves the chart on the server.
     * Options:
     * withData: Boolean
     *   Tells the server to take a snapshot of the data. The data isnt
     *   transmitted, but the server fetches it. Defaults to false.
     *
     * @param {{ withData?: boolean }}} options
     */

  }, {
    key: "save",
    value: function save() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // Validate
      if (!this.isValid()) {
        this.trigger('config:invalid');
        return RSVP.Promise.reject("ChartData: Configuration invalid: ".concat(this.validationError));
      } // Engage!


      if (this._saveRequest) {
        this._saveRequest.abort();
      }

      this.trigger('save:start');
      this._saveRequest = new ChartSaveRequest();
      return this._saveRequest.send(this.attributesForSave(options)).then(this.finishSave, this.saveError);
    }
    /**
     * @param {{ withData: boolean }} options
     */

  }, {
    key: "attributesForSave",
    value: function attributesForSave(options) {
      var attributes = this.toJSON(); // Add metadata title for <title>, meta tags

      attributes.metadataTitle = this.title(); // Add referrer

      if (!attributes.referrer) {
        attributes.referrer = "//".concat(location.host).concat(location.pathname);
      } // Add context


      var _location = location,
          hostname = _location.hostname;

      if (!attributes.context) {
        attributes.context = hostname.match('(^|.)oecd-ilibrary.org$') ? 'OECD iLibrary' : hostname.match('(^|.)nordic-ilibrary.org$') ? 'Nordic iLibrary' : 'OECD';
      } // Add an empty data attribute to tell the server to
      // save the chart along with data.


      if (options.withData) {
        attributes.data = '';
      } // Make saved chart non-editable


      attributes.editable = false;
      return attributes;
    }
    /**
     * Triggers a save:success event and cleans up.
     *
     * @param {{ id: string }} data
     */

  }, {
    key: "finishSave",
    value: function finishSave(data) {
      delete this._saveRequest;
      this.set('id', data.id);
      this.trigger('save:success');
      return data;
    }
    /**
     * Triggers a save:error event and rejects the promise.
     *
     * @param {Error} reason
     */

  }, {
    key: "saveError",
    value: function saveError(reason) {
      delete this._saveRequest;
      this.trigger('save:error', reason); // Reject the promise returned by then().
      // Make sure errors are visible in the console.

      throw reason;
    } // Serialization
    // -------------
    // Returns an object with saved keys/values

  }, {
    key: "toJSON",
    value: function toJSON() {
      // subject/subjects duality: Translate plural `subjects` to
      // singular `subject`.
      var savedKeys = _.without(SAVED_KEYS, 'subjects');

      var object = this.pick(savedKeys);
      object.subject = this.attributes.subjects;
      return object;
    }
  }]);
  return ChartData;
}(Backbone.Model); // Method binding
// --------------


_.assign(ChartData.prototype, methodBinding);

ChartData.prototype.boundMethods = ['relevantChangeHandler', 'fetch', 'filterLocations', 'finishFetch', 'fetchError', 'finishSave', 'saveError'];
module.exports = ChartData;

},{"../configuration":67,"../constants/chart-types":70,"../constants/default-configuration":71,"../error-reporter":81,"../i18n":82,"../util/chart":119,"../util/create-template":121,"../util/latest-data-start-time":128,"../util/method-binding":134,"../util/time-period-conversion":141,"../util/time-range":142,"../util/url":143,"./chart-data-error":89,"./chart-save-request":93,"./data-request":95,"./data-transformation":96,"./filter-locations":97,"./highlight-history":98,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/typeof":24,"backbone":"backbone","lodash":"lodash","rsvp":32}],93:[function(require,module,exports){
'use strict'; // const _ = require('lodash');

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Configuration = require('../configuration');

var Request = require('./request');

var urlUtil = require('../util/url'); // const RSVP = require('rsvp');


var ChartSaveRequest = /*#__PURE__*/function (_Request) {
  (0, _inherits2.default)(ChartSaveRequest, _Request);

  var _super = _createSuper(ChartSaveRequest);

  function ChartSaveRequest() {
    (0, _classCallCheck2.default)(this, ChartSaveRequest);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(ChartSaveRequest, [{
    key: "url",
    value: function url() {
      return urlUtil.addCurrentProtocol(Configuration.get('chartSaving').saveURL);
    }
  }, {
    key: "body",
    value: function body() {
      return JSON.stringify(this.config);
    }
  }, {
    key: "send",
    value: function send(config) {
      // console.log('ChartSaveRequest#send\n', JSON.stringify(config, null, '  '));
      return (0, _get2.default)((0, _getPrototypeOf2.default)(ChartSaveRequest.prototype), "send", this).call(this, config);
    } // Development: Fake the response, generate a random ID and
    // resolve the promise after a delay.

    /*
    send(config) {
      this.config = config;
      console.log('DEV ChartSaveRequest#send\n', JSON.stringify(config, null, '  '));
      const data = { id: _.uniqueId('fake-chart-id-') };
      const latency = 1;
      return new RSVP.Promise((fulfill, reject) => {
        const fulfillAndDispose = () => {
          fulfill(data);
          return this.dispose();
        };
        const rejectAndDispose = () => {
          reject('Faked saving error');
          return this.dispose();
        };
        this.resolvePromise = fulfillAndDispose;
        this.rejectPromise = rejectAndDispose;
        setTimeout(fulfillAndDispose, latency);
      });
    }
    */

  }]);
  return ChartSaveRequest;
}(Request); // Production: Remote saving


ChartSaveRequest.prototype.method = 'POST'; // Development: Testing locally

/*
ChartSaveRequest.prototype.method = 'GET';
ChartSaveRequest.prototype.url = '../data/chart-saving.json';
*/
// Using text/plain instead of application/json for now
// to support IE9 XDomainRequest. See:
// http://web.archive.org/web/20200724160942/https://docs.microsoft.com/en-us/archive/blogs/ieinternals/xdomainrequest-restrictions-limitations-and-workarounds

ChartSaveRequest.prototype.requestHeaders = {
  'Content-Type': 'text/plain'
};
module.exports = ChartSaveRequest;

},{"../configuration":67,"../util/url":143,"./request":107,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],94:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var sdmxUrl = require('./sdmx-url'); // Returns an SDMX API URL in the CSV format.
// Expects an API config hash and a params hash (opt).


var csvSdmxUrl = function csvSdmxUrl(config, params) {
  var fullParams = {
    contentType: 'csv',
    detail: 'code',
    separator: 'comma',
    'csv-lang': config.language
  };

  _.assign(fullParams, params);

  return sdmxUrl(config, fullParams);
};

module.exports = csvSdmxUrl;

},{"./sdmx-url":111,"lodash":"lodash"}],95:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var SDMXRequest = require('./sdmx-request');

var RequestCache = require('./request-cache');

var _require = require('./data-transformation'),
    transformData = _require.transformData;

var RequestError = require('./request-error');

var ID_REG_EXP = /\{"id"\s*:\s*"([^"]+)"/;

var DataRequest = /*#__PURE__*/function (_SDMXRequest) {
  (0, _inherits2.default)(DataRequest, _SDMXRequest);

  var _super = _createSuper(DataRequest);

  function DataRequest() {
    (0, _classCallCheck2.default)(this, DataRequest);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(DataRequest, [{
    key: "parse",
    value:
    /**
     * @param {string} inputData
     * @returns {RawChartData}
     */
    function parse(inputData) {
      // Parse as JSON
      var jsonData = (0, _get2.default)((0, _getPrototypeOf2.default)(DataRequest.prototype), "parse", this).call(this, inputData); // Transform SDMX

      var data;

      try {
        data = transformData(jsonData, this.config.subjects);
      } catch (originalError) {
        throw new RequestError({
          message: 'Data transformation failed',
          originalError: originalError
        });
      }

      return data;
    }
  }, {
    key: "additionalErrorData",
    value: function additionalErrorData() {
      var data = (0, _get2.default)((0, _getPrototypeOf2.default)(DataRequest.prototype), "additionalErrorData", this).call(this);
      var xhr = this._xhr;

      if (xhr && xhr.responseText) {
        var matches = String(xhr.responseText).match(ID_REG_EXP);

        if (matches) {
          data.responseId = matches[1];
        }
      }

      return data;
    }
  }]);
  return DataRequest;
}(SDMXRequest); // The cache is shared on the prototype by all instances.


DataRequest.prototype.cache = new RequestCache(20);
module.exports = DataRequest;

},{"./data-transformation":96,"./request-cache":105,"./request-error":106,"./sdmx-request":109,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],96:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var d3 = require('d3');

var mathUtil = require('../util/math');

var _require = require('../util/chart'),
    dValue = _require.dValue,
    sortByDateAsc = _require.sortByDateAsc,
    sortByNameAsc = _require.sortByNameAsc,
    sortByOrder = _require.sortByOrder;

var SDMXResponse = require('./sdmx-response');
/**
 * @typedef {import('../types/types').IdAndName} IdAndName
 * @typedef {import('../types/types').LocationWithValues} LocationWithValues
 * @typedef {import('../types/types').DataPoint} DataPoint
 * @typedef {import('../types/types').RawChartData} RawChartData
 */

/*
Output format:
{
  indicator: { id: 'CPI', name: 'Consumer Price Index' }
  subjects: [
    { id: 'ALL', name: 'Total' }
  ]
  measure: { id: 'A_GRWTH', name: 'Annual growth rate' }
  frequency: { id: 'A', name: 'Annual' }
  properties: {
    mixedSigns: false
  }
  timePeriods: [
    { id: '2009', name: '2009', date: Date }
    { id: '2010', name: '2010', date: Date }
    { id: '2011', name: '2011', date: Date }
  ]
  subjectsWithValues: [
    {
      id: 'ALL'
      name: 'Total',
      locationsWithValues: [
        {
          id: 'USA'
          name: 'United States'
          values: [
            {
              id: 'USA', name: 'United States',
              subject: 'ALL', subjectName: 'Total',
              timePeriod: '2009', timePeriodName: '2009', date: Date,
              value: 5.3, status: null
            }
            {
              id: 'USA', name: 'United States',
              subject: 'ALL', subjectName: 'Total',
              timePeriod: '2010', timePeriodName: '2010', date: Date,
              value: 6.0, status: null
            }
            {
              id: 'USA', name: 'United States',
              subject: 'ALL', subjectName: 'Total',
              timePeriod: '2011', timePeriodName: '2011', date: Date,
              value: 7.2, status: { id: 'B', name: 'Break' }
            }
          ]
          extent: [5.3, 7.2]
        }
        {
          id: 'DEU'
          name: 'Germany'
          values: [
            {
              id: 'DEU', name: 'Germany',
              subject: 'ALL', subjectName: 'Total',
              timePeriod: '2009', timePeriodName: '2009', date: Date,
              value: 3.4, status: null
            }
            {
              id: 'DEU', name: 'Germany',
              subject: 'ALL', subjectName: 'Total',
              timePeriod: '2010', timePeriodName: '2010', date: Date,
              value: 4.0, status: null
            }
            {
              id: 'DEU', name: 'Germany',
              subject: 'ALL', subjectName: 'Total',
              timePeriod: '2011', timePeriodName: '2011', date: Date,
              value: 5.6, status: null
            }
          ]
          extent: [3.4, 5.6]
        }
      ]
    }
  ],
  locationWithValues: <Reference to the locationWithValues
    of the first subject>
}
*/
// Ignore data points with these observation status


var PURGE_OBSERVATION_STATUS = ['C', 'H', 'L', 'M', 'N']; // Helper functions for creating objects
// -------------------------------------

/**
 * Creates a locationWithValues
 *
 * @param {IdAndName} location
 * @return {LocationWithValues}
 */

var createLocation = function createLocation(location) {
  return {
    id: location.id,
    name: location.name,
    values: [],
    // Will be set to [Number, Number]
    extent: null
  };
};
/**
 * Creates a data point
 *
 * @param {IdAndName} location
 * @param {IdAndName} subject
 * @param {IdAndName} timePeriod
 * @param {number} value
 * @param {IdAndName} observationStatus
 * @returns {DataPoint}
 */


var dataPoint = function dataPoint(location, subject, timePeriod, value, observationStatus) {
  return {
    id: location.id,
    name: location.name,
    subject: subject.id,
    subjectName: subject.name,
    timePeriod: timePeriod.id,
    timePeriodName: timePeriod.name,
    date: timePeriod.date,
    value: value,
    status: observationStatus
  };
};

var NoDataReturnedError = /*#__PURE__*/function (_Error) {
  (0, _inherits2.default)(NoDataReturnedError, _Error);

  var _super = _createSuper(NoDataReturnedError);

  function NoDataReturnedError() {
    (0, _classCallCheck2.default)(this, NoDataReturnedError);
    return _super.apply(this, arguments);
  }

  return NoDataReturnedError;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
/**
 * @param {RawSDMXResponse} input
 * @param {string[]} orderedSubjects
 * @returns {RawChartData}
 */


var transformData = function transformData(input, orderedSubjects) {
  var response = new SDMXResponse(input);

  if (response.isEmpty()) {
    throw new NoDataReturnedError('dataTransformation: No data returned');
  }

  if (response.isCompactFormat()) {
    return transformCompact(response, orderedSubjects);
  }

  throw new Error('dataTransformation: Normal format not implemented');
};
/**
 * @param {SDMXResponse} response
 * @param {string[]} orderedSubjects
 * @returns {RawChartData}
 */


var transformCompact = function transformCompact(response, orderedSubjects) {
  // Properties
  // ----------
  var properties = {
    mixedSigns: false
  }; // Indicator, subjects, measure, frequency
  // ---------------------------------------

  var indicator = response.pickDimension(response.getIndicator()); // Unsorted subjects, original order

  var subjects = response.getSubjects().map(response.pickDimension); // Sorted subjects, configuration order

  var sortedSubjects = sortByOrder(subjects, orderedSubjects);
  var measure = response.pickDimension(response.getMeasure());
  var frequency = response.pickDimension(response.getFrequency()); // Time periods
  // ------------
  // Unsorted time periods, original order

  var timePeriods = response.getFullTimePeriods(); // Time periods sorted by date

  var sortedTimePeriods = response.getSortedTimePeriods(); // Subjects with locations with values
  // -----------------------------------
  // Read locations and values

  var inputLocations = response.getLocations();
  var inputValues = response.getValues(); // Create unsorted subjectsWithValues

  var subjectsWithValues = subjects.map(function (subject) {
    return {
      id: subject.id,
      name: subject.name,
      locationsWithValues: inputLocations.map(createLocation)
    };
  }); // Create sorted subjectsWithValues

  var sortedSubjectsWithValues = sortByOrder(subjectsWithValues, orderedSubjects); // Create a shortcut to the first subject (configuration order)

  var firstSubjectValues = sortedSubjectsWithValues[0].locationsWithValues; // Dimension indices

  var locationDimensionIndex = response.getLocationIndex();
  var subjectDimensionIndex = response.getSubjectIndex();
  var measureDimensionIndex = response.getMeasureIndex();
  var timePeriodDimensionIndex = response.getTimePeriodIndex(); // We need a variable to store the sign of the first present value != 0

  var firstSign = null; // Process input values
  // --------------------

  for (var key in inputValues) {
    var valueAndAttributes = inputValues[key];
    var dimensions = key.split(':').map(Number); // Filter values for unwanted measures.
    // Currently only one measure is supported.

    var measureIndex = dimensions[measureDimensionIndex];

    if (measureIndex !== 0) {
      continue;
    } // The value is packed in an array with meta information


    var _valueAndAttributes = (0, _toArray2.default)(valueAndAttributes),
        value = _valueAndAttributes[0],
        attributeIndices = _valueAndAttributes.slice(1); // Determine whether values have mixed signs


    if (!properties.mixedSigns) {
      var sign = mathUtil.sign(value);

      if (!firstSign) {
        firstSign = sign;
      }

      if (sign !== 0 && !isNaN(sign) && sign !== firstSign) {
        properties.mixedSigns = true;
      }
    } // Extract observation status


    var observationStatus = response.observationStatus(attributeIndices); // Purge value if necessary

    var cleanValue = observationStatus && PURGE_OBSERVATION_STATUS.indexOf(observationStatus.id) >= 0 ? null : value; // Get subject

    var subjectIndex = dimensions[subjectDimensionIndex];
    var subjectWithValues = subjectsWithValues[subjectIndex]; // Get location

    var locationIndex = dimensions[locationDimensionIndex];
    var locationWithValues = subjectWithValues.locationsWithValues[locationIndex]; // Get time period

    var timePeriodIndex = dimensions[timePeriodDimensionIndex];
    var timePeriod = timePeriods[timePeriodIndex]; // Create new datum

    var datum = dataPoint(locationWithValues, subjectWithValues, timePeriod, cleanValue, observationStatus); // Insert the data point at the index of the time period

    locationWithValues.values[timePeriodIndex] = datum;
  } // Post-processing
  // ---------------
  // Post-process locations


  for (var i = 0, l = subjectsWithValues.length; i < l; i++) {
    var _subjectWithValues = subjectsWithValues[i];
    var locationsWithValues = _subjectWithValues.locationsWithValues; // Sort locations in-place by name

    locationsWithValues.sort(sortByNameAsc); // Post-process values

    for (var j = 0, l2 = locationsWithValues.length; j < l2; j++) {
      var _locationWithValues = locationsWithValues[j];
      var values = _locationWithValues.values; // Fill missing data points with a null data point

      for (var k = 0, l3 = timePeriods.length; k < l3; k++) {
        var _timePeriod = timePeriods[k];

        if (values[k] === undefined) {
          var _datum = dataPoint(_locationWithValues, _subjectWithValues, _timePeriod, null, null);

          values[k] = _datum;
        }
      } // Add extent per locationWithValue


      _locationWithValues.extent = d3.extent(values, dValue); // Sort values in-place by time period

      values.sort(sortByDateAsc);
    }
  } // Create the output object


  return {
    properties: properties,
    indicator: indicator,
    subjects: sortedSubjects,
    measure: measure,
    frequency: frequency,
    timePeriods: sortedTimePeriods,
    subjectsWithValues: sortedSubjectsWithValues,
    locationsWithValues: firstSubjectValues
  };
};

module.exports = {
  transformData: transformData,
  NoDataReturnedError: NoDataReturnedError
};

},{"../util/chart":119,"../util/math":132,"./sdmx-response":110,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/toArray":22,"@babel/runtime/helpers/wrapNativeSuper":26,"d3":27}],97:[function(require,module,exports){
'use strict';

var _ = require('lodash');
/** @param {import('../types/types').RawChartData} RawChartData */

/** @param {import('../types/types').LocationWithValues} LocationWithValues */

/**
 * Filters locations according to the visibility and highlighting configuration.
 * For a given data object, returns a copy augmented with
 * `filteredLocationsWithValues`.
 *
 * @param {RawChartData} data
 * @param {boolean} showBaseline
 * @param {boolean} showNonBaseline
 * @param {strring} baselineComparison
 * @param {string[]} highlightedLocations
 * @returns {RawChartData}
 */


var filterLocations = function filterLocations(data, showBaseline, showNonBaseline, baselineComparison, highlightedLocations) {
  var filterEnabled = !(showBaseline && showNonBaseline);
  /**
   * Filter function that returns whether the location is visible
   *
   * @param {LocationWithValues} location
   */

  var locationFilter = function locationFilter(location) {
    var id = location.id;
    return (showBaseline || id !== baselineComparison) && (showNonBaseline || id === baselineComparison) || highlightedLocations.indexOf(id) >= 0;
  };

  var dataCopy = _.clone(data); // Filter the locations for each subject


  dataCopy.subjectsWithValues = dataCopy.subjectsWithValues.map(function (subject) {
    var subjectCopy = _.clone(subject); // Create filtered locations


    subjectCopy.filteredLocationsWithValues = filterEnabled ? subjectCopy.locationsWithValues.filter(locationFilter) : subjectCopy.locationsWithValues;
    return subjectCopy;
  }); // Update shortcuts to the first subject

  var firstSubject = dataCopy.subjectsWithValues[0];
  dataCopy.locationsWithValues = firstSubject.locationsWithValues;
  dataCopy.filteredLocationsWithValues = firstSubject.filteredLocationsWithValues;
  return dataCopy;
};

module.exports = filterLocations;

},{"lodash":"lodash"}],98:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var arrayUtil = require('../util/array'); // Records the history of location highlighting for a ChartData model.
// Assigns a highlight number to each location.


var HighlightHistory = /*#__PURE__*/function () {
  /**
   * @param {import('./chart-data')} model
   */
  function HighlightHistory(model) {
    (0, _classCallCheck2.default)(this, HighlightHistory);
    this.model = model;
    this.update();
  } // Updates the history when the actual highlighted locations change.


  (0, _createClass2.default)(HighlightHistory, [{
    key: "update",
    value: function update() {
      // actualHighlightedLocations requires the data to be loaded.
      if (!this.model.get('data')) {
        return;
      }

      var history = this.history;

      if (!history) {
        history = [];
      }

      var highlightedLocations = this.model.actualHighlightedLocations(); // If an id was removed, remove it from history.
      // Filter the existing history, creating a sparse array.

      var reducer = function reducer(result, id, highlightNumber) {
        if (highlightedLocations.indexOf(id) >= 0) {
          result[highlightNumber] = id;
        }

        return result;
      };

      history = history.reduce(reducer, []); // If an id was added, assign a highlight number and add it to the history.

      for (var i = 0, l = highlightedLocations.length; i < l; i++) {
        var id = highlightedLocations[i];

        if (history.indexOf(id) === -1) {
          var highlightNumber = this.nextHighlightNumber(history);
          history[highlightNumber] = id;
        }
      }

      this.history = history; // Create a map for quick lookup

      this.historyById = arrayUtil.valueMap(history);
    } // Returns the next unassigned highlight number for the given history.
    // Returns an integer number.

  }, {
    key: "nextHighlightNumber",
    value: function nextHighlightNumber(history) {
      var historyLength = history.length;

      if (historyLength === 0) {
        return 0;
      }

      for (var highlightNumber = 0; highlightNumber < history.length; highlightNumber++) {
        // Found a gap, re-assign
        var id = history[highlightNumber];

        if (id == null) {
          return highlightNumber;
        }
      } // No gaps found, assign next


      return historyLength;
    } // Returns the highlight number for the given location id.
    // Returns a number >= 1 and < highlightLimit or false
    // if the location is not highlighted.

  }, {
    key: "highlightNumber",
    value: function highlightNumber(id) {
      var number = this.historyById.get(id);

      if (number != null) {
        return number % this.model.get('highlightLimit') + 1;
      } else {
        return false;
      }
    }
  }]);
  return HighlightHistory;
}();
/**
 * Array with highlight number => location id, possibly sparse
 * e.g. [ 0: 'DEU', 1: 'AUS', 3: 'USA', 4: 'FRA'  ]
 *
 * @type {string[] | null}
 */


HighlightHistory.prototype.history = null;
/**
 * d3.map with location id => highlight number for quick lookup
 * e.g. d3.map(DEU: 0, AUS: 1, USA: 3, FRA: 4 )
 *
 * @type {{ [key: string]: number } | null}
 */

HighlightHistory.prototype.historyById = null;
module.exports = HighlightHistory;

},{"../util/array":118,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11}],99:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var SDMXRequest = require('./sdmx-request');

var transformIndicatorMetadata = require('./indicator-metadata-transformation');

var RequestCache = require('./request-cache');

var IndicatorMetadataRequest = /*#__PURE__*/function (_SDMXRequest) {
  (0, _inherits2.default)(IndicatorMetadataRequest, _SDMXRequest);

  var _super = _createSuper(IndicatorMetadataRequest);

  function IndicatorMetadataRequest() {
    var _this;

    (0, _classCallCheck2.default)(this, IndicatorMetadataRequest);
    _this = _super.call(this);
    /**
     * @type {(
     * import('../types/types').ChartDataAttributes &
     * { calculateAvailableCombinations: boolean }
     * )} */

    _this.config;
    return _this;
  }

  (0, _createClass2.default)(IndicatorMetadataRequest, [{
    key: "parameters",
    value: function parameters() {
      var params = (0, _get2.default)((0, _getPrototypeOf2.default)(IndicatorMetadataRequest.prototype), "parameters", this).call(this); // Do not request data, only metadata

      params.detail = 'SeriesKeysOnly';
      return params;
    }
    /**
     * @param {string} responseText
     * @returns {import('../types/types').RawIndicatorMetadata}
     */

  }, {
    key: "parse",
    value: function parse(responseText) {
      /** @type {import('../types/types').RawSDMXResponse} */
      var response = (0, _get2.default)((0, _getPrototypeOf2.default)(IndicatorMetadataRequest.prototype), "parse", this).call(this, responseText);
      return transformIndicatorMetadata(response, this.config.calculateAvailableCombinations);
    }
  }]);
  return IndicatorMetadataRequest;
}(SDMXRequest); // The cache is shared on the prototype by all instances.


IndicatorMetadataRequest.prototype.cache = new RequestCache(20);
module.exports = IndicatorMetadataRequest;

},{"./indicator-metadata-transformation":100,"./request-cache":105,"./sdmx-request":109,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],100:[function(require,module,exports){
'use strict';

var SDMXResponse = require('./sdmx-response');
/** @typedef {import('../types/types').RawSDMXResponse} RawSDMXResponse */

/** @typedef {import('../types/types').IdAndName} IdAndName */

/** @typedef {import('../types/types').RawIndicatorMetadata} RawIndicatorMetadata */

/** @typedef {import('../types/types').SmfCombination} SmfCombination */

/**
 * @param {RawSDMXResponse} input
 * @returns {RawIndicatorMetadata}
 */


var transformIndicatorMetadata = function transformIndicatorMetadata(input) {
  var calculateAvailableCombinations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var response = new SDMXResponse(input);
  var dimensions = response.getDimensions();

  if (dimensions.length === 0) {
    throw new Error('transformIndicatorMetadata: No data returned');
  }

  var subjects = response.getSubjects();
  var measures = response.getMeasures();
  var frequencies = response.getFrequencies(); // Unsorted time periods, original order

  var timePeriods = response.getTimePeriods(); // Time periods sorted by date

  var sortedTimePeriods = response.getSortedTimePeriods();
  var locations = response.getSortedLocations();
  var availableCombinations = calculateAvailableCombinations ? getAvailableCombinations(response, subjects, measures, frequencies) : null;
  return {
    locations: locations,
    subjects: subjects,
    measures: measures,
    frequencies: frequencies,
    timePeriods: timePeriods,
    sortedTimePeriods: sortedTimePeriods,
    availableCombinations: availableCombinations
  };
};
/**
 * Walks through all data points and compiles the possible SMF combinations.
 *
 * @param {SDMXResponse} response
 * @param {IdAndName[]} subjects
 * @param {IdAndName[]} measures
 * @param {IdAndName[]} frequencies
 * @returns {SmfCombinations}
 */


var getAvailableCombinations = function getAvailableCombinations(response, subjects, measures, frequencies) {
  var inputValues = response.getValues();
  var subjectDimensionIndex = response.getSubjectIndex();
  var measureDimensionIndex = response.getMeasureIndex();
  var frequencyDimensionIndex = response.getFrequencyIndex();
  var seenCombinations = {};

  for (var key in inputValues) {
    var dimensions = key.split(':');
    var subjectIndex = dimensions[subjectDimensionIndex];
    var measureIndex = dimensions[measureDimensionIndex];
    var frequencyIndex = dimensions[frequencyDimensionIndex];
    var seenKey = "".concat(subjectIndex, ":").concat(measureIndex, ":").concat(frequencyIndex);
    seenCombinations[seenKey] = true;
  }

  var smfCombinations = [];

  for (var _key in seenCombinations) {
    var _dimensions = _key.split(':');
    /** @type {SmfCombination} */


    var smfCombination = {
      subject: subjects[_dimensions[0]].id,
      measure: measures[_dimensions[1]].id,
      frequency: frequencies[_dimensions[2]].id
    };
    smfCombinations.push(smfCombination);
  }

  return smfCombinations;
};

module.exports = transformIndicatorMetadata;

},{"./sdmx-response":110}],101:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var Backbone = require('backbone');

var DEFAULT_CONFIGURATION = require('../constants/default-configuration');

var IndicatorMetadataRequest = require('./indicator-metadata-request');
/** @typedef {import('../types/types').RawSDMXResponse} RawSDMXResponse */

/** @typedef {import('../types/types').ChartDataSchema} ChartDataSchema */

/** @typedef {import('../types/types').RawIndicatorMetadata} RawIndicatorMetadata */

/** @typedef {ChartDataSchema & { data: RawIndicatorMetadata }} IndicatorMetadataAttributes} */

/**
 * @typedef
 * @extends {Backbone.Model<IndicatorMetadataAttributes>}
 */


var IndicatorMetadata = /*#__PURE__*/function (_Backbone$Model) {
  (0, _inherits2.default)(IndicatorMetadata, _Backbone$Model);

  var _super = _createSuper(IndicatorMetadata);

  function IndicatorMetadata() {
    var _this;

    (0, _classCallCheck2.default)(this, IndicatorMetadata);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.finishFetch = _this.finishFetch.bind((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(IndicatorMetadata, [{
    key: "defaults",
    value: function defaults() {
      return _.assign({}, DEFAULT_CONFIGURATION, {
        // All dimensions for the given indicator. This requests a lot of data!
        subject: '',
        measure: '',
        frequency: ''
      });
    } // Fetching
    // --------

    /**
     * @returns {RawIndicatorMetadata}
     */

  }, {
    key: "fetch",
    value: function fetch() {
      if (this._request) {
        this._request.abort();
      }

      this._request = new IndicatorMetadataRequest();

      var config = _.assign({
        calculateAvailableCombinations: true
      }, this.attributes); // Engage!


      return this._request.send(config).then(this.finishFetch, this.fetchError);
    }
    /**
     * Saves the data
     *
     * @param {RawIndicatorMetadata} data
     * @returns {RawIndicatorMetadata}
     */

  }, {
    key: "finishFetch",
    value: function finishFetch(data) {
      this.set('data', data);
      return data;
    }
    /**
     * @param {Error} reason
     */

  }, {
    key: "fetchError",
    value: function fetchError(reason) {
      // Reject the promise returned by then().
      // Make sure errors are visible in the console.
      throw reason;
    }
  }]);
  return IndicatorMetadata;
}(Backbone.Model);

module.exports = IndicatorMetadata;

},{"../constants/default-configuration":71,"./indicator-metadata-request":99,"@babel/runtime/helpers/assertThisInitialized":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"backbone":"backbone","lodash":"lodash"}],102:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var Pinboard = require('./pinboard'); // Mediates access to the pinboard model


var PINBOARD_EDIT_MODE = 'pinboardEditMode';

var PinboardMediator = /*#__PURE__*/function () {
  // Property declarations
  // ---------------------
  //
  // model: Pinboard
  function PinboardMediator() {
    (0, _classCallCheck2.default)(this, PinboardMediator);
    // Creates the pinbord model, fetching it locally.
    this.model = new Pinboard();
    this.model.fetch();
  }

  (0, _createClass2.default)(PinboardMediator, [{
    key: "isActive",
    value: function isActive() {
      return this.model.isActive();
    } // Gets or sets the layout.
    // Saves the pinboard locally on setting.

  }, {
    key: "layout",
    value: function layout(_layout) {
      if (_layout) {
        this.model.layout(_layout);
        this.model.saveLocally();
      } else {
        return this.model.layout();
      }
    } // Gets or sets the charts.
    // Saves the pinboard locally on setting.

  }, {
    key: "charts",
    value: function charts(_charts) {
      if (_charts) {
        this.model.charts(_charts);
        this.model.saveLocally();
      } else {
        return this.model.charts();
      }
    } // Adding and removing charts
    // --------------------------
    // Adds a chart to the pinboard and saves it locally.

  }, {
    key: "addChart",
    value: function addChart(model) {
      this.model.addChart(model);
      this.model.saveLocally();
    } // Removes a chart from the pinboard and saves it locally.

  }, {
    key: "removeChart",
    value: function removeChart(model) {
      this.model.removeChart(model);
      this.model.saveLocally();
    } // Editing charts
    // --------------
    // Activate the edit mode for a given chart,
    // deactivates the edit mode for all others.
    // Saves the pinboard locally.

  }, {
    key: "enterEditMode",
    value: function enterEditMode(chart) {
      var charts = this.model.charts();

      for (var i = 0, l = charts.length; i < l; i++) {
        var otherChart = charts[i];
        otherChart.set(PINBOARD_EDIT_MODE, otherChart === chart, {
          force: true
        });
      }

      this.model.saveLocally();
    } // Deactivates the edit mode for a given chart.
    // Saves the pinboard locally.

  }, {
    key: "leaveEditMode",
    value: function leaveEditMode(chart) {
      chart.unset(PINBOARD_EDIT_MODE, {
        force: true
      });
      this.model.saveLocally();
    } // Gets the first chart that is in edit mode

  }, {
    key: "editableChart",
    value: function editableChart() {
      return _.find(this.model.charts(), function (chart) {
        return chart.get(PINBOARD_EDIT_MODE);
      });
    } // Updates a chart in the pinboard with the attributes of another chart.
    // Expects two ChartData objects. Saves the pinboard locally.

  }, {
    key: "updateChart",
    value: function updateChart(chart, sourceChart) {
      this.model.updateChart(chart, sourceChart);
      this.model.saveLocally();
    } // Saving the pinboard
    // -------------------
    // Saves the pinboard remotely. Returns a promise.

  }, {
    key: "save",
    value: function save() {
      // Stop editing
      var charts = this.model.charts();

      for (var i = 0, l = charts.length; i < l; i++) {
        var chart = charts[i];
        chart.unset(PINBOARD_EDIT_MODE, {
          force: true
        });
      }

      return this.model.save();
    }
  }]);
  return PinboardMediator;
}();

module.exports = new PinboardMediator();

},{"./pinboard":104,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"lodash":"lodash"}],103:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Configuration = require('../configuration');

var Request = require('./request');

var urlUtil = require('../util/url');

var PinboardSaveRequest = /*#__PURE__*/function (_Request) {
  (0, _inherits2.default)(PinboardSaveRequest, _Request);

  var _super = _createSuper(PinboardSaveRequest);

  function PinboardSaveRequest() {
    (0, _classCallCheck2.default)(this, PinboardSaveRequest);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(PinboardSaveRequest, [{
    key: "url",
    value: function url() {
      return urlUtil.addCurrentProtocol(Configuration.get('pinboard').saveURL);
    }
  }, {
    key: "body",
    value: function body() {
      return JSON.stringify(this.config);
    } // Fake the response for now, generate an ID and
    // resolve the promise after some time

    /*
    send(config) {
      console.log('PinboardSaveRequest#send', this.config);
      this.config = config;
      const data = {id: _.uniqueId('faked_pinboard_id_')};
      return new RSVP.Promise((fulfill, reject) => {
        const fulfillAndDispose = () => {
          fulfill(data);
          this.dispose();
        };
        const rejectAndDispose = () => {
          reject('Faked saving error');
          this.dispose();
        };
        this.resolvePromise = fulfillAndDispose;
        this.rejectPromise = rejectAndDispose;
        const successProbability = 1;
        const resolve = Math.random() >= (1 - successProbability) ?
          fulfillAndDispose
        :
          rejectAndDispose;
        setTimeout(resolve, 2000);
      });
    }
    */

  }]);
  return PinboardSaveRequest;
}(Request); // Remote


PinboardSaveRequest.prototype.method = 'POST'; // Testing locally
// PinboardSaveRequest.prototype.method = 'GET';
// PinboardSaveRequest.prototype.url = '../data/pinboard-saving.json';
// Using text/plain instead of application/json for now
// to support IE9 XDomainRequest. See http://bit.ly/1cWFGqx

PinboardSaveRequest.prototype.requestHeaders = {
  'Content-Type': 'text/plain'
};
module.exports = PinboardSaveRequest;

},{"../configuration":67,"../util/url":143,"./request":107,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],104:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var Backbone = require('backbone');

var Configuration = require('../configuration');

var I18n = require('../i18n');

var createTemplate = require('../util/create-template');

var urlUtil = require('../util/url');

var stores = require('../util/stores');

var methodBinding = require('../util/method-binding');

var ChartData = require('./chart-data');

var PinboardSaveRequest = require('./pinboard-save-request');

var STORAGE_KEY = 'pinboard'; // The Pinboard model holds ChartData models and metadata
// for the current user-created pinboard.
// Configuration for charts added to the pinboard.

var PINBOARD_CHART_CONFIG = {
  // Charts may carry their configuration over to the indicator page.
  storedConfiguration: 'impose',
  context: 'OECD',
  // Disallow compact header
  compactHeader: false,
  // Make the chart non-editable
  editable: false
};
var LAYOUT = 'layout';
var CHARTS = 'charts';

var Pinboard = /*#__PURE__*/function (_Backbone$Model) {
  (0, _inherits2.default)(Pinboard, _Backbone$Model);

  var _super = _createSuper(Pinboard);

  function Pinboard() {
    var _this;

    (0, _classCallCheck2.default)(this, Pinboard);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.bindMethods();

    return _this;
  } // Public getters and setters
  // --------------------------
  // layout: one of 'small-tiles', 'primary-with-secondaries', 'vertical'
  // charts: Array of chart configurations


  (0, _createClass2.default)(Pinboard, [{
    key: "defaults",
    value: function defaults() {
      return {
        layout: 'small-tiles',
        charts: []
      };
    } // Returns whether local pinboard saving works.

  }, {
    key: "isActive",
    value: function isActive() {
      return stores.permanent.enabled;
    } // Gets or sets the layout attribute.
    // Expects a String on setting.

  }, {
    key: "layout",
    value: function layout(_layout) {
      if (_layout) {
        return this.set(LAYOUT, _layout);
      } else {
        return this.get(LAYOUT);
      }
    } // Gets or sets the charts attribute.
    // Expects an array of ChartData on setting.

  }, {
    key: "charts",
    value: function charts(_charts) {
      if (_charts) {
        return this.set(CHARTS, _charts);
      } else {
        return this.get(CHARTS);
      }
    } // Adding, updating and removing charts
    // ------------------------------------
    // Adds a chart configuration to the pinboard.
    // Expects a ChartData model, creates a copy.

  }, {
    key: "addChart",
    value: function addChart(sourceModel) {
      var model = new ChartData(sourceModel.toJSON());
      model.set(PINBOARD_CHART_CONFIG);
      var charts = this.charts().concat(model);
      this.charts(charts);
    } // Updates a chart in the pinboard from another chart.
    // Expects two ChartData models.

  }, {
    key: "updateChart",
    value: function updateChart(model, sourceModel) {
      var forceOptions = {
        force: true
      };
      model.set(sourceModel.toJSON(), forceOptions);
      model.set(PINBOARD_CHART_CONFIG, forceOptions);
    }
  }, {
    key: "removeChart",
    value: function removeChart(model) {
      this.charts(_.without(this.charts(), model));
    } // Fetching
    // --------
    // Synchronous fetch from the local storage

  }, {
    key: "fetch",
    value: function fetch() {
      var attributes = stores.permanent.get(STORAGE_KEY);

      if (attributes && attributes.charts) {
        // Create ChartData models
        attributes.charts = attributes.charts.map(function (chartAttributes) {
          return new ChartData(chartAttributes);
        });
        this.set(attributes);
      }

      return this;
    } // Saving
    // ------
    // Returns the URL for the pinboard.

  }, {
    key: "url",
    value: function url() {
      if (!this.id) {
        throw new Error('Pinboard#save: Pinboard is not saved yet.');
      }

      var _Configuration$get = Configuration.get('pinboard'),
          embedURL = _Configuration$get.embedURL;

      var url = createTemplate(embedURL).render({
        id: this.id
      });
      url = urlUtil.addCurrentProtocol(url);
      return url;
    } // Synchronous save to the local storage.

  }, {
    key: "saveLocally",
    value: function saveLocally() {
      // This calls toJSON on all ChartData models because
      // this is how JSON.stringify is defined
      stores.permanent.set(STORAGE_KEY, this.attributes);
    } // Asynchronous save to the remote API. Returns a promise.

  }, {
    key: "save",
    value: function save() {
      if (this._saveRequest) {
        this._saveRequest.abort();
      }

      this.trigger('save:start');
      this._saveRequest = new PinboardSaveRequest();
      return this._saveRequest.send(this.attributesForSave()).then(this.saveSuccess, this.saveError);
    }
  }, {
    key: "attributesForSave",
    value: function attributesForSave() {
      var attributes = this.toJSON(); // Omit id if already set

      delete attributes.id; // Add current language

      attributes.language = I18n.locale;
      return attributes;
    }
  }, {
    key: "saveSuccess",
    value: function saveSuccess(data) {
      delete this._saveRequest;
      this.set('id', data.id);
      this.trigger('save:success', data);
      return data;
    }
  }, {
    key: "saveError",
    value: function saveError(reason) {
      delete this._saveRequest;
      this.trigger('save:error', reason); // Reject the promise returned by then().
      // Make sure errors are visible in the console.

      throw reason;
    }
  }]);
  return Pinboard;
}(Backbone.Model); // Method binding
// --------------


_.assign(Pinboard.prototype, methodBinding);

Pinboard.prototype.boundMethods = ['saveSuccess', 'saveError'];
module.exports = Pinboard;

},{"../configuration":67,"../i18n":82,"../util/create-template":121,"../util/method-binding":134,"../util/stores":138,"../util/url":143,"./chart-data":92,"./pinboard-save-request":103,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"backbone":"backbone","lodash":"lodash"}],105:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var RequestCache = /*#__PURE__*/function () {
  function RequestCache(length) {
    (0, _classCallCheck2.default)(this, RequestCache);

    if (length != null) {
      this.length = length;
    }

    this._keys = [];
    this._cache = {};
  }

  (0, _createClass2.default)(RequestCache, [{
    key: "get",
    value: function get(id) {
      if (id != null && id in this._cache) {
        return this._cache[id];
      } else {
        return null;
      }
    }
  }, {
    key: "set",
    value: function set(id, data) {
      this._cache[id] = data; // (Re)insert the item at the beginning

      this._keys = _.without(this._keys, id);

      this._keys.unshift(id); // If max length is reached, drop last item


      if (this._keys.length >= this.length) {
        var dropId = this._keys.pop();

        delete this._cache[dropId];
      }
    }
  }]);
  return RequestCache;
}(); // Default size for retained requests


RequestCache.prototype.length = 10; // Store keys of cached requests (Array of IDs)

RequestCache.prototype._keys = null; // Actual cache (Object ID => response)

RequestCache.prototype._cache = null;
module.exports = RequestCache;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"lodash":"lodash"}],106:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var RequestError = /*#__PURE__*/function (_Error) {
  (0, _inherits2.default)(RequestError, _Error);

  var _super = _createSuper(RequestError);

  /** @param {{ message: string, originalError?: Error }} options */
  function RequestError(options) {
    var _this;

    (0, _classCallCheck2.default)(this, RequestError);
    _this = _super.call(this, options.message);

    _.assign((0, _assertThisInitialized2.default)(_this), options);

    return _this;
  }

  return RequestError;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));

RequestError.prototype.name = 'RequestError';
module.exports = RequestError;

},{"@babel/runtime/helpers/assertThisInitialized":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/wrapNativeSuper":26,"lodash":"lodash"}],107:[function(require,module,exports){
/* global XDomainRequest */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var RSVP = require('rsvp');

var urlUtil = require('../util/url');

var disposal = require('../util/disposal');

var methodBinding = require('../util/method-binding');

var RequestError = require('./request-error');
/** @typedef {import('./request-cache')} RequestCache */
// Generic Request class.
// Parses the response as JSON per default.
// Uses a cache if `cache` is set to a RequestCache.

/**
 * @template {{ [key: string]: any }} Config
 * @template {{ [key: string]: any }} Response
 */


var Request = /*#__PURE__*/function () {
  // Property declarations
  // ---------------------
  //
  // cache: RequestCache
  //   The cache is shared on the prototype by all instances.
  // config: Object
  // url: String or Function that is called
  // method: String or Function that is called
  // body: any, can be a Function that is called
  // _url: String
  // _xhr: XMLHttpRequest
  // promise: Promise
  // resolvePromise: Function
  // rejectPromise: Function
  // responseFromCache: Boolean
  // requestHeaders: Object
  function Request() {
    (0, _classCallCheck2.default)(this, Request);
    this.bindMethods();
  }
  /**
   * Sends a request with the given configuration.
   * Returns a Promise that is fulfilled with the parsed response.
   *
   * @param {Config} config
   * @returns {Promise<Response>}
   */


  (0, _createClass2.default)(Request, [{
    key: "send",
    value: function send(config) {
      var _this = this;

      this.config = config;
      var data = this.fromCache();

      if (data) {
        // Cache hit
        this.responseFromCache = true;
        this.dispose(); // Clone cached object

        return RSVP.Promise.resolve(this.cloneData(data));
      } else {
        // Cache miss
        this.promise = new RSVP.Promise(function (resolve, reject) {
          _this.resolvePromise = resolve;
          _this.rejectPromise = reject;
          return _this.sendXHR();
        });
        return this.promise;
      }
    }
  }, {
    key: "fromCache",
    value: function fromCache() {
      if (this.cache) {
        return this.cache.get(this.ident());
      } else {
        return null;
      }
    } // Resolve the Promise with a shallow clone of the data
    // so the original, cached object isnt changed

  }, {
    key: "cloneData",
    value: function cloneData(data) {
      return _.clone(data);
    } // Unique identifier used for caching

  }, {
    key: "ident",
    value: function ident() {
      return _.result(this, 'url');
    }
  }, {
    key: "url",
    value: function url() {
      throw new RequestError({
        message: 'url method needs to be implemented'
      });
    }
    /**
     * Parses the response as JSON per default
     *
     * @param {string} responseText
     * @returns {object}
     */

  }, {
    key: "parse",
    value: function parse(responseText) {
      var data;

      try {
        data = JSON.parse(responseText);
      } catch (originalError) {
        throw new RequestError({
          message: 'JSON parsing failed',
          originalError: originalError
        });
      }

      if ((0, _typeof2.default)(data) !== 'object') {
        throw new RequestError({
          message: 'Unknown response type, not an object'
        });
      }

      return data;
    } // Creates a new XMLHttpRequest instance.

  }, {
    key: "xhr",
    value: function xhr() {
      var xhr = new XMLHttpRequest();

      var url = _.result(this, 'url');

      var isCrossDomain = urlUtil.isCrossDomain(url); // In IE 9, create a XDomainRequest for cross-domain request.

      if (isCrossDomain && xhr.withCredentials == null) {
        if (window.XDomainRequest) {
          xhr = new XDomainRequest();
        } else {
          this.rejectWithMessage('Cross-domain requests are not supported');
        }
      }

      return xhr;
    } // Request control
    // ---------------
    // Sends and returns the XMLHttpRequest object

  }, {
    key: "sendXHR",
    value: function sendXHR() {
      var result = _.partial(_.result, this); // Open request

      /** @type {XMLHttpRequest} */


      var xhr = result('xhr');
      this._xhr = xhr;
      var url = result('url');
      /** @type {string} */

      this._url = url;
      /** @type {string} */

      var method = result('method');

      try {
        xhr.open(method, url, true);
      } catch (e) {
        return xhr;
      } // Event handling


      xhr.onload = this.xhrLoadHandler;
      xhr.onerror = this.xhrErrorHandler; // Event handling: timeout

      var timeout = result('timeout');

      if (timeout > 0) {
        xhr.timeout = timeout;
        xhr.ontimeout = this.xhrTimeoutHandler;
      } // Set empty handlers for IE 9
      // Background: http://bit.ly/1uy8ElJ http://bit.ly/1kGQ996


      var isXDomainRequest = window.XDomainRequest && xhr instanceof window.XDomainRequest;

      if (isXDomainRequest) {
        xhr.timeout = 0;
        var i = 0; // Do something harmless in the handlers

        xhr.ontimeout = function () {
          return i++;
        };

        xhr.onprogress = function () {
          return i++;
        };
      } // Extra headers
      // XDomainRequest (IE 9) does not support setting headers.


      if (xhr.setRequestHeader) {
        var requestHeaders = result('requestHeaders');

        for (var header in requestHeaders) {
          var value = requestHeaders[header];
          xhr.setRequestHeader(header, value);
        }
      } // Engage!

      /** @type {string} */


      var body = result('body') || undefined;

      if (isXDomainRequest) {
        // Apply a hack for IE 9 so the request does not abort
        var f = function f() {
          return xhr.send(body);
        };

        setTimeout(f, 50);
      } else {
        xhr.send(body);
      }

      return xhr;
    } // Aborts the running request.

  }, {
    key: "abort",
    value: function abort() {
      if (this.disposed) {
        return;
      }

      var xhr = this._xhr;

      if (xhr) {
        xhr.abort();
      }

      this.rejectWithMessage('aborted');
    } // Handlers
    // --------

  }, {
    key: "xhrLoadHandler",
    value: function xhrLoadHandler() {
      var data;
      var xhr = this._xhr; // XDomainRequest (IE 9) does not have a status property.

      var status = xhr.status; // Expect the server to return an HTTP 2xx status

      if (status != null && !(200 <= status && status < 300)) {
        this.reject(new RequestError({
          message: 'Server error'
        }));
        return;
      } // Parse the data


      try {
        data = this.parse(xhr.responseText);
      } catch (error) {
        this.reject(error);
        return;
      }

      var dataForResolve = data; // Cache data

      if (this.cache) {
        // Save the original, resolve with a clone
        this.cache.set(this.ident(), data);
        dataForResolve = this.cloneData(data);
      } // Yay.


      this.resolvePromise(dataForResolve);
      this.dispose();
    }
    /**
     * @param {ProgressEvent} error
     */

  }, {
    key: "xhrErrorHandler",
    value: function xhrErrorHandler(error) {
      var requestError = new RequestError({
        message: error.message,
        originalError: error
      });
      this.reject(requestError);
    }
  }, {
    key: "xhrTimeoutHandler",
    value: function xhrTimeoutHandler() {
      this.rejectWithMessage('XMLHttpRequest timeout');
    }
    /**
     * Rejects the promise with a RequestError that has the given message.
     *
     * @param {string} message
     */

  }, {
    key: "rejectWithMessage",
    value: function rejectWithMessage(message) {
      this.reject(new RequestError({
        message: message
      }));
    }
    /**
     * Rejects the promise with a RequestError. Disposes the request.
     * Expects a string or an object.
     *
     * @param {Error} error
     */

  }, {
    key: "reject",
    value: function reject(error) {
      if (!this.rejectPromise) {
        return;
      } // Add additional information to the error


      _.assign(error, this.additionalErrorData());

      this.rejectPromise(error);
      this.dispose();
    }
  }, {
    key: "additionalErrorData",
    value: function additionalErrorData() {
      /** @type {{
       * requestURL?: string,
       * responseStatus?: number,
       * responseText?: string
       * }} */
      var data = {};
      var url = this._url;
      var xhr = this._xhr;

      if (url) {
        data.requestURL = url;
      }

      if (xhr) {
        if (xhr.status) {
          data.responseStatus = xhr.status;
        }

        if (xhr.responseText) {
          // Only the first n characters of the response
          data.responseText = String(xhr.responseText).substring(0, 200).replace(/\s+/g, ' ');
        }
      }

      return data;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      this.disposed = true;
      disposal.disposeProperties(this);
    }
  }]);
  return Request;
}(); // Method binding
// --------------


_.assign(Request.prototype, methodBinding); // Properties
// ----------


Request.prototype.boundMethods = ['xhrLoadHandler', 'xhrErrorHandler', 'xhrTimeoutHandler'];
/**
 * The cache is shared on the prototype by all instances.
 *
 * @type {RequestCache | null}
 */

Request.prototype.cache = null;
Request.prototype.responseFromCache = false;
Request.prototype.method = 'GET';
Request.prototype.body = null;
Request.prototype.requestHeaders = {}; // Disposal
// --------

Request.prototype.disposed = false;
Request.prototype.disposedProperties = ['config', 'body', '_url', '_xhr', 'promise', 'resolvePromise', 'rejectPromise'];
module.exports = Request;

},{"../util/disposal":123,"../util/method-binding":134,"../util/url":143,"./request-error":106,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/typeof":24,"lodash":"lodash","rsvp":32}],108:[function(require,module,exports){
'use strict'; // A Rule for User Selection Carry Over.

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var Rule = /*#__PURE__*/function () {
  function Rule(options) {
    (0, _classCallCheck2.default)(this, Rule);
    this.context = options.context;
    this.sources = options.sources;
    this.properties = options.properties;
    this.target = options.target;
  }

  (0, _createClass2.default)(Rule, [{
    key: "hasSource",
    value: function hasSource(source) {
      return this.sources.indexOf(source) >= 0;
    }
  }, {
    key: "hasProperty",
    value: function hasProperty(property) {
      return this.properties.indexOf(property) >= 0;
    }
  }]);
  return Rule;
}();

module.exports = Rule;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11}],109:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Request = require('./request');

var sdmxUrl = require('./sdmx-url');

var SDMXRequest = /*#__PURE__*/function (_Request) {
  (0, _inherits2.default)(SDMXRequest, _Request);

  var _super = _createSuper(SDMXRequest);

  function SDMXRequest() {
    var _this;

    (0, _classCallCheck2.default)(this, SDMXRequest);
    _this = _super.call(this);
    /** @type {import('../types/types').ChartDataAttributes} */

    _this.config;
    return _this;
  }

  (0, _createClass2.default)(SDMXRequest, [{
    key: "requestHeaders",
    value: function requestHeaders() {
      return {
        Accept: 'application/vnd.sdmx.data+json',
        'Accept-Language': this.config.language
      };
    }
  }, {
    key: "url",
    value: function url() {
      return sdmxUrl(this.config, this.parameters());
    } // Returns an object with query string parameters

  }, {
    key: "parameters",
    value: function parameters() {
      return {
        'json-lang': this.config.language,
        // Compact format
        dimensionAtObservation: 'allDimensions'
      };
    }
  }]);
  return SDMXRequest;
}(Request);

module.exports = SDMXRequest;

},{"./request":107,"./sdmx-url":111,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],110:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var arrayUtil = require('../util/array');

var chartUtil = require('../util/chart');

var timePeriodConversion = require('../util/time-period-conversion');
/** @typedef {import('../types/types').RawSDMXResponse} RawSDMXResponse */

/** @typedef {import('../types/types').DimensionObservation} DimensionObservation */

/** @typedef {import('../types/types').IdAndName} IdAndName */
// Constants


var COMPACT_FORMAT_REGEXP = /[?&]dimensionAtObservation=allDimensions(&|$)/i; // Dimension identifiers

var LOCATION = 'LOCATION';
var INDICATOR = 'INDICATOR';
var SUBJECT = 'SUBJECT';
var MEASURE = 'MEASURE';
var FREQUENCY = 'FREQUENCY';
var TIME_PERIOD = 'TIME_PERIOD';
var TIME_FORMAT = 'TIME_FORMAT';
var OBS_STATUS = 'OBS_STATUS'; // Holds the raw SDMX response in this.data and offers query methods.
// All methods are functionally pure. An instance only holds this.data.

var SDMXResponse = /*#__PURE__*/function () {
  /**
   * @param {RawSDMXResponse} data
   */
  function SDMXResponse(data) {
    (0, _classCallCheck2.default)(this, SDMXResponse);
    this.data = data;
  } // Returns whether the SDMX response used the compact format
  // (dimensionAtObservation=AllDimensions)


  (0, _createClass2.default)(SDMXResponse, [{
    key: "isCompactFormat",
    value: function isCompactFormat() {
      var header = this.data.header;
      var request = header.request,
          links = header.links;

      if (request) {
        // Old SDMX format: request object
        return COMPACT_FORMAT_REGEXP.test(request.uri);
      } else if (links && links.length) {
        // New SDMX format: links array with a rel: request entry
        var link = _.find(links, {
          rel: 'request'
        });

        if (link) {
          return COMPACT_FORMAT_REGEXP.test(link.href);
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.getDimensions().length === 0;
    } // Dimensions
    // ----------

    /**
     * For a given dimension object, returns a new object with id and name only.
     *
     * @param {IdAndName} object
     */

  }, {
    key: "pickDimension",
    value: function pickDimension(object) {
      return {
        id: object.id,
        name: object.name
      };
    } // High-level dimension getters
    // ----------------------------

  }, {
    key: "getLocations",
    value: function getLocations() {
      return this.getMultiDimension(LOCATION);
    }
  }, {
    key: "getIndicator",
    value: function getIndicator() {
      return this.getSingleDimension(INDICATOR);
    }
  }, {
    key: "getIndicators",
    value: function getIndicators() {
      return this.getMultiDimension(INDICATOR);
    }
  }, {
    key: "getSubject",
    value: function getSubject() {
      return this.getSingleDimension(SUBJECT);
    }
  }, {
    key: "getSubjects",
    value: function getSubjects() {
      return this.getMultiDimension(SUBJECT);
    }
  }, {
    key: "getMeasure",
    value: function getMeasure() {
      return this.getSingleDimension(MEASURE);
    }
  }, {
    key: "getMeasures",
    value: function getMeasures() {
      return this.getMultiDimension(MEASURE);
    }
  }, {
    key: "getFrequency",
    value: function getFrequency() {
      return this.getSingleDimension(FREQUENCY);
    }
  }, {
    key: "getFrequencies",
    value: function getFrequencies() {
      return this.getMultiDimension(FREQUENCY);
    }
  }, {
    key: "getTimePeriods",
    value: function getTimePeriods() {
      return this.getMultiDimension(TIME_PERIOD);
    } // Locations
    // ---------

  }, {
    key: "getSortedLocations",
    value: function getSortedLocations() {
      return this.getLocations().sort(chartUtil.sortByNameAsc);
    } // Time periods
    // ------------
    // Time periods in the original order, augmented with Date objects
    // Returns a new array with new objects

  }, {
    key: "getFullTimePeriods",
    value: function getFullTimePeriods() {
      var _this = this;

      return this.getTimePeriods().map(function (timePeriod) {
        // Creates a new object { id, name }
        timePeriod = _this.pickDimension(timePeriod); // Add a Date object

        timePeriod.date = timePeriodConversion.idToDate(timePeriod.id);
        return timePeriod;
      });
    } // Time periods sorted by date, augmented with Date objects

  }, {
    key: "getSortedTimePeriods",
    value: function getSortedTimePeriods() {
      return this.getFullTimePeriods().sort(chartUtil.sortByDateAsc);
    } // Low-level dimension getters
    // ---------------------------

    /**
     * @param {string} id
     * @returns {IdAndName}
     */

  }, {
    key: "getSingleDimension",
    value: function getSingleDimension(id) {
      return this.getDimension(id).values[0];
    }
    /**
     * @param {string} id
     * @returns {IdAndName[]}
     */

  }, {
    key: "getMultiDimension",
    value: function getMultiDimension(id) {
      return this.getDimension(id).values;
    }
    /**
     * @param {string} id
     * @returns {DimensionObservation}
     */

  }, {
    key: "getDimension",
    value: function getDimension(id) {
      return _.find(this.getDimensions(), {
        id: id
      });
    }
    /** @returns {DimensionObservation[]} */

  }, {
    key: "getDimensions",
    value: function getDimensions() {
      return this.data.structure.dimensions.observation;
    } // Dimension index getters
    // -----------------------

  }, {
    key: "getLocationIndex",
    value: function getLocationIndex() {
      return this.getDimensionIndex(LOCATION);
    }
  }, {
    key: "getIndicatorIndex",
    value: function getIndicatorIndex() {
      return this.getDimensionIndex(INDICATOR);
    }
  }, {
    key: "getSubjectIndex",
    value: function getSubjectIndex() {
      return this.getDimensionIndex(SUBJECT);
    }
  }, {
    key: "getMeasureIndex",
    value: function getMeasureIndex() {
      return this.getDimensionIndex(MEASURE);
    }
  }, {
    key: "getFrequencyIndex",
    value: function getFrequencyIndex() {
      return this.getDimensionIndex(FREQUENCY);
    }
  }, {
    key: "getTimePeriodIndex",
    value: function getTimePeriodIndex() {
      return this.getDimensionIndex(TIME_PERIOD);
    }
    /**
     * @param {string} id
     * @returns {number | null}
     */

  }, {
    key: "getDimensionIndex",
    value: function getDimensionIndex(id) {
      var _arrayUtil$findElemen = arrayUtil.findElementWithIndex(this.getDimensions(), function (dimensionCandidate) {
        return dimensionCandidate.id === id;
      }),
          dimension = _arrayUtil$findElemen.element,
          index = _arrayUtil$findElemen.index;

      if (dimension) {
        // keyPosition is missing for TIME_PERIOD, just use the array index
        return dimension.keyPosition != null ? dimension.keyPosition : index;
      } else {
        return null;
      }
    } // Attributes
    // ----------

  }, {
    key: "getTimeFormats",
    value: function getTimeFormats() {
      return this.getMultiAttribute(TIME_FORMAT);
    }
  }, {
    key: "getMultiAttribute",
    value: function getMultiAttribute(id) {
      return this.getAttribute(id).values;
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(id) {
      return _.find(this.data.structure.attributes.observation, {
        id: id
      });
    }
  }, {
    key: "getAttributeAt",
    value: function getAttributeAt(index) {
      return this.data.structure.attributes.observation[index];
    }
    /**
     * For a given list of attribute indices, return the
     * first observation status id (e.g. 'B' for 'Break')
     *
     * @param {number[]} attributeIndices
     * @returns {IdAndName}
     */

  }, {
    key: "observationStatus",
    value: function observationStatus(attributeIndices) {
      for (var position = 0; position < attributeIndices.length; position++) {
        var valueIndex = attributeIndices[position];
        var attribute = this.getAttributeAt(position);

        if (!attribute || attribute.id !== OBS_STATUS) {
          continue;
        }

        var value = attribute.values[valueIndex];

        if (value != null) {
          return value;
        }
      }

      return null;
    } // Values
    // ------

  }, {
    key: "getValues",
    value: function getValues() {
      return this.data.dataSets[0].observations;
    }
  }]);
  return SDMXResponse;
}(); // Constants


SDMXResponse.COMPACT_FORMAT_REGEXP = COMPACT_FORMAT_REGEXP; // Dimension identifiers

SDMXResponse.LOCATION = LOCATION;
SDMXResponse.INDICATOR = INDICATOR;
SDMXResponse.SUBJECT = SUBJECT;
SDMXResponse.MEASURE = MEASURE;
SDMXResponse.FREQUENCY = FREQUENCY;
SDMXResponse.TIME_PERIOD = TIME_PERIOD;
SDMXResponse.TIME_FORMAT = TIME_FORMAT;
SDMXResponse.OBS_STATUS = OBS_STATUS;
module.exports = SDMXResponse;

},{"../util/array":118,"../util/chart":119,"../util/time-period-conversion":141,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"lodash":"lodash"}],111:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var urlUtil = require('../util/url');
/**
 * Creates an URL for the SDMX JSON API.
 * Expects a API config hash and a params hash (opt).
 * For the syntax description, see http://stats.oecd.org/opendataapi/Json.htm
 *
 * @param {import('../types/types').ChartDataAttributes} config
 * @param {{ [key: string]: string }} rawParams
 */


var sdmxUrl = function sdmxUrl(config, params) {
  var sdmxParams = _.assign({}, params); // Translate startTime/endTime to startPeriod/endPeriod params


  if (config.startTime) {
    sdmxParams.startPeriod = config.startTime;
  }

  if (config.endTime) {
    sdmxParams.endPeriod = config.endTime;
  }

  var filterExpression = [config.locations.join('+'), config.indicator, config.subjects.join('+'), config.measure, config.frequency].join('.');
  var url = config.baseUrl + '/' + config.dataset + '/' + filterExpression + '/' + config.agencyName + urlUtil.stringifyQueryString(sdmxParams);
  return urlUtil.addCurrentProtocol(url);
};

module.exports = sdmxUrl;

},{"../util/url":143,"lodash":"lodash"}],112:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var User = require('./user');

var Rule = require('./rule');

var Selection = require('./selection');

var cleanSelectionValue = require('../util/clean-selection-value');
/*
 * SelectionMediator organises communication between configurations of individual
 * charts and user selections carried over.
 */


var SelectionMediator = {
  persistRules: {},
  restoreRules: {},
  context: null,
  // Installs a rule to persist selections in a given context.
  persist: function persist(context, sources, properties, target) {
    var rule = new Rule({
      context: context,
      sources: sources,
      properties: properties,
      target: target
    });
    (this.persistRules[context] || (this.persistRules[context] = [])).push(rule);
  },
  // Installs a rule to restore selections in a given context.
  restore: function restore(context, targets) {
    return this.restoreRules[context] = targets;
  },
  setContext: function setContext(context) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    this.context = context; // Persist options passed when setting context

    if (options) {
      this.update('init', options);
    }
  },
  retrieve: function retrieve() {
    return this.retrieveReduce(function (selection, item) {
      return _.defaults(selection, item.selection);
    });
  },
  // Returns all applied selections as Selection objects.
  // Returns an object with { [selectionName]: Selection,  }
  selections: function selections() {
    return this.retrieveReduce(function (selections, item) {
      var context = item.context,
          selection = item.selection;

      for (var name in selection) {
        if (!Object.prototype.hasOwnProperty.call(selection, name) || name in selections) continue;
        selections[name] = new Selection({
          name: name,
          context: context,
          value: selection[name]
        });
      }

      return selections;
    });
  },
  // Removes a selection. Expects a Selection instance and an optional item.
  // If an item is given, the item is removed from the array value.
  unsetSelection: function unsetSelection(selection, item) {
    var name = selection.name,
        context = selection.context;
    var stored = User.retrieveSelection(context);

    stored[name] = function () {
      if (item != null) {
        var val = stored[name];

        if (_.isArray(val)) {
          return cleanSelectionValue(_.without(val, item));
        } else {
          return undefined;
        }
      } else {
        return undefined;
      }
    }();

    User.storeSelection(context, stored);
  },
  retrieveReduce: function retrieveReduce(reducer) {
    var accumulator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (this.context) {
      var history = User.retrieveHistory();
      var targets = this.restoreRules[this.context] || [];
      return _.chain(history).filter(function (item) {
        return targets.indexOf(item.context) >= 0;
      }).reduce(reducer, accumulator).value();
    } else {
      return {};
    }
  },
  // Updates the stored selection with the given changes
  update: function update(source, changes) {
    var shouldCleanValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (!this.context) {
      return false;
    } // Restrict to rules applying to both context and source


    var rules = _.filter(this.persistRules[this.context], function (rule) {
      return rule.hasSource(source);
    }); // Process each updated property


    for (var name in changes) {
      var value = changes[name];

      for (var i = 0, l = rules.length; i < l; i++) {
        var rule = rules[i];

        if (rule.hasProperty(name)) {
          var selection = User.retrieveSelection(rule.target);
          selection[name] = shouldCleanValue ? cleanSelectionValue(value) : value;
          User.storeSelection(rule.target, selection);
        }
      }
    }

    return true;
  },
  // Applies the selection to a chart model
  apply: function apply(model) {
    var userSelection = this.retrieve();

    if (!userSelection) {
      return;
    }

    var storedConfiguration = model.get('storedConfiguration');
    var applyUserSelection = storedConfiguration === 'accept' || storedConfiguration === 'exchange';

    if (!applyUserSelection) {
      return;
    }

    model.set(userSelection, {
      silent: true,
      force: true
    });
  },
  // Observes changes on the model in order to save them.
  observe: function observe(model) {
    var storedConfiguration = model.get('storedConfiguration');
    var updateSelection = storedConfiguration === 'exchange' || storedConfiguration === 'impose';

    if (updateSelection) {
      model.on('relevantChange', this.modelChangeHandler, this);
    }
  },
  modelChangeHandler: function modelChangeHandler(model, changes) {
    this.update(model.get('storedConfiguration'), changes);
  }
}; // Install Rules
// -------------

SelectionMediator.persist('country', ['init'], ['highlightedLocations'], 'user');
SelectionMediator.persist('embedded', ['impose'], ['type', 'subjects', 'measure', 'frequency', 'startTime', 'endTime', 'locations', 'highlightedLocations', 'showBaseline', 'showNonBaseline'], 'embedded');
SelectionMediator.persist('indicator', ['exchange'], ['highlightedLocations', 'showBaseline', 'showNonBaseline'], 'user');
SelectionMediator.restore('indicator', ['country', 'embedded', 'user']);
SelectionMediator.restore('topic', ['user']); // Selections from the 'embedded' context are purged after one request

User.shortlived = ['embedded'];
module.exports = SelectionMediator;

},{"../util/clean-selection-value":120,"./rule":108,"./selection":113,"./user":115,"lodash":"lodash"}],113:[function(require,module,exports){
'use strict'; // A configuration option that is carried over between pages.
// Consists of a name (e.g. highlightedLocations), a value (e.g. ['DEU'])
// and a target context (e.g. "user").

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var Selection = /*#__PURE__*/function () {
  function Selection(options) {
    (0, _classCallCheck2.default)(this, Selection);
    this.name = options.name;
    this.context = options.context;
    this.value = options.value;
  }

  (0, _createClass2.default)(Selection, [{
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    }
  }]);
  return Selection;
}();

module.exports = Selection;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11}],114:[function(require,module,exports){
'use strict';

var AvailableCombinations = require('./available-combinations');

var timePeriodConversion = require('../util/time-period-conversion'); // Time period navigation
// Functions for changing the startTime/endTime of a ChartData model
// Time periods to navigate


var NAVIGATION_STEPS = 1;
var timePeriodNavigation = {
  // Navigates given time periods forward
  // Sets model attributes
  forward: function forward(model, steps) {
    return model.set(this.timeForward(model, steps));
  },
  // Navigates given time periods backwards
  // Sets model attributes
  back: function back(model, steps) {
    return model.set(this.timeBack(model, steps));
  },
  // Returns the new time periods as { startTime, endTime }
  timeForward: function timeForward(model) {
    var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NAVIGATION_STEPS;
    return this.timeInBounds(model, steps, steps);
  },
  // Returns the new time periods as { startTime, endTime }
  timeBack: function timeBack(model) {
    var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NAVIGATION_STEPS;
    return this.timeInBounds(model, -steps, -steps);
  },

  /*
  * Narrow down the time range by the given steps on each end
  * Returns the new time periods as { startTime, endTime }
  timeZoomIn: (model, steps = NAVIGATION_STEPS) ->
    @timeInBounds model, steps, -steps
    * Broaden the time range by the given steps on each end
  * Returns the new time periods as { startTime, endTime }
  timeZoomOut: (model, steps = NAVIGATION_STEPS) ->
    @timeInBounds model, -steps, steps
  */
  // Given two number deltas, returns { startTime, endTime } that are calculated
  // from the current startTime/endTime in the bounds of the available
  // time periods for the current frequency.
  timeInBounds: function timeInBounds(model, startDelta, endDelta) {
    var idToNumber = timePeriodConversion.idToNumber,
        numberToId = timePeriodConversion.numberToId,
        numberStep = timePeriodConversion.numberStep;
    var inputStartTime = model.actualStartTime().id;
    var inputEndTime = model.actualEndTime().id;
    var frequency = model.get('frequency');
    var startTime = idToNumber(frequency, inputStartTime);
    var endTime = idToNumber(frequency, inputEndTime);
    var step = numberStep(frequency);
    startTime += startDelta * step;
    endTime += endDelta * step; // Check whether the calculated time periods are within the bounds

    var metadata = model.get('metadata');

    if (metadata) {
      var availableCombinations = new AvailableCombinations(model, metadata);
      var bounds = availableCombinations.timePeriodBoundsForFrequency(frequency);

      if (bounds) {
        var min = idToNumber(frequency, bounds.startTime.id);
        var max = idToNumber(frequency, bounds.endTime.id); // This is basically startTime < min and endTime > max, but
        // JavaScript numbers are crazy. So this check is tolerant.

        if (min - startTime >= step) {
          startTime = min;
        }

        if (endTime - max >= step) {
          endTime = max;
        }
      }
    }

    if (startTime > endTime) {
      startTime = endTime;
    }

    startTime = numberToId(frequency, startTime);
    endTime = numberToId(frequency, endTime);
    return {
      startTime: startTime,
      endTime: endTime
    };
  }
};

if (typeof Object.freeze === 'function') {
  Object.freeze(timePeriodNavigation);
}

module.exports = timePeriodNavigation;

},{"../util/time-period-conversion":141,"./available-combinations":85}],115:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var stores = require('../util/stores');

var MEMORY_SIZE = 5; // Private history store fronting local storage

var historyCache = null;
var User = {
  // Shortlived entries only live one session
  shortlived: [],
  storeSelection: function storeSelection(context, selection) {
    if (stores.session.enabled) {
      // We need to apply the same two operations to different histories
      var truncateOp = function truncateOp(history) {
        return (// Remove existing entries for this context
          _.reject(history, function (item) {
            return item.context === context;
          })
        );
      };

      var appendOp = function appendOp(history) {
        return (// Prepend new entry, truncate to defined number of entries
          _.take([{
            context: context,
            selection: selection
          }].concat(history), MEMORY_SIZE)
        );
      }; // Apply updates to historyCache


      historyCache = appendOp(truncateOp(historyCache)); // Apply updates to store and return the stored string

      return stores.session.set('context_history', appendOp(truncateOp(this.retrieveHistoryFromStorage())));
    } else {
      return false;
    }
  },
  retrieveSelection: function retrieveSelection(context) {
    var item = _.find(this.retrieveHistory(), {
      context: context
    }) || {};
    return item.selection || {};
  },
  retrieveHistoryFromStorage: function retrieveHistoryFromStorage() {
    if (stores.session.enabled) {
      return stores.session.get('context_history') || [];
    }
  },
  retrieveHistory: function retrieveHistory() {
    if (stores.session.enabled) {
      // If we have a history in cache, serve it
      if (historyCache != null) {
        return historyCache; // Otherwise retrieve from local storage and cache
      } else {
        historyCache = this.retrieveHistoryFromStorage(); // Purge shortlived entries

        stores.session.set('context_history', _.reject(historyCache, function (entry) {
          return User.shortlived.indexOf(entry.context) >= 0;
        })); // Return originally retrieved history

        return historyCache;
      }
    } else {
      return [];
    }
  }
};
module.exports = User;

},{"../util/stores":138,"lodash":"lodash"}],116:[function(require,module,exports){
'use strict';

module.exports = {
  // Tracks an event
  trackEvent: function trackEvent(category, action, label, value, nonInteraction) {
    // Google Analytics (ga.js)
    if (window._gaq && window._gaq.push) {
      // ga.js
      window._gaq.push(['_trackEvent', category, action, label, value, nonInteraction]);
    }
  }
};

},{}],117:[function(require,module,exports){
'use strict'; // Animation utilities

var w = window;
var animation = {
  requestAnimationFrame: function () {
    var backend = w.requestAnimationFrame || function (callback) {
      return w.setTimeout(callback, 1000 / 60);
    };

    return backend.bind(w);
  }(),
  cancelAnimationFrame: function () {
    var backend = w.cancelAnimationFrame || function (handle) {
      return w.clearTimeout(handle);
    };

    return backend.bind(w);
  }()
};
module.exports = animation;

},{}],118:[function(require,module,exports){
'use strict';

var d3 = require('d3');

var arrayUtil = {
  /**
   * Finds an element in an array by invoking a callback.
   * Mixture of `_.find` / `_.findIndex`.
   *
   * @template T
   * @param {T[]} array
   * @param {(element: T, index: number, array: T[]) => boolean} condition
   */
  findElementWithIndex: function findElementWithIndex(array, condition) {
    for (var index = 0; index < array.length; index++) {
      var element = array[index];

      if (condition(element, index, array)) {
        return {
          element: element,
          index: index
        };
      }
    }

    return null;
  },

  /**
   * Transforms an array into an d3.map with reversed keys and values.
   * The array index becomes the value, the array value becomes the key.
   * e.g. `['a', 'b', 'c']` => `d3.map { a: 0, b: 1, c: 2 }`
   * If there are identical values, the last index wins.
   * e.g. `['a', 'b', 'c', 'a']` => `d3.map { a: 3, b: 1, c: 2 }`
   *
   * @template T
   * @param {T[]} array
   */
  valueMap: function valueMap(array) {
    /** @type {d3.Map<T>} */
    var map = d3.map();

    for (var index = 0; index < array.length; index++) {
      var value = array[index];
      map.set(value, index);
    }

    return map;
  }
};
module.exports = arrayUtil;

},{"d3":27}],119:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var d3 = require('d3');
/** @typedef {import('../types/types').IdAndName} IdAndName */

/** @typedef {import('../types/types').DataPoint} DataPoint */

/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {import('../types/types').LocationWithValues} LocationWithValues */

/** @typedef {import('../types/types').LocationsWithValues} LocationsWithValues */

/**
 * Utility functions for dealing with chart data.
 * Returns whether a datum has a defined value.
 *
 * @param {DataPoint} d
 */


var hasValue = function hasValue(d) {
  return d.value != null;
};
/**
 * Maps a data point to the id (usually the location id).
 *
 * @param {IdAndName} d
 */


var idKey = function idKey(d) {
  return d.id;
};
/**
 * Maps a data point to the name.
 *
 * @param {DataPoint} d
 */


var dName = function dName(d) {
  return d.name;
};
/**
 * For a given data point, returns the number value.
 *
 * @param {DataPoint} d
 */


var dValue = function dValue(d) {
  return d.value;
};
/**
 * Selects the first data point for a locationWithValues.
 *
 * @param {LocationWithValues} locationWithValues
 */


var singleDSelector = function singleDSelector(locationWithValues) {
  return locationWithValues.values[0];
};
/**
 * Returns the first number value for a LocationWithValues.
 *
 * @param {LocationWithValues} locationWithValues
 */


var singleValueSelector = function singleValueSelector(locationWithValues) {
  return singleDSelector(locationWithValues).value;
};
/**
 * Sort objects ascending by their name using localeCompare
 *
 * @param {{ name: string }} a
 * @param {{ name: string }} b
 */


var sortByNameAsc = function sortByNameAsc(a, b) {
  return a.name.localeCompare(b.name);
};
/**
 * Sort objects descending by their name using localeCompare
 *
 * @param {{ name: string }} a
 * @param {{ name: string }} b
 */


var sortByNameDesc = function sortByNameDesc(a, b) {
  return b.name.localeCompare(a.name);
};
/**
 * Sort objects ascending by their date
 *
 * @param {{ date: Date }} a
 * @param {{ date: Date }} b
 */


var sortByDateAsc = function sortByDateAsc(a, b) {
  return a.date - b.date;
};
/**
 * Sort objects ascending by their value
 *
 * @param {{ value: number }} a
 * @param {{ value: number }} b
 */


var sortByValueDesc = function sortByValueDesc(a, b) {
  return b.value - a.value;
};
/**
 * Sorts a list of objects by id with the given id order.
 * Expects an array of objects with ids and an array of ids.
 * e.g. [ { id: 'b' }, { id: 'a' }, { id: 'c' } ], [ 'a', 'b', 'c' ]
 * Returns a list of objects with ids by a given order.
 * e.g. [ { id: 'a' }, { id: 'b' }, { id: 'c' } ]
 * Returns an array of objects.
 *
 * @template {{ id: string }[]} T
 * @param {T} objects
 * @param {string[]} order
 * @return {T}
 */


var sortByOrder = function sortByOrder(objects, order) {
  // [ 0: id ] -> { id: 0 }

  /** @type {{ [key: string]: number }} */
  var orderById = order.reduce(function (result, id, index) {
    result[id] = index;
    return result;
  }, {});

  var sortByIndex = function sortByIndex(a, b) {
    return orderById[a.id] - orderById[b.id];
  };

  return objects.slice().sort(sortByIndex);
};
/**
 * Filters the values of a given location using a given filter function.
 * Creates a shallow copy of the location so the original values array
 * remains untouched.
 *
 * @param {LocationWithValues} location
 * @param {(data: DataPoint[]) => DataPoint[]} filter
 */


var filterValues = function filterValues(location, filter) {
  var locationClone = _.clone(location);

  locationClone.values = filter(locationClone.values);
  return locationClone;
};
/**
 * Returns a copy of the data with filtered values for each location.
 * Expects the data object and a filter function that receives
 * values: Array.
 *
 * @param {RawChartData} data
 * @param {(data: DataPoint[]) => DataPoint[]} filter
 */


var dataWithFilteredValues = function dataWithFilteredValues(data, filter) {
  var dataClone = _.clone(data);

  dataClone.filteredLocationsWithValues = dataClone.filteredLocationsWithValues.map(function (location) {
    return filterValues(location, filter);
  });
  return dataClone;
};
/**
 * Wraps a value in an array if its truthy.
 *
 * @template T
 * @param {T} value
 * @return {T[]}
 */


var wrapValue = function wrapValue(value) {
  return value ? [value] : [];
};
/**
 * Returns a copy of the data with only the last data point for each location.
 * This is the data point for the newest time period any location
 * has a value for. So its not guaranteed that the last data point
 * is defined for all locations.
 *
 * @param {RawChartData} data
 */


var dataWithLastValue = function dataWithLastValue(data) {
  return dataWithFilteredValues(data, function (values) {
    return wrapValue(latestDataPoint(values, false));
  });
};
/**
 * Returns a copy of the data with only the latest defined data point
 * for each location.
 * @param {RawChartData} data
 */


var dataWithLatestValue = function dataWithLatestValue(data) {
  return dataWithFilteredValues(data, function (values) {
    return wrapValue(latestDataPoint(values, true));
  });
};
/**
 * Returns the latest data point:
 * If useLatestData is true, the latest defined, otherwise the last.
 *
 * @param {DataPoint[]} values
 * @param {boolean} useLatestData
 */


var latestDataPoint = function latestDataPoint(values, useLatestData) {
  return useLatestData ? _.findLast(values, hasValue) : _.last(values);
};
/**
 * Calculates the extent of given locationsWithValues (lowest and
 * highest value). Returns [min: Number, max: Number].
 *
 * @param {LocationsWithValues} locationsWithValues
 */


var extent = function extent(locationsWithValues) {
  return d3.extent(allValues(locationsWithValues));
};
/**
 * For an array of locationsWithValues, returns an array
 * with all defined number values.
 *
 * @param {LocationsWithValues} locationsWithValues
 */


var allValues = function allValues(locationsWithValues) {
  /** @type {number[]} */
  var values = [];
  locationsWithValues.forEach(function (locationWithValues) {
    locationWithValues.values.forEach(function (dataPoint) {
      var value = dataPoint.value;

      if (value !== null) {
        values.push(value);
      }
    });
  });
  return values;
};
/**
 * Calculates the extremum, i.e. the value furthest away from zero.
 *
 * @template T
 * @param {T[]} values
 * @param {(value: T) => number} valueSelector
 */


var absoluteExtremum = function absoluteExtremum(values, valueSelector) {
  return values.reduce(function (extremum, d) {
    var value = valueSelector(d);

    if (Math.abs(value) > Math.abs(extremum)) {
      return value;
    } else {
      return extremum;
    }
  }, 0);
};
/**
 * Creates a class selector from a class name.
 * @param {string} className
 */


var selector = function selector(className) {
  return ".".concat(className);
};

module.exports = {
  hasValue: hasValue,
  idKey: idKey,
  dName: dName,
  dValue: dValue,
  singleDSelector: singleDSelector,
  singleValueSelector: singleValueSelector,
  sortByNameAsc: sortByNameAsc,
  sortByNameDesc: sortByNameDesc,
  sortByDateAsc: sortByDateAsc,
  sortByValueDesc: sortByValueDesc,
  sortByOrder: sortByOrder,
  filterValues: filterValues,
  dataWithFilteredValues: dataWithFilteredValues,
  wrapValue: wrapValue,
  dataWithLastValue: dataWithLastValue,
  dataWithLatestValue: dataWithLatestValue,
  latestDataPoint: latestDataPoint,
  extent: extent,
  allValues: allValues,
  absoluteExtremum: absoluteExtremum,
  selector: selector
};

},{"d3":27,"lodash":"lodash"}],120:[function(require,module,exports){
'use strict';

var _ = require('lodash');
/**
 * Cleans a selection value. Currently affects only arrays:
 * Returns undefined for empty arrays and arrays with falsy values.
 *
 * @template T
 * @param {T | T[]} value
 */


var cleanSelectionValue = function cleanSelectionValue(value) {
  if (_.isArray(value)) {
    if (value.some(function (item) {
      return !!item;
    })) {
      return value;
    } else {
      return undefined;
    }
  } else {
    return value;
  }
};

module.exports = cleanSelectionValue;

},{"lodash":"lodash"}],121:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var hogan = require('hogan.js');

var I18n = null;
var DEFAULT_TEMPLATE_OPTIONS = {
  // Work around cyclic dependency by late-binding the name for I18n
  t: function t() {
    if (!I18n) {
      I18n = require('../i18n');
    }

    return I18n.t;
  }
}; // Creates a template function with Mustache-style escaping and
// {{escape}}
//
// Includes an I18n helper that can be used to directly look up strings from
// the locale configuration.
//
// With a locale of FR configured,
//
//     {{#t}}namespace.greeting{{/t}}, {{name}}!
//
// could result in "Salut, Michelle!".

var createTemplate = function createTemplate(str) {
  var template = hogan.compile(str); // We need to monkey-patch render because Hogan doesnt support default
  // values.

  var originalRender = template.render;

  template.render = function (options, partials, indent) {
    // Merge global defaults and per-render options
    var mergedOptions = _.assign({}, DEFAULT_TEMPLATE_OPTIONS, options);

    return originalRender.call(template, mergedOptions, partials, indent);
  };

  return template;
};

module.exports = createTemplate;

},{"../i18n":82,"hogan.js":30,"lodash":"lodash"}],122:[function(require,module,exports){
'use strict';

var ASPECT_RATIO = require('../constants/aspect-ratio');

var Configuration = require('../configuration'); // Minimum size for multiple line charts


var MULTIPLE_LINE_MIN_WIDTH = 300;
var MULTIPLE_LINE_MIN_HEIGHT = MULTIPLE_LINE_MIN_WIDTH / ASPECT_RATIO;
/**
 * Returns the chart type that is be used to display the data.
 * Depends on chart configuration, the data and the available size.
 *
 * @param {import('../models/chart-data')} model
 * @param {number} width
 * @param {number} height
 * @returns {string}
 */

var displayType = function displayType(model, width, height) {
  var type = model.get('type');
  var data = model.get('data'); // Switch from line or bar to symbol if there are several subjects

  var subjectsWithValues = data.subjectsWithValues;
  var switchToSymbol = (type === 'line' || type === 'bar') && subjectsWithValues && subjectsWithValues.length > 1;

  if (switchToSymbol) {
    return 'symbol';
  } // Switch from line to bar if use latest data is enabled
  // or there is just one time period


  var useLatestData = model.get('useLatestData');
  var timePeriods = data.timePeriods;
  var switchToBar = type === 'line' && (useLatestData || timePeriods && timePeriods.length === 1);

  if (switchToBar) {
    return 'bar';
  } // Switch from line to multiple line (small multiples) if there is
  // a certain amount of highlighted locations and the size fits


  var locationLength = model.actualHighlightedLocations().length;
  var multipleLineConfig = Configuration.get('multipleLineChart');
  var switchToMultipleLine = type === 'line' && locationLength >= multipleLineConfig.minLocations && locationLength <= multipleLineConfig.maxLocations && width >= MULTIPLE_LINE_MIN_WIDTH && height >= MULTIPLE_LINE_MIN_HEIGHT;

  if (switchToMultipleLine) {
    return 'multipleLine';
  } // Use the configured type


  return type;
};

module.exports = displayType;

},{"../configuration":67,"../constants/aspect-ratio":68}],123:[function(require,module,exports){
'use strict';

var objectUtil = require('../util/object');

var disposal = {
  // Removes object properties of an object specified in the
  // `disposedProperties` array. Walks all objects in the prototype chain to
  // gather all versions of `disposedProperties`.
  //
  // Removing properties isnt strictly necessary, but can prevent memory leaks
  // if the instance references other objects. Removing references allows the
  // garbage collector to do its job.
  // Also this allows to spot errors fast. Working with disposed objects
  // gives early exceptions because key properties have been removed.
  // Background info: http://docs.chaplinjs.org/disposal.html
  disposeProperties: function disposeProperties(object) {
    var versions = objectUtil.getAllPropertyVersions(object, 'disposedProperties');
    versions.forEach(function (properties) {
      properties.forEach(function (property) {
        delete object[property];
      });
    });
  }
};
module.exports = disposal;

},{"../util/object":136}],124:[function(require,module,exports){
"use strict";

// DOM helpers
var support = require('./support');

module.exports = {
  /**
   * Returns the computed width and height. Returns 0 for invisible elements.
   * Does not even out browser bugs, so the meaning might vary.
   *
   * @param {Element} el
   */
  size: function size(el) {
    var style = getComputedStyle(el);
    var widthString = style.width;
    var heightString = style.height;
    var width = parseFloat(widthString);

    if (isNaN(width)) {
      width = 0;
    }

    var height = parseFloat(heightString);

    if (isNaN(height)) {
      height = 0;
    }

    return {
      width: width,
      height: height,
      style: style
    };
  },

  /**
   * Returns the outer size (border box) of an element as sub-pixel floats.
   * See http://www.w3.org/TR/CSS2/box.html#box-dimensions
   * Assumes `box-sizing: border-box`.
   * `jQuery#outerWidth` would return a rounded integers since it uses
   * `offsetWidth/Height`.
   *
   * @param {Element} el
   */
  outerSize: function outerSize(el) {
    var _this$size = this.size(el),
        width = _this$size.width,
        height = _this$size.height,
        style = _this$size.style;

    if (style.boxSizing !== 'border-box') {
      throw new Error('dom#outerSize: Works only for box-sizing: border-box');
    }

    var adjustedWidth = width;
    var adjustedHeight = height; // In IE <= 11, the computed width does not include the border and padding
    // despite box-sizing: border-box

    if (!support.boxSizingReliable) {
      adjustedWidth = width + parseFloat(style.borderLeftWidth) + parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderRightWidth);
      adjustedHeight = height + parseFloat(style.borderTopWidth) + parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderBottomWidth);
    }

    return {
      width: adjustedWidth,
      height: adjustedHeight
    };
  },

  /**
   * Returns the inner size (content box) of an element as sub-pixel floats.
   * See http://www.w3.org/TR/CSS2/box.html#box-dimensions
   * Assumes `box-sizing: border-box`.
   * `jQuery#width` would return a rounded integers since it uses
   * `offsetWidth/Height`.
   *
   * @param {Element} el
   */
  innerSize: function innerSize(el) {
    var _this$size2 = this.size(el),
        width = _this$size2.width,
        height = _this$size2.height,
        style = _this$size2.style;

    if (style.boxSizing !== 'border-box') {
      throw new Error('dom#innerSize: Works only for box-sizing: border-box');
    }

    var adjustedWidth = width;
    var adjustedHeight = height; // In IE <= 11, the computed width does not include the border and padding
    // despite box-sizing: border-box

    if (support.boxSizingReliable) {
      adjustedWidth = width - parseFloat(style.borderLeftWidth) - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight) - parseFloat(style.borderRightWidth);
      adjustedHeight = height - parseFloat(style.borderTopWidth) - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom) - parseFloat(style.borderBottomWidth);
    }

    return {
      width: adjustedWidth,
      height: adjustedHeight
    };
  }
};

},{"./support":140}],125:[function(require,module,exports){
"use strict";

var _ = require('lodash');

var csvSdmxUrl = require('../models/csv-sdmx-url');
/** @typedef {import('../types/types').ChartDataAttributes} ChartDataAttributes */

/** @typedef {import('../models/chart-data')} ChartData */

/**
 * Initiates an indicator download on the given clicked anchor element
 * (<a href="">Download</a>).
 * @param {ChartDataAttributes} attributes
 * @param {HTMLAnchorElement} aElement
 */


var startDownload = function startDownload(attributes, aElement) {
  aElement.href = csvSdmxUrl(attributes);
};
/**
 * Initiates a download of the full indicator data by clicking on an anchor.
 * @param {ChartData} model
 * @param {HTMLAnchorElement} aElement
 */


var downloadIndicator = function downloadIndicator(model, aElement) {
  var attributes = _.omit(model.attributesForFetch(), 'measure', 'frequency', 'startTime', 'endTime'); // Override locations: All locations of the indicator


  attributes.locations = []; // Override subjects: All subjects of the indicator

  attributes.subjects = [];
  startDownload(attributes, aElement);
};
/**
 * Initiates a download of the current chart data by clicking on an anchor.
 * @param {ChartData} model
 * @param {HTMLAnchorElement} aElement
 */


var downloadSelection = function downloadSelection(model, aElement) {
  var attributes = model.attributesForFetch();
  startDownload(attributes, aElement);
};

module.exports = {
  startDownload: startDownload,
  downloadIndicator: downloadIndicator,
  downloadSelection: downloadSelection
};

},{"../models/csv-sdmx-url":94,"lodash":"lodash"}],126:[function(require,module,exports){
// Fullscreen cross-browser library
// See https://github.com/sindresorhus/screenfull.js
'use strict';

var _ = require('lodash');

var $ = require('jquery');

var $window = $(window);
var doc = document;
var $doc = $(doc);
var _document = document,
    body = _document.body; // Detect prefixed methods and properties

var requestProperties = ['requestFullscreen', 'mozRequestFullScreen', 'webkitRequestFullscreen', 'webkitRequestFullScreen', 'msRequestFullscreen'];

var requestProperty = _.find(requestProperties, function (property) {
  return typeof body[property] === 'function';
});

var exitProperties = ['exitFullscreen', 'mozCancelFullScreen', 'webkitExitFullscreen', 'webkitCancelFullScreen', 'msExitFullscreen'];

var exitProperty = _.find(exitProperties, function (property) {
  return typeof doc[property] === 'function';
});

var elementProperties = ['fullscreenElement', 'mozFullScreenElement', 'webkitFullscreenElement', 'webkitCurrentFullScreenElement', 'msFullscreenElement'];

var elementProperty = _.find(elementProperties, function (property) {
  return property in document;
});

var changeEvents = ['fullscreenchange', 'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange'];

var changeEvent = _.find(changeEvents, function (event) {
  return "on".concat(event) in doc;
});

var fallbackClass = 'fullscreen-fallback'; // In fallback mode, store the current fullscreen element

var fullscreenEl = null;

var keyupHandler = function keyupHandler(event) {
  if (event.keyCode === 27) {
    fullscreen.exitFullscreen(fullscreenEl);
  }
};

var fullscreen = {
  onChange: function onChange(handler) {
    if (changeEvent) {
      document.addEventListener(changeEvent, handler);
      return true;
    } else {
      return false;
    }
  },
  offChange: function offChange(handler) {
    if (changeEvent) {
      document.removeEventListener(changeEvent, handler);
      return true;
    } else {
      return false;
    }
  },
  // Enters the fullscreen mode.
  // Returns 'native' or 'fallback'
  requestFullscreen: function requestFullscreen(el) {
    if (requestProperty) {
      el[requestProperty]();
      return 'native';
    } // Fallback


    fullscreenEl = el;
    $(el).addClass(fallbackClass);
    window.scrollTo(0, 0);
    $doc.keyup(keyupHandler); // Trigger a fake resize event so elements might update

    $window.trigger('resize');
    return 'fallback';
  },
  // Exists the fullscreen mode.
  // Returns 'native' or 'fallback'
  exitFullscreen: function exitFullscreen(el) {
    if (exitProperty) {
      if (this.isFullscreen()) {
        doc[exitProperty]();
      }

      return 'native';
    } // Fallback


    if (fullscreenEl) {
      fullscreenEl = null;

      if (el) {
        $(el).removeClass(fallbackClass);
      }

      $doc.off('keyup', keyupHandler); // Trigger a fake resize event so elements might update

      $window.trigger('resize');
    }

    return 'fallback';
  },
  // Returns the current fullscreen element
  fullscreenElement: function fullscreenElement() {
    if (elementProperty) {
      return doc[elementProperty];
    } else {
      return fullscreenEl;
    }
  },
  // Returns whether the fullscreen mode is enabled
  isFullscreen: function isFullscreen() {
    return Boolean(this.fullscreenElement());
  },
  // Toggles the fullscreen mode. Returns 'native' or 'fallback'.
  toggleFullscreen: function toggleFullscreen(el, enable) {
    if (enable == null) {
      enable = !this.isFullscreen();
    }

    if (enable) {
      return this.requestFullscreen(el);
    } else {
      return this.exitFullscreen(el);
    }
  }
};
module.exports = fullscreen;

},{"jquery":"jquery","lodash":"lodash"}],127:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var d3 = require('d3'); // D3 ends the simulation when the alpha cooling falls below this parameter
// https://github.com/mbostock/d3/wiki/Force-Layout


var D3_COOLING_CUTOFF = 0.005;
var geom = {
  /*
  Nodes should be spread evenly without straying too far from their original
  position (and without overlapping). Neighboring nodes should stay neighbors
  immediately or reasonably close. Oceans and missing countries are ignored
  as far as neighborship goes, links between nodes should be provided.
    Assuming nodes to have initial positions (x,y) which they start from.
    Overlapping is prevented by appropriate use of negative charge, charge
  distance, and link distance, but we need to finally decollide using a quadtree
  to ensure no weird emergent force bundles things together.
    We invert gravity to repel nodes from the center slightly, so they spread
  across the available space. To keep nodes in the canvas, nodes are always
  set back to be within the available dimensions should they overshoot them
  in a tick.
  */
  evenOut: function evenOut(nodes, links, width, height, selection) {
    var iterations = 300;
    var center = {
      x: width / 2,
      y: height / 2
    };
    var paddingPercent = 0.001;
    var padding = Math.max(width * paddingPercent, height * paddingPercent);
    var edgePadding = width * 0.02; // Make it harder for nodes to leave their position

    var friction = 0.5;
    var maxRadius = d3.max(nodes, function (node) {
      return node.radius;
    });
    var chargeDistance = 2 * maxRadius; // Set a low gravity pushing nodes away from the center

    var gravity = -0.005; // Keep temperature low to prevent hasty jumps in the beginning of the
    // simulation

    var startAlpha = 0.05;
    var iteration = 1;
    var decollide = false;

    var moveNode = function moveNode(node, quadtree) {
      // Decollision
      if (decollide) {
        quadtree.visit(geom.collisionVisitor(node, width * 0.01, width, height));
      } // Push nodes back into canvas


      var nodeEdgePadding = node.radius + edgePadding;
      node.x = geom.boundIn(nodeEdgePadding, width - nodeEdgePadding, node.x);
      node.y = geom.boundIn(nodeEdgePadding, height - nodeEdgePadding, node.y); // Animate if we are debugging

      if (selection) {
        selection.attr('transform', function (d) {
          return "translate(".concat(d.x, ",").concat(d.y, ")");
        });
      }
    };

    var tick = function tick() {
      // Postpone decolliding until after some iterations
      decollide = iteration / iterations > 0.5;
      var quadtree = d3.geom.quadtree(nodes);

      for (var i = 0, l = nodes.length; i < l; i++) {
        var node = nodes[i];
        moveNode(node, quadtree);
      }

      iteration++;
    };

    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]) // Respect radii and leave some padding
    .linkDistance(function (link) {
      return link.target.radius + link.source.radius + padding;
    }).friction(friction) // Nodes should be mutually repellent, larger nodes need more space.
    // In addition, nodes close to the edge can not move and are therefore
    // more repellent.
    .charge(function (d) {
      var cy = Math.abs((d.y - center.y - d.radius) / center.y);
      return -1 * (d.radius + d.radius * d.radius * d.radius * cy);
    }).chargeDistance(chargeDistance).gravity(gravity).alpha(startAlpha).on('tick', tick).start();

    if (!selection) {
      // No animation is desired, only numeric outcome of simulation
      for (var i = 1; i <= iterations; i++) {
        force.tick();
      }

      force.stop();
    }

    return nodes;
  },
  // Complex decollision with a force layout
  decollide: function decollide(nodes, links, width, height, selection) {
    var iterations = 300;
    var paddingPercent = 0.001;
    var padding = Math.max(width * paddingPercent, height * paddingPercent);
    var linkStrength = 0.4; // Make it harder for nodes to leave their position

    var friction = 0.4;
    var maxRadius = d3.max(nodes, function (node) {
      return node.radius;
    });
    var chargeDistance = 2 * maxRadius; // Keep temperature low to prevent hasty jumps in the beginning of the
    // simulation

    var startAlpha = 0.05; // Percent of the distance between current and target position
    // that a node moves to the target pos. after decollision

    var adjustment = 0.5;

    var moveNode = function moveNode(node, quadtree, alpha) {
      // Decollision
      quadtree.visit(geom.collisionVisitor(node, padding, width, height)); // Push nodes back to their target position

      var xDiff = node.targetX - node.x;
      var yDiff = node.targetY - node.y;
      var percentSimulation = D3_COOLING_CUTOFF / alpha;
      var adjustmentForIteration = adjustment * (1 - percentSimulation);
      node.x += xDiff * adjustmentForIteration;
      node.y += yDiff * adjustmentForIteration; // Animate if we are debugging

      if (selection) {
        selection.attr('transform', function (d) {
          return "translate(".concat(d.x, ", ").concat(d.y, ")");
        });
      }
    };

    var tick = function tick(event) {
      var quadtree = d3.geom.quadtree(nodes);

      for (var i = 0, l = nodes.length; i < l; i++) {
        var node = nodes[i];
        moveNode(node, quadtree, event.alpha);
      }
    };

    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]) // Respect radii and leave some padding
    .linkDistance(function (link) {
      return link.target.radius + link.source.radius + padding;
    }).linkStrength(linkStrength).friction(friction).chargeDistance(chargeDistance).gravity(0).alpha(startAlpha).on('tick', tick).start();

    if (!selection) {
      // No animation is desired, only numeric outcome of simulation
      for (var i = 1; i <= iterations; i++) {
        force.tick();
      }

      force.stop();
    }

    return nodes;
  },
  // Simple decollision without a force layout
  simpleDecollide: function simpleDecollide(nodes, width, height) {
    var iterations = 20;
    var paddingPercent = 0.001;
    var padding = Math.max(width * paddingPercent, height * paddingPercent);
    var adjustment = 0.5;

    for (var iteration = 1; iteration <= iterations; iteration++) {
      var quadtree = d3.geom.quadtree(nodes);
      var adjustmentFactor = 1 - iteration / (iterations * 0.95);
      var adjustmentForIteration = adjustment * adjustmentFactor;

      for (var i = 0, l = nodes.length; i < l; i++) {
        var node = nodes[i];
        quadtree.visit(geom.collisionVisitor(node, padding, width, height)); // Push node back to its target position

        var xDiff = node.targetX - node.x;
        var yDiff = node.targetY - node.y;
        node.x += xDiff * adjustmentForIteration;
        node.y += yDiff * adjustmentForIteration;
      }
    }

    return nodes;
  },
  // Collision visitor without bound checking
  // Adapted from http://bl.ocks.org/mbostock/3231298
  collisionVisitor: function collisionVisitor(node, padding, width, height) {
    var paddedNodeRadius = node.radius + padding;
    var nx1 = node.x - paddedNodeRadius;
    var nx2 = node.x + paddedNodeRadius;
    var ny1 = node.y - paddedNodeRadius;
    var ny2 = node.y + paddedNodeRadius;

    var horizontalBound = _.partial(geom.boundIn, node.radius, width - node.radius);

    var verticalBound = _.partial(geom.boundIn, node.radius, height - node.radius);

    return function (quad, x1, y1, x2, y2) {
      var quadPoint = quad.point;

      if (quadPoint && quadPoint !== node) {
        var x = node.x - quadPoint.x;
        var y = node.y - quadPoint.y;
        var pointRadius = quadPoint.radius;
        var distanceNodeQuad = Math.sqrt(x * x + y * y);
        var distanceExpected = paddedNodeRadius + pointRadius;

        if (distanceNodeQuad < distanceExpected) {
          var offsetFactor = (distanceNodeQuad - distanceExpected) / distanceNodeQuad * 0.5;
          var xOffset = x * offsetFactor;
          var yOffset = y * offsetFactor;
          node.x = horizontalBound(node.x - xOffset);
          node.y = verticalBound(node.y - yOffset);
          quadPoint.x = geom.boundIn(pointRadius, width - pointRadius, quadPoint.x + xOffset);
          quadPoint.y = geom.boundIn(pointRadius, height - pointRadius, quadPoint.y + yOffset);
        }
      }

      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    };
  },
  boundIn: function boundIn(min, max, val) {
    if (val < min) {
      return min;
    } else if (val > max) {
      return max;
    } else {
      return val;
    }
  }
};
module.exports = geom;

},{"d3":27,"lodash":"lodash"}],128:[function(require,module,exports){
"use strict";

var FREQUENCIES = require('../constants/frequencies');

var Configuration = require('../configuration');

var timePeriodConversion = require('../util/time-period-conversion');

var latestDataStartTime = function latestDataStartTime(frequency) {
  var month, year;
  var timeRanges = Configuration.get('latestDataTimePeriods') || {};
  var periods = timeRanges[frequency] || 12;
  var now = new Date();

  if (frequency === FREQUENCIES.ANNUAL) {
    year = now.getFullYear() - periods;
    month = now.getMonth();
  } else if (frequency === FREQUENCIES.QUARTERLY) {
    year = now.getFullYear();
    month = now.getMonth() - periods * 3;
  } else if (frequency === FREQUENCIES.MONTHLY) {
    year = now.getFullYear();
    month = now.getMonth() - periods;
  }

  var startDate = new Date(year, month, now.getDate());
  return timePeriodConversion.dateToId(frequency, startDate);
};

module.exports = latestDataStartTime;

},{"../configuration":67,"../constants/frequencies":72,"../util/time-period-conversion":141}],129:[function(require,module,exports){
'use strict';

var _ = require('lodash');
/**
 * Perform topological sort to linearize dependency associations.
 *
 * Argument `item` is expected to be an object with keys as item names
 * and values being objects with an `after` property listing the names of all
 * items this item depends on.
 *
 * Returns a list of item names with a dependency-compatible ordering.
 * Fails with error in presence of circular dependencies.
 *
 * @param {import('../types/types').Dependents} items
 */


var linearize = function linearize(items) {
  var ordering = [];
  var visited = [];
  /**
   * @param {string} name
   * @param {string[]} lineage
   */

  var traverse = function traverse(name) {
    var lineage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (visited.indexOf(name) >= 0) {
      return;
    }

    var dependent = items[name];

    if (!dependent) {
      throw new Error("Dependency not found: ".concat(name));
    }

    lineage.push(name);
    visited.push(name);
    var afterDependencies = dependent.after;

    for (var i = 0, l = afterDependencies.length; i < l; i++) {
      var dependency = afterDependencies[i];

      if (lineage.indexOf(dependency) >= 0) {
        throw new Error("Circular dependency: ".concat(name, " and ").concat(dependency));
      }

      traverse(dependency, _.toArray(lineage));
    }

    return ordering.push(name);
  };

  for (var name in items) {
    traverse(name);
  }

  return ordering;
};

module.exports = linearize;

},{"lodash":"lodash"}],130:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var _require = require('./chart'),
    hasValue = _require.hasValue,
    latestDataPoint = _require.latestDataPoint;
/**
 * Given there is only one time period, creates an array with locations with
 * values of all subjects. Example:
 *
 * ```
 * [
 *   {
 *     id: 'GRC'
 *     name: 'Greece'
 *     # Data points for one time period sorted by subject or value ascending
 *     values: [
 *       { id: 'GRC', timePeriod: '2009', subject: 'SUBJ_A', value: 5.0,  }
 *       { id: 'GRC', timePeriod: '2009', subject: 'SUBJ_B', value: 6.0,  }
 *       { id: 'GRC', timePeriod: '2009', subject: 'SUBJ_C', value: 7.0,  }
 *     ]
 *   }
 * ]
 * ```
 *
 * The second parameter controls if the last or the latest defined data point
 * is used. If the latest defined is used, the values may come from different
 * time periods.
 *
 * @param {import('../types/types').RawChartData} data
 * @param {boolean} useLatestData
 */


var locationsWithSubjectValues = function locationsWithSubjectValues(data, useLatestData) {
  return data.filteredLocationsWithValues.map(function (location, index) {
    location = _.create(location); // Gather last or latest values from all subjects for the location

    var newValues = data.subjectsWithValues.map(function (subjectWithValues) {
      var values = subjectWithValues.filteredLocationsWithValues[index].values;
      return latestDataPoint(values, useLatestData);
    });
    location.values = _.compact(newValues);
    return location;
  }) // Remove locations without defined (non-null) values
  .filter(function (location) {
    return location.values.some(hasValue);
  });
};

module.exports = locationsWithSubjectValues;

},{"./chart":119,"lodash":"lodash"}],131:[function(require,module,exports){
/* eslint-disable no-console */
'use strict'; // Safe error logging on the console

var logError = function logError() {
  if (window.console && console.error) {
    if (console.error.apply) {
      var _console;

      // Babel compiles this to console.error.apply(console, arguments).
      // console.error.apply is undefined in IE9, so we need to check before.
      (_console = console).error.apply(_console, arguments);
    } else {
      console.error(Array.prototype.slice.call(arguments).join(' '));
    }
  }
};

module.exports = logError;

},{}],132:[function(require,module,exports){
'use strict';

var math = {
  /**
   * Like parseInt, but force base 10
   *
   * @param {string} string
   */
  int: function int(string) {
    return parseInt(string, 10);
  },

  /**
   * @param {number} num
   */
  sign: function sign(num) {
    if (num < 0) {
      return -1;
    } else if (num > 0) {
      return 1;
    } else if (num === 0) {
      return 0;
    } else {
      return NaN;
    }
  }
};
module.exports = math;

},{}],133:[function(require,module,exports){
"use strict";

var _ = require('lodash'); // This is faster than working with `arguments`
// \u001E is the ASCII Record Separator


var stringify2 = function stringify2(a, b) {
  return "".concat(a, "\x1E").concat(b);
};

var stringify3 = function stringify3(a, b, c) {
  return "".concat(a, "\x1E").concat(b, "\x1E").concat(c);
};

var stringify4 = function stringify4(a, b, c, d) {
  return "".concat(a, "\x1E").concat(b, "\x1E").concat(c, "\x1E").concat(d);
};

var stringify5 = function stringify5(a, b, c, d, e) {
  return "".concat(a, "\x1E").concat(b, "\x1E").concat(c, "\x1E").concat(d, "\x1E").concat(e);
};

var stringify6 = function stringify6(a, b, c, d, e, f) {
  return "".concat(a, "\x1E").concat(b, "\x1E").concat(c, "\x1E").concat(d, "\x1E").concat(e, "\x1E").concat(f);
};

var getStringify = function getStringify(length) {
  switch (length) {
    case 0:
      return stringify6;

    case 1:
      return _.identity;

    case 2:
      return stringify2;

    case 3:
      return stringify3;

    case 4:
      return stringify4;

    case 5:
      return stringify5;

    case 6:
      return stringify6;

    default:
      throw new Error('util.memoize: Too many arguments');
  }
}; // Memoize a function using an argument stringifier.
// Only works with arguments that can be easily converted to strings,
// i.e. primitives and objects to a certain degree.
// Only works with functions that have up to 6 arguments.
// The argument number must be fixed and the arguments must be declared.
// If these constraints are not met, use _.memoize.
// Expects a function, returns a function.


var memoize = function memoize(func) {
  // This is faster than working with `arguments`
  // See http://bit.ly/1yZyg25
  var stringify = getStringify(func.length);

  var memoized = function memoized(a, b, c, d, e, f) {
    var cache = memoized.cache;
    var key = stringify(a, b, c, d, e, f);

    if (key in cache) {
      return cache[key];
    } else {
      return cache[key] = func.call(this, a, b, c, d, e, f);
    }
  };

  memoized.cache = {};
  return memoized;
};

module.exports = memoize;

},{"lodash":"lodash"}],134:[function(require,module,exports){
"use strict";

var objectUtil = require('./object'); // Class mixin for binding methods to the instance
// Usage:
// class MyClass {
//   constructor() {
//     this.bindMethods();
//   }
// }
// _.assign(MyClass.prototype, methodBinding);
// MyClass.prototype.boundMethods = [ 'method1', 'method2' ];

/**
 * @param {{ [key: string]: (...args: any[]) => any) }} object
 * @param {string} methodName
 */


var bindMethod = function bindMethod(object, methodName) {
  var func = object[methodName];

  if (typeof func !== 'function') {
    throw new Error("bindMethods: ".concat(methodName, " is not a function"));
  }

  var bound = func.bind(object);
  object[methodName] = bound;
};

var methodBinding = {
  // Binds all methods to the instance specified in the `boundMethods` array.
  // Walks all objects in the prototype chain to gather all versions of `boundMethods`.
  bindMethods: function bindMethods() {
    /** @type {string[][]} */
    var versions = objectUtil.getAllPropertyVersions(this, 'boundMethods');

    for (var i = 0, l = versions.length; i < l; i++) {
      var methodNames = versions[i];

      for (var j = 0, l2 = methodNames.length; j < l2; j++) {
        var methodName = methodNames[j];
        bindMethod(this, methodName);
      }
    }
  },

  /** @type {string[]} */
  boundMethods: []
};
module.exports = methodBinding;

},{"./object":136}],135:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var d3 = require('d3');

var I18n = require('../i18n');
/** @typedef {import('../types/types').IdAndName} IdAndName */

/** @typedef {import('../types/types').RawChartData} RawChartData */

/** @typedef {{ symbol: string, min: number }} Suffix */
// Standard decimal places


var DECIMALS = 2;
var INTEGER_LIMIT = 4;
var THOUSANDS_SEPARATOR = null;
var DECIMAL_MARK = null;
var ALL_ZEROS = /^0+$/;
var TRAILING_ZEROS = /0+$/;
/**
 * Compact number formatter
 * Formats 123456.789 as 123,456.789
 * Cuts off decimal place if the integer part gets longer than `integerLimit`
 * Cuts off zeros in decimal places unless `forceDecimals` is true
 * Expects a number and options, returns a string.
 *
 * @param {number} number
 * @param {number?} decimals
 * @param {boolean?} forceDecimals
 * @param {number?} integerLimit
 * @param {string?} thousandsSeparator
 * @param {string?} decimalMark
 */

var formatNumber = function formatNumber(number, decimals, forceDecimals, integerLimit, thousandsSeparator, decimalMark) {
  // Return empty strings for non-numbers
  if (number === undefined || number === null || number === '') {
    return '';
  }

  if (typeof number !== 'number') {
    number = Number(number);
  }

  if (isNaN(number)) {
    return '';
  } // Default arguments


  if (decimals === undefined) {
    decimals = DECIMALS;
  }

  if (forceDecimals === undefined) {
    forceDecimals = false;
  }

  if (integerLimit === undefined) {
    integerLimit = INTEGER_LIMIT;
  }

  if (THOUSANDS_SEPARATOR === null) {
    THOUSANDS_SEPARATOR = I18n.t('general.thousands');
  }

  if (thousandsSeparator === undefined) {
    thousandsSeparator = THOUSANDS_SEPARATOR;
  }

  if (DECIMAL_MARK === null) {
    DECIMAL_MARK = I18n.t('general.decimal');
  }

  if (decimalMark === undefined) {
    decimalMark = DECIMAL_MARK;
  }

  var str = number.toFixed(decimals);
  var pointPos = str.indexOf('.');

  if (pointPos === -1) {
    pointPos = str.length;
  }

  var sign;
  var int = str.substring(0, pointPos);

  if (str.charAt(0) === '-') {
    sign = '-';
    int = int.substring(1);
  } else {
    sign = '';
  }

  var fraction = str.substring(pointPos + 1); // Add thousands separators

  str = '';
  var i = int.length;
  var consumed = 0;

  while (i > 0) {
    i--;
    var char = int.charAt(i);

    if (consumed === 3) {
      str = char + thousandsSeparator + str;
      consumed = 0;
    } else {
      str = char + str;
    }

    consumed++;
  } // Only add the decimal places if forced or
  // the integer is less then $integerLimit and does not consist of zeros


  if (fraction.length > 0 && (forceDecimals || str.length < integerLimit && !fraction.match(ALL_ZEROS))) {
    str += forceDecimals ? decimalMark + fraction : decimalMark + fraction.replace(TRAILING_ZEROS, '');
  } // Add sign again


  str = sign + str;
  return str;
}; // Label formatting
// ----------------


var LABEL_INT_LIMIT = 4;
var LABEL_SUFFIXED_INT_LIMIT = 3;
/**
 * SI prefixes (used as number suffixes here since there is no explicit unit):
 * http://en.wikipedia.org/wiki/Metric_prefix
 *
 * @type {{ [key: string]: number }}
 */

var LABEL_SUFFIXES = {
  G: 1e9,
  M: 1e6,
  k: 1e3
};
var SIGNIFICANT_DECIMALS_LIMIT = 3;
/**
 * Returns the decimals for the given number extent.
 *
 * @param {number} min
 * @param {number} max
 * @param {boolean} suffixed
 */

var labelDecimals = function labelDecimals(min, max, suffixed) {
  var extent = max - min;

  if (extent === 0) {
    if (min % 1 > 0 || max % 1 > 0) {
      return 1;
    } else {
      return 0;
    }
  } else if (extent >= 100) {
    return 0;
  } else if (!suffixed && extent <= 0.5 && min >= 0 && max < 10) {
    return 3;
  } else if (extent <= 3) {
    return 2;
  } else {
    return 1;
  }
};
/**
 * Returns the decimals for the given number extent and suffix minimum.
 *
 * @param {number} min
 * @param {number} max
 * @param {number} suffixMin
 */


var suffixedLabelDecimals = function suffixedLabelDecimals(min, max, suffixMin) {
  // Scale the extent for the suffix
  min = min / suffixMin;
  max = max / suffixMin;
  return labelDecimals(min, max, true);
};
/**
 * Creates a label formatter for the given decimals.
 *
 * @param {number} decimals
 * @param {boolean} forceDecimals
 */


var normalLabelFormatterForDecimals = function normalLabelFormatterForDecimals(decimals, forceDecimals) {
  return (
    /** @param {number} number */
    function (number) {
      return formatNumber(number, decimals, forceDecimals, LABEL_INT_LIMIT);
    }
  );
};
/**
 * Creates a label formatter for the given suffix and decimals.
 *
 * @param {Suffix} suffix
 * @param {number} decimals
 * @param {boolean} forceDecimals
 */


var suffixedLabelFormatterForDecimals = function suffixedLabelFormatterForDecimals(suffix, decimals, forceDecimals) {
  var suffixMin = suffix.min;
  var suffixSymbol = suffix.symbol;
  /** @param {number} number */

  var formatter = function formatter(number) {
    return formatNumber(number / suffixMin, decimals, forceDecimals, LABEL_SUFFIXED_INT_LIMIT) + suffixSymbol;
  };

  return formatter;
};
/**
 * Creates a label formatter without suffixes for the given extent.
 * Automatically determines the number of decimals.
 *
 * @param {number} min
 * @param {number} max
 * @param {boolean} forceDecimals
 */


var normalLabelFormatter = function normalLabelFormatter(min, max, forceDecimals) {
  var decimals = labelDecimals(min, max, false);
  return normalLabelFormatterForDecimals(decimals, forceDecimals);
};
/**
 * Creates a label formatter with suffixes for the given extent.
 * Automatically determines the number of decimals.
 * Returns a function or null if suffixes are not applicable.
 *
 * @param {Suffix} suffix
 * @param {number} min
 * @param {number} max
 * @param {boolean} forceDecimals
 */


var suffixedLabelFormatter = function suffixedLabelFormatter(suffix, min, max, forceDecimals) {
  var decimals = suffixedLabelDecimals(min, max, suffix.min);
  return suffixedLabelFormatterForDecimals(suffix, decimals, forceDecimals);
};
/**
 * Finds a matching suffix for the given maximum.
 * Returns { symbol: String, min: Number } or null if no suffix is applicable.
 *
 * @param {number} max
 * @returns {Suffix}
 */


var findSuffix = function findSuffix(max) {
  for (var symbol in LABEL_SUFFIXES) {
    var min = LABEL_SUFFIXES[symbol];

    if (max >= min) {
      return {
        symbol: symbol,
        min: min
      };
    }
  }

  return null;
};
/**
 * Creates a label formatter for the given extent.
 * Automatically determines whether suffixes are used.
 *
 * @param {number} min
 * @param {number} max
 * @param {boolean} suffixed
 * @param {boolean} forceDecimals
 */


var flexibleLabelFormatter = function flexibleLabelFormatter(min, max, suffixed, forceDecimals) {
  // Try SI suffixes
  var suffix;

  if (suffixed) {
    suffix = findSuffix(max);
  }

  if (suffix) {
    return suffixedLabelFormatter(suffix, min, max, forceDecimals);
  } else {
    return normalLabelFormatter(min, max, forceDecimals);
  }
};
/**
 * @param {Suffix?} suffix
 * @param {number} decimals
 * @param {boolean} forceDecimals
 */


var flexibleLabelFormatterForDecimals = function flexibleLabelFormatterForDecimals(suffix, decimals, forceDecimals) {
  if (suffix) {
    return suffixedLabelFormatterForDecimals(suffix, decimals, forceDecimals);
  } else {
    return normalLabelFormatterForDecimals(decimals, forceDecimals);
  }
};
/**
 * Creates a formatter for labels that reacts to the data extent
 * in order to prevent overlarge label texts.
 *
 * @param {number[]} values
 * @param {boolean} suffixed
 * @param {boolean} forceDecimals
 */


var labelFormatter = function labelFormatter(values, suffixed, forceDecimals) {
  var _d3$extent = d3.extent(values),
      _d3$extent2 = (0, _slicedToArray2.default)(_d3$extent, 2),
      min = _d3$extent2[0],
      max = _d3$extent2[1];

  return flexibleLabelFormatter(min, max, suffixed, forceDecimals);
};
/**
 * Creates a label formatter that can cope with the total extent and
 * the extent of each locationWithValues.
 *
 * @param {import('../types/types').RawChartData} data
 * @param {[number, number]} dataExtent
 * @param {boolean} suffixed
 * @param {boolean} forceDecimals
 */


var extensiveLabelFormatter = function extensiveLabelFormatter(data, dataExtent, suffixed, forceDecimals) {
  // Try SI suffixes
  var suffix;

  if (suffixed) {
    // Use the total max to decide which prefix is used
    suffix = findSuffix(dataExtent[1]);
  } // Calculate the chart-wide decimals by calculating the decimals
  // for each locationWithValues and taking the maximum.


  var allDecimals = data.locationsWithValues.map(function (locationWithValues) {
    var _locationWithValues$e = (0, _slicedToArray2.default)(locationWithValues.extent, 2),
        min = _locationWithValues$e[0],
        max = _locationWithValues$e[1];

    if (suffix) {
      return suffixedLabelDecimals(min, max, suffix.min);
    } else {
      return labelDecimals(min, max, false);
    }
  });
  var decimals = d3.max(allDecimals);
  return flexibleLabelFormatterForDecimals(suffix, decimals, forceDecimals);
};
/**
 * Returns the maximum significant decimals for a given array of numbers,
 * with a maximum of SIGNIFICANT_DECIMALS_LIMIT decimals.
 * Returns an integer number.
 *
 * @param {number[]} values
 */


var significantDecimals = function significantDecimals(values) {
  var allDecimals = values.map(function (number) {
    var string = number.toFixed(SIGNIFICANT_DECIMALS_LIMIT);
    var fraction = string.substring(string.indexOf('.') + 1).replace(TRAILING_ZEROS, '');

    if (fraction) {
      return fraction.length;
    } else {
      return 0;
    }
  });
  var decimals = d3.max(allDecimals);
  return Math.min(decimals, SIGNIFICANT_DECIMALS_LIMIT);
};
/**
 * Creates a label formatter based on the significant decimals
 * for a given array of numbers.
 *
 * @param {number[]} values
 * @param {boolean} suffixed
 * @param {boolean} forceDecimals
 */


var significantDecimalsFormatter = function significantDecimalsFormatter(values, suffixed, forceDecimals) {
  // Try SI suffixes
  var suffix;

  if (suffixed) {
    var max = d3.max(values);
    suffix = findSuffix(max);

    if (suffix) {
      var suffixMin = suffix.min; // Scale all values

      max = max / suffixMin;
      values = values.map(function (v) {
        return v / suffixMin;
      });
    }
  }

  var decimals = significantDecimals(values);
  return flexibleLabelFormatterForDecimals(suffix, decimals, forceDecimals);
};
/**
 * @param {IdAndName} measure
 */


var shortMeasure = function shortMeasure(measure) {
  if (measure.name.indexOf('%') > -1) {
    return '%';
  } else {
    return '';
  }
};

var numberFormatter = {
  formatNumber: formatNumber,
  findSuffix: findSuffix,
  labelFormatter: labelFormatter,
  extensiveLabelFormatter: extensiveLabelFormatter,
  significantDecimalsFormatter: significantDecimalsFormatter,
  shortMeasure: shortMeasure
};
module.exports = numberFormatter;

},{"../i18n":82,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/slicedToArray":20,"d3":27}],136:[function(require,module,exports){
'use strict';

var _ = require('lodash'); // Object utilities
// ----------------
// Returns the prototype chain of an object.
// In old browsers, falls back to the __proto__ property
// set up by Babel ES6 classes.
// Returns an array.


var getPrototypeChain = function () {
  if (Object.getPrototypeOf) {
    return (
      /**
       * @param {object} object
       * @returns {object[]}
       */
      function (object) {
        var chain = [];

        while (object = Object.getPrototypeOf(object)) {
          chain.push(object);
        }

        return chain;
      }
    );
  } else {
    return (
      /**
       * @param {object} object
       * @returns {object[]}
       */
      function (object) {
        var chain = [object.constructor.prototype];

        while (object = object.constructor != null ? object.constructor.__proto__ : undefined) {
          chain.push(object);
        }

        return chain;
      }
    );
  }
}();
/**
 * Returns the property lookup chain of an object.
 * This is the object itself and its prototype chain.
 *
 * @param {object} object
 * @returns {object[]}
 */


var getLookupChain = function getLookupChain(object) {
  return [object].concat(getPrototypeChain(object));
};
/**
 * Returns all unique property versions from the given object itself
 * and its prototype chain.
 * For example, if `object1` and `object2` have different values of `prop` and
 * `object2` is `object1`s prototype, it returns `[object1.prop, object2.prop]`.
 *
 * @param {object} object
 * @param {string} property
 */


var getAllPropertyVersions = function getAllPropertyVersions(object, property) {
  var result = [];
  var chain = getLookupChain(object).reverse();

  for (var i = 0, l = chain.length; i < l; i++) {
    var object2 = chain[i];
    var value = object2[property];

    if (value != null && result.indexOf(value) === -1) {
      result.push(value);
    }
  }

  return result;
};
/**
 * Returns a merged object from all property versions in the prototype chain.
 * Example:
 * Given:
 * `object1 = { p: { a: 1 } }`
 * `object2 = { p: { a: 2, b: 'yo' } }`
 * `object2` is `object1`s prototype
 * `getMergedVersion(object1, 'p')` returns `{ a: 1, b: 'yo' }`.
 * Only works with properties that are objects.
 * Returns an object.
 *
 * @param {object} object
 * @param {string} property
 * @returns {object}
 */


var getMergedVersion = function getMergedVersion(object, property) {
  var result = {};
  var chain = getLookupChain(object).reverse();

  for (var i = 0, l = chain.length; i < l; i++) {
    var object2 = chain[i];
    var value = object2[property];

    if (value) {
      _.assign(result, value);
    }
  }

  return result;
};
/**
 * Returns the first key/value pair of an object, assuming there is an order.
 * Returns an object `{ key, value }`.
 *
 * @param {object} object
 */


var firstProperty = function firstProperty(object) {
  for (var key in object) {
    var value = object[key];
    return {
      key: key,
      value: value
    };
  }

  return undefined;
};

module.exports = {
  getPrototypeChain: getPrototypeChain,
  getLookupChain: getLookupChain,
  getAllPropertyVersions: getAllPropertyVersions,
  getMergedVersion: getMergedVersion,
  firstProperty: firstProperty
};

},{"lodash":"lodash"}],137:[function(require,module,exports){
'use strict';

var $ = require('jquery'); // Helpers for sharing URLs and text on social media


var sharingUtil = {
  // Share a URL on Facebook, opening a new window with the FB sharer.
  facebook: function facebook(url) {
    var params = {
      u: url
    };
    url = "https://www.facebook.com/sharer/sharer.php?".concat($.param(params));
    window.open(url, '_blank');
  },
  // Share a text on Twitter, opening a new window with the tweet form.
  twitter: function twitter(text) {
    var params = {
      text: text
    };
    var url = "https://twitter.com/intent/tweet?".concat($.param(params));
    window.open(url, '_blank');
  },
  // Share a subject and body via email, invoking the email client.
  email: function email(subject, body) {
    subject = encodeURIComponent(subject);
    body = encodeURIComponent(body);
    var url = "mailto:?subject=".concat(subject, "&body=").concat(body);
    location.href = url;
  }
};
module.exports = sharingUtil;

},{"jquery":"jquery"}],138:[function(require,module,exports){
'use strict'; // Thin wrapper around storages conforming to the sessionStorage/localStorage API
// that stores objects/values as JSON.
//
// Silently absorbs all method calls if storage is unavailable.

var storageFactory = function storageFactory(storageName) {
  var isEnabled, storage;

  try {
    // Check whether we can access storage and write to it
    storage = window[storageName];
    var key = 'storageFactoryTest';
    var value = "foo-".concat(new Date().getTime());
    storage.setItem(key, value);
    isEnabled = storage.getItem(key) === value;
    storage.removeItem(key);
  } catch (e) {
    isEnabled = false;
  } // Proxy storage to prevent runtime errors


  var storageProxy = {
    getItem: function getItem(key) {
      if (isEnabled) {
        return storage.getItem(key);
      } else {
        return null;
      }
    },
    setItem: function setItem(key, val) {
      if (isEnabled) {
        return storage.setItem(key, val);
      }
    },
    removeItem: function removeItem(key) {
      if (isEnabled) {
        return storage.removeItem(key);
      }
    }
  }; // Public API

  return {
    enabled: isEnabled,
    // Fetches a stored value by key and returns the parsed value.
    get: function get(key) {
      var json = storageProxy.getItem(key);

      if (json != null) {
        return JSON.parse(json);
      } else {
        return null;
      }
    },
    // Stores a key/value pair and returns the serialized JSON.
    set: function set(key, value) {
      var json = JSON.stringify(value);
      storageProxy.setItem(key, json);
      return json;
    },
    // Removes an entry by key.
    remove: function remove(key) {
      return storageProxy.removeItem(key);
    }
  };
};

module.exports = {
  session: storageFactory('sessionStorage'),
  permanent: storageFactory('localStorage')
};

},{}],139:[function(require,module,exports){
'use strict';

module.exports = {
  dasherize: function dasherize(str) {
    return str.trim().replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
  }
};

},{}],140:[function(require,module,exports){
'use strict';

var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
module.exports = {
  // Tests several features necessary for the Data Portal charts:
  // SVG with D3 and cross-domain XHR.
  // Boolean property.
  chartsSupported: Boolean( // d3 creates even HTML elements with createElementNS
  document.createElementNS && // SVG
  document.createElementNS(SVG_NAMESPACE, 'svg').createSVGRect && ('withCredentials' in new XMLHttpRequest() || window.XDomainRequest)),
  // Calculates the environment's scrollbar width.
  // Number property.
  scrollbarWidth: function () {
    var el = document.createElement('div');
    el.style.cssText = 'position: absolute; top: -9999px; ' + 'width: 100px; height: 100px; overflow: scroll';
    document.body.appendChild(el);
    var scrollbarWidth = el.offsetWidth - el.clientWidth;
    document.body.removeChild(el);
    return scrollbarWidth;
  }(),
  // Whether the computed values of width/height correctly
  // respect box-sizing: border-box. Internet Explorer does not,
  // including latest version 11. Taken from jQuery:
  // https://github.com/jquery/jquery/blob/master/src/css/support.js
  // See also http://caniuse.com/#feat=css3-boxsizing
  // Boolean property.
  boxSizingReliable: function () {
    if (!window.getComputedStyle) {
      return false;
    }

    var expectedWidth = 50;
    var el = document.createElement('div');
    el.style.cssText = 'position: absolute; top: 0; left: 0; ' + "border: 10px solid red; padding: 10px; width: ".concat(expectedWidth, "px; ") + 'box-sizing: border-box; -webkit-box-sizing: border-box';
    document.body.appendChild(el);
    var style = getComputedStyle(el);

    var boxSizingReliable = function () {
      if (style) {
        var width = parseFloat(style.width); // Error-tolerance due to subpixel rendering and scaling

        return expectedWidth - width < 0.5;
      } else {
        return true;
      }
    }();

    document.body.removeChild(el);
    return boxSizingReliable;
  }(),
  isTouchDevice: function () {
    // Taken from Modernizr 2.6.2. See http://bit.ly/1zrGOfj
    var touchEventSupport = Boolean('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); // MSIE has Touch in the user agent
    // Based on http://msdn.microsoft.com/en-us/library/ie/hh920767(v=vs.85).aspx

    var _navigator = navigator,
        userAgent = _navigator.userAgent;
    var touchExplorer = /MSIE/i.test(userAgent) && /Touch/i.test(userAgent);
    return touchEventSupport || touchExplorer;
  }()
};

},{}],141:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var _require = require('../constants/frequencies'),
    ANNUAL = _require.ANNUAL,
    QUARTERLY = _require.QUARTERLY,
    MONTHLY = _require.MONTHLY,
    REGEXPS = _require.REGEXPS,
    ANNUAL_REGEXP = _require.ANNUAL_REGEXP,
    QUARTERLY_REGEXP = _require.QUARTERLY_REGEXP,
    MONTHLY_REGEXP = _require.MONTHLY_REGEXP;

var memoize = require('./memoize');

var _require2 = require('./math'),
    int = _require2.int;

var I18n = require('../i18n');
/** @typedef {import('../types/types').Frequency} Frequency */

/**
 * How many periods per year
 *
 * @type {{ [key: string]: number }}
 */


var PERIOD_FRACTIONS = {};
PERIOD_FRACTIONS[ANNUAL] = 1;
PERIOD_FRACTIONS[QUARTERLY] = 4;
PERIOD_FRACTIONS[MONTHLY] = 12;

var NUMBER_STEPS = _.mapValues(PERIOD_FRACTIONS, function (value) {
  return 1 / value;
});

var isAnnualId = function isAnnualId(timePeriod) {
  return ANNUAL_REGEXP.test(timePeriod);
}; // const isQuarterlyId = timePeriod => QUARTERLY_REGEXP.test(timePeriod);
// const isMonthlyId = timePeriod => MONTHLY_REGEXP.test(timePeriod);

/**
 * @param {string} timePeriod
 */


var parseAnnualId = function parseAnnualId(timePeriod) {
  return ANNUAL_REGEXP.exec(timePeriod);
};
/**
 * @param {string} timePeriod
 */


var parseQuarterlyId = function parseQuarterlyId(timePeriod) {
  return QUARTERLY_REGEXP.exec(timePeriod);
};
/**
 * @param {string} timePeriod
 */


var parseMonthlyId = function parseMonthlyId(timePeriod) {
  return MONTHLY_REGEXP.exec(timePeriod);
};
/**
 * Converts a annual time period id into a number.
 * Returns NaN if the value cannot be parsed as an annual time period.
 * `'2014'` > `2014.0`
 *
 * @param {string} timePeriod
 */


var annualIdToNumber = function annualIdToNumber(timePeriod) {
  var matches = parseAnnualId(timePeriod);

  if (!matches) {
    return NaN;
  }

  return int(matches[1]);
};
/**
 * Converts a quarterly time period id into a number.
 * Returns NaN if the value cannot be parsed as a quarterly time period.
 * `'2014-Q2'` > `2014.25`
 *
 * @param {string} timePeriod
 */


var quarterlyIdToNumber = function quarterlyIdToNumber(timePeriod) {
  var matches = parseQuarterlyId(timePeriod);

  if (!matches) {
    return NaN;
  }

  var year = int(matches[1]);
  var quarter = int(matches[2]);
  var fraction = (quarter - 1) / 4;
  return year + fraction;
};
/**
 * Converts a monthly time period id into a number.
 * Returns NaN if the value cannot be parsed as a monthly time period.
 * `'2014-01'` > `2014.0`
 *
 * @param {string} timePeriod
 */


var monthlyIdToNumber = function monthlyIdToNumber(timePeriod) {
  var matches = parseMonthlyId(timePeriod);

  if (!matches) {
    return NaN;
  }

  var year = int(matches[1]);
  var month = int(matches[2]);
  var fraction = (month - 1) / 12;
  return year + fraction;
};

var timePeriodConversion = {
  /**
   * Converts a time period id into a Date object.
   * Use the first month and day of the year, quarter, month.
   *
   * Annual:
   *   `'2014'` > `Date(2014, 0, 1)`
   * Quarterly:
   *   `'2014-Q1'` > `Date(2014, 0, 1)`
   *   `'2014-Q2'` > `Date(2014, 3, 1)`
   *   `'2014-Q3'` > `Date(2014, 6, 1)`
   *   `'2014-Q4'` > `Date(2014, 9, 1)`
   * Monthly:
   *   `'2014-01'` > `Date(2014, 0, 1)`
   *
   * @param {string} timePeriod
   */
  idToDate: function idToDate(timePeriod) {
    var matches, year;

    if (isAnnualId(timePeriod)) {
      year = int(timePeriod);
      return new Date(year, 0);
    } else if (matches = parseQuarterlyId(timePeriod)) {
      year = int(matches[1]);
      var quarter = int(matches[2]);

      var month = function () {
        switch (quarter) {
          case 1:
            return 0;

          case 2:
            return 3;

          case 3:
            return 6;

          case 4:
            return 9;

          default:
            return 0;
        }
      }();

      return new Date(year, month, 1);
    } else if (matches = parseMonthlyId(timePeriod)) {
      return new Date(matches[1], Number(matches[2]) - 1, 1);
    } else {
      throw new TypeError("idToDate: ".concat(timePeriod, " cannot be converted"));
    }
  },

  /**
   * Converts a time period id into a number.
   * The frequency must be given.
   * Annual: `'2014'` > `2014.0`
   * Quarterly: `'2014-Q2'` > `2014.25`
   * Monthly: `'2014-01'` > `2014.0`
   *
   * @param {Frequency} frequency
   * @param {string} timePeriod
   */
  idToNumber: function idToNumber(frequency, timePeriod) {
    switch (frequency) {
      case ANNUAL:
        return annualIdToNumber(timePeriod);

      case QUARTERLY:
        return quarterlyIdToNumber(timePeriod);

      case MONTHLY:
        return monthlyIdToNumber(timePeriod);

      default:
        throw new TypeError('idToNumber: invalid frequency given');
    }
  },

  /**
   * Converts a time period id into a number.
   * Automatically detects the frequency.
   * Annual: `'2014'` > `2014.0`
   * Quarterly: `'2014-Q2'` > `2014.25`
   * Monthly: `'2014-01'` > `2014.0`
   *
   * @param {string} timePeriod
   */
  idToNumberDetectFrequency: function idToNumberDetectFrequency(timePeriod) {
    var result = annualIdToNumber(timePeriod);

    if (result) {
      return result;
    }

    result = quarterlyIdToNumber(timePeriod);

    if (result) {
      return result;
    }

    result = monthlyIdToNumber(timePeriod);

    if (result) {
      return result;
    }

    throw new TypeError("idToNumberDetectFrequency: ".concat(timePeriod, " cannot be parsed"));
  },

  /**
   * Converts a float number into a time period ID.
   * The frequency must be given.
   * Annual: `2014.0` > `'2014'`
   * Quarterly: `2014.25 > `'2014-Q2'`
   * Monthly: `2014.0 > `'2014-01'`
   *
   * @param {Frequency} frequency
   * @param {number} number
   */
  numberToId: function numberToId(frequency, number) {
    switch (frequency) {
      case ANNUAL:
        return "".concat(int(number));

      case QUARTERLY:
        var year = Math.floor(number);
        var quarter = number % 1 * PERIOD_FRACTIONS[QUARTERLY] + 1;
        return "".concat(year, "-Q").concat(quarter);

      case MONTHLY:
        year = Math.floor(number);
        var month = Math.round(number % 1 * PERIOD_FRACTIONS[MONTHLY] + 1);

        if (month < 10) {
          month = "0".concat(month);
        }

        return "".concat(year, "-").concat(month);

      default:
        throw new TypeError('numberToId: invalid frequency given');
    }
  },

  /**
   * Converts Date object into a time period id.
   * Annual:
   *   `Date(2014, ?, ?)` > `'2014'`
   * Quarterly:
   *   `Date(2014, 0-2, ?)` > `'2014-Q1'`
   *   `Date(2014, 3-5, ?)` > `'2014-Q2'`
   *   `Date(2014, 6-8, ?)` > `'2014-Q3'`
   *   `Date(2014, 9-11, ?)` > `'2014-Q4'`
   * Monthly:
   *   `Date(2014, 0, ?)` > `'2014-01'`
   *
   * @param {Frequency} frequency
   * @param {Date} date
   */
  dateToId: function dateToId(frequency, date) {
    var year = date.getFullYear();

    switch (frequency) {
      case ANNUAL:
        return "".concat(year);

      case QUARTERLY:
        var quarter = Math.floor(date.getMonth() / 3) + 1;
        return "".concat(year, "-Q").concat(quarter);

      case MONTHLY:
        var month = date.getMonth() + 1;

        if (month < 10) {
          month = "0".concat(month);
        }

        return "".concat(year, "-").concat(month);

      default:
        throw new TypeError('dateToId: invalid frequency given');
    }
  },

  /**
   * Long human-readable format for UI labels
   * Example for English:
   * Annual:
   *   `'2014'` > `'2014'`
   * Quarterly:
   *   `'2014-Q2' > `'Q2 2014'`
   * Monthly:
   *   `'2014-01' > `'Jan 2014'`
   *
   * @param {Frequency} frequency
   * @param {string} timePeriod
   * @param {string?} separator
   */
  longTimePeriod: function longTimePeriod(frequency, timePeriod) {
    var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';

    switch (frequency) {
      case ANNUAL:
        return timePeriod;

      case QUARTERLY:
        var matches = parseQuarterlyId(timePeriod);
        var year = matches[1];
        var quarter = matches[2];
        var quarterPrefix = I18n.t('general.quarterShort');
        return "".concat(quarterPrefix).concat(quarter).concat(separator).concat(year);

      case MONTHLY:
        matches = parseMonthlyId(timePeriod);
        year = matches[1];
        var month = int(matches[2]) - 1;
        month = I18n.t('general.shortMonths')[month];
        return "".concat(month).concat(separator).concat(year);

      default:
        throw new TypeError('longTimePeriod: invalid frequency given');
    }
  },

  /**
   * Returns the regular expression for a given frequency
   *
   * @param {Frequency} frequency
   */
  regExp: function regExp(frequency) {
    return REGEXPS[frequency];
  },

  /**
   * Returns the step for a given frequency for the number representation
   *
   * @param {Frequency} frequency
   */
  numberStep: function numberStep(frequency) {
    return NUMBER_STEPS[frequency];
  }
}; // Memoize all functions

timePeriodConversion = _.mapValues(timePeriodConversion, memoize);

if (typeof Object.freeze === 'function') {
  Object.freeze(timePeriodConversion);
}

module.exports = timePeriodConversion;

},{"../constants/frequencies":72,"../i18n":82,"./math":132,"./memoize":133,"lodash":"lodash"}],142:[function(require,module,exports){
'use strict';

var I18n = require('../i18n');
/**
 * Returns intelligent actual time ranges depending on the displayed chart type:
 * 2015 or latest available, 2010  2014, 2010, 2015 or 2015.
 *
 * @param {string} startTime Formatted start time (human-readable, not the internal id)
 * @param {string} endTime Formatted end time (human-readable, not the internal id)
 * @param {number} shownTimePeriods How many time periods the chart is able to visualize
 * @param {boolean} useLatestData
 */


var timeRange = function timeRange(startTime, endTime, shownTimePeriods, useLatestData) {
  var time, shortTime;

  if (useLatestData) {
    // Charts that show the latest data:
    // Use the end time and the suffix or latest available
    time = "".concat(endTime, " ").concat(I18n.t('chartHeader.endTimeLatestData'));
    shortTime = endTime;
  } else if (shownTimePeriods === Infinity) {
    // Charts that show several time periods:
    // Use a range
    if (endTime && endTime !== startTime) {
      time = "".concat(startTime, " \u2013 ").concat(endTime);
      shortTime = time;
    } else {
      // Only one period present
      time = startTime;
      shortTime = startTime;
    }
  } else if (shownTimePeriods === 2) {
    // Charts that show two time periods:
    // List first and last
    time = "".concat(startTime, ", ").concat(endTime);
    shortTime = time;
  } else {
    // Charts that show one time period:
    // Use the end time, since they show the latest
    time = endTime;
    shortTime = endTime;
  }

  return {
    time: time,
    shortTime: shortTime
  };
};

module.exports = timeRange;

},{"../i18n":82}],143:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _ = require('lodash');

var HTTP_WITH_PROTOCOL = /^https?:\/\//;
/**
 * URL helpers from Chaplin.js (MIT-licensed)
 * https://github.com/chaplinjs/chaplin/blob/master/src/chaplin/lib/utils.coffee
 */

var urlUtil = {
  /**
   * Returns a hash with query parameters from a query string
   *
   * @param {string} queryString
   * @returns {{ [key: string]: string }}
   */
  parseQueryString: function parseQueryString(queryString) {
    var params = {};

    if (!queryString) {
      return params;
    }

    queryString = queryString.slice(queryString.indexOf('?') + 1);
    var pairs = queryString.split('&');

    for (var i = 0, l = pairs.length; i < l; i++) {
      var pair = pairs[i];

      if (!pair.length) {
        continue;
      }

      var _pair$split = pair.split('='),
          _pair$split2 = (0, _slicedToArray2.default)(_pair$split, 2),
          field = _pair$split2[0],
          value = _pair$split2[1];

      if (!field.length) {
        continue;
      }

      field = decodeURIComponent(field);
      value = decodeURIComponent(value);
      var current = params[field];

      if (current) {
        // Handle multiple params with same name: Aggregate them in an array.
        if (current.push) {
          // Add the existing array.
          current.push(value);
        } else {
          // Create a new array.
          params[field] = [current, value];
        }
      } else {
        params[field] = value;
      }
    }

    return params;
  },

  /**
   * Creates a query string from a given hash.
   *
   * @param {{ [key: string]: string }} params
   * @returns {string}
   */
  stringifyQueryString: function stringifyQueryString(params) {
    params = _.map(params, function (value, key) {
      return encodeURIComponent(key) + '=' + encodeURIComponent(value);
    }).join('&');

    if (params) {
      params = "?".concat(params);
    }

    return params;
  },

  /**
   * Returns whether the request is cross-domain. A request is cross-domain
   * if the protocol, host or port differ from the current pages URL.
   *
   * @param {string} url
   */
  isCrossDomain: function isCrossDomain(url) {
    var baseURL = "".concat(location.protocol, "//").concat(location.host, "/");
    var absoluteURL = url; // Treat URLs without protocol/host

    if (!HTTP_WITH_PROTOCOL.test(url)) {
      absoluteURL = urlUtil.resolve(url);
    } // absoluteURL starts with baseURI?


    return absoluteURL.indexOf(baseURL) !== 0;
  },

  /**
   * Resolves a relative URL to an absolute using an a element
   * https://github.com/jquery/jquery/blob/1.11.1/src/ajax.js#L52-L56
   *
   * @param {string} url
   */
  resolve: function resolve(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
  },

  /**
   * Adds a protocol (e.g. http:) to a URL if it is protocol-relative.
   *
   * @param {string} protocol
   * @param {string} url
   */
  addProtocol: function addProtocol(protocol, url) {
    if (url.substring(0, 2) === '//') {
      return "".concat(protocol).concat(url);
    } else {
      return url;
    }
  },

  /**
   * Adds the protocol of the current page to a URL in case it is
   * protocol-relative, e.g.
   * `//example.org` => `http://example.org` or `https://example.org`
   * `http://example.org` => stays `http://example.org`
   *
   * @param {string} url
   */
  addCurrentProtocol: function addCurrentProtocol(url) {
    return urlUtil.addProtocol(location.protocol, url);
  }
};
module.exports = urlUtil;

},{"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/slicedToArray":20,"lodash":"lodash"}],144:[function(require,module,exports){
// Taken from d3.chart
// https://github.com/misoproject/d3.chart/blob/master/src/assert.js
// License: MIT license https://github.com/misoproject/d3.chart/blob/master/LICENSE-MIT
// Copyright (c) 2014 Irene Ros & Mike Pennisi
'use strict';

module.exports = function (test, message) {
  if (test) {
    return;
  }

  throw new Error('[d3.chart] ' + message);
};

},{}],145:[function(require,module,exports){
// Based on d3.chart
// Simplified version of the chart extensions.
// https://github.com/misoproject/d3.chart/blob/master/src/chart-extensions.js
// License: MIT license https://github.com/misoproject/d3.chart/blob/master/LICENSE-MIT
// Copyright (c) 2014 Irene Ros & Mike Pennisi
'use strict';

var d3 = require('d3');
/**
 * Returns the chart that the current selection belongs to.
 */


d3.selection.prototype.chart = function () {
  return this._chart;
}; // Implement `d3.selection.prototype.chart` for all selection types.


d3.selection.enter.prototype.chart = d3.selection.prototype.chart;
d3.transition.prototype.chart = d3.selection.enter.prototype.chart;

},{"d3":27}],146:[function(require,module,exports){
// Taken from d3.chart
// https://github.com/misoproject/d3.chart/blob/master/src/layer-extensions.js
// License: MIT license https://github.com/misoproject/d3.chart/blob/master/LICENSE-MIT
// Copyright (c) 2014 Irene Ros & Mike Pennisi
"use strict";

var d3 = require("d3");

var Layer = require("./layer");
/**
 * Create a new layer on the d3 selection from which it is called.
 *
 * @static
 *
 * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer
 *        constructor}
 * @returns {d3.selection}
 */


d3.selection.prototype.layer = function (options) {
  var layer = new Layer(this);
  var eventName; // Set layer methods (required)

  layer.dataBind = options.dataBind;
  layer.insert = options.insert; // Bind events (optional)

  if ("events" in options) {
    for (eventName in options.events) {
      layer.on(eventName, options.events[eventName]);
    }
  } // Mix the public methods into the D3.js selection (bound appropriately)


  this.on = function () {
    return layer.on.apply(layer, arguments);
  };

  this.off = function () {
    return layer.off.apply(layer, arguments);
  };

  this.draw = function () {
    return layer.draw.apply(layer, arguments);
  };

  return this;
};

},{"./layer":147,"d3":27}],147:[function(require,module,exports){
// Taken from d3.chart
// https://github.com/misoproject/d3.chart/blob/master/src/layer.js
// License: MIT license https://github.com/misoproject/d3.chart/blob/master/LICENSE-MIT
// Copyright (c) 2014 Irene Ros & Mike Pennisi
'use strict';

var d3 = require('d3');

var assert = require('./assert');

var lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;
/**
 * Create a layer using the provided `base`. The layer instance is *not*
 * exposed to d3.chart users. Instead, its instance methods are mixed in to the
 * `base` selection it describes; users interact with the instance via these
 * bound methods.
 *
 * @private
 * @constructor
 * @externalExample {runnable} layer
 *
 * @param {d3.selection} base The containing DOM node for the layer.
 */

var Layer = function Layer(base) {
  assert(base, 'Layers must be initialized with a base.');
  this._base = base;
  this._handlers = {};
};
/**
 * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This
 * implementation is "virtual"--it *must* be overridden by Layer instances.
 *
 * @param {Array} data Value passed to {@link Layer#draw}
 */


Layer.prototype.dataBind = function () {
  assert(false, 'Layers must specify a `dataBind` method.');
};
/**
 * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this
 * layer's `base`. This implementation is "virtual"--it *must* be overridden by
 * Layer instances.
 */


Layer.prototype.insert = function () {
  assert(false, 'Layers must specify an `insert` method.');
};
/**
 * Subscribe a handler to a "lifecycle event". These events (and only these
 * events) are triggered when {@link Layer#draw} is invoked--see that method
 * for more details on lifecycle events.
 *
 * @externalExample {runnable} layer-on
 *
 * @param {String} eventName Identifier for the lifecycle event for which to
 *        subscribe.
 * @param {Function} handler Callback function
 *
 * @returns {d3.selection} Reference to the layer's base.
 */


Layer.prototype.on = function (eventName, handler, options) {
  options = options || {};
  assert(lifecycleRe.test(eventName), "Unrecognized lifecycle event name specified to `Layer#on`: '" + eventName + "'.");

  if (!(eventName in this._handlers)) {
    this._handlers[eventName] = [];
  }

  this._handlers[eventName].push({
    callback: handler,
    chart: options.chart || null
  });

  return this._base;
};
/**
 * Unsubscribe the specified handler from the specified event. If no handler is
 * supplied, remove *all* handlers from the event.
 *
 * @externalExample {runnable} layer-off
 *
 * @param {String} eventName Identifier for event from which to remove
 *        unsubscribe
 * @param {Function} handler Callback to remove from the specified event
 *
 * @returns {d3.selection} Reference to the layer's base.
 */


Layer.prototype.off = function (eventName, handler) {
  var handlers = this._handlers[eventName];
  var idx;
  assert(lifecycleRe.test(eventName), "Unrecognized lifecycle event name specified to `Layer#off`: '" + eventName + "'.");

  if (!handlers) {
    return this._base;
  }

  if (arguments.length === 1) {
    handlers.length = 0;
    return this._base;
  }

  for (idx = handlers.length - 1; idx > -1; --idx) {
    if (handlers[idx].callback === handler) {
      handlers.splice(idx, 1);
    }
  }

  return this._base;
};
/**
 * Render the layer according to the input data: Bind the data to the layer
 * (according to {@link Layer#dataBind}, insert new elements (according to
 * {@link Layer#insert}, make lifecycle selections, and invoke all relevant
 * handlers (as attached via {@link Layer#on}) with the lifecycle selections.
 *
 * - update
 * - update:transition
 * - enter
 * - enter:transition
 * - exit
 * - exit:transition
 *
 * @externalExample {runnable} layer-draw
 *
 * @param {Array} data Data to drive the rendering.
 */


Layer.prototype.draw = function (data) {
  var bound, entering, events, selection, method, handlers, eventName, idx, len;
  bound = this.dataBind.call(this._base, data); // Although `bound instanceof d3.selection` is more explicit, it fails
  // in IE8, so we use duck typing to maintain compatability.

  assert(bound && bound.call === d3.selection.prototype.call, 'Invalid selection defined by `Layer#dataBind` method.');
  assert(bound.enter, 'Layer selection not properly bound.');
  entering = bound.enter();
  entering._chart = this._base._chart;
  events = [{
    name: 'update',
    selection: bound
  }, {
    name: 'enter',
    selection: entering,
    method: this.insert
  }, {
    name: 'merge',
    // Although the `merge` lifecycle event shares its selection object
    // with the `update` lifecycle event, the object's contents will be
    // modified when d3.chart invokes the user-supplied `insert` method
    // when triggering the `enter` event.
    selection: bound
  }, {
    name: 'exit',
    // Although the `exit` lifecycle event shares its selection object
    // with the `update` and `merge` lifecycle events, the object's
    // contents will be modified when d3.chart invokes
    // `d3.selection.exit`.
    selection: bound,
    method: bound.exit
  }];

  for (var i = 0, l = events.length; i < l; ++i) {
    eventName = events[i].name;
    selection = events[i].selection;
    method = events[i].method; // Some lifecycle selections modify shared state, so they must be
    // deferred until just prior to handler invocation.

    if (typeof method === 'function') {
      selection = method.call(selection);
    }

    if (selection.empty()) {
      continue;
    } // Although `selection instanceof d3.selection` is more explicit,
    // it fails in IE8, so we use duck typing to maintain
    // compatability.


    assert(selection && selection.call === d3.selection.prototype.call, "Invalid selection defined for '" + eventName + "' lifecycle event.");
    handlers = this._handlers[eventName];

    if (handlers) {
      for (idx = 0, len = handlers.length; idx < len; ++idx) {
        // Attach a reference to the parent chart so the selection"s
        // `chart` method will function correctly.
        selection._chart = handlers[idx].chart || this._base._chart;
        selection.call(handlers[idx].callback);
      }
    }

    handlers = this._handlers[eventName + ':transition'];

    if (handlers && handlers.length) {
      selection = selection.transition();

      for (idx = 0, len = handlers.length; idx < len; ++idx) {
        selection._chart = handlers[idx].chart || this._base._chart;
        selection.call(handlers[idx].callback);
      }
    }
  }
};

module.exports = Layer;

},{"./assert":144,"d3":27}],148:[function(require,module,exports){
"use strict";

var d3 = require('d3'); // Taken from:
// https://github.com/d3/d3-geo-projection
// License:
// https://github.com/d3/d3-geo-projection/blob/master/LICENSE
// Source files:
// https://github.com/d3/d3-geo-projection/blob/master/src/math.js
// https://github.com/d3/d3-geo-projection/blob/master/src/van-der-grinten3.js


(function () {
  var  = 1e-6,
       = Math.PI,
      half =  / 2;
  var projection = d3.geo.projection;

  function sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }

  function asin(x) {
    return x > 1 ? half : x < -1 ? -half : Math.asin(x);
  }

  function asqrt(x) {
    return x > 0 ? Math.sqrt(x) : 0;
  }

  function vanDerGrinten3(, ) {
    if (Math.abs() < ) return [, 0];
    var sin =  / half,
         = asin(sin);
    if (Math.abs() <  || Math.abs(Math.abs() - half) < ) return [0,  * Math.tan( / 2)];
    var A = ( /  -  / ) / 2,
        y1 = sin / (1 + Math.cos());
    return [ * (sgn() * asqrt(A * A + 1 - y1 * y1) - A),  * y1];
  }

  vanDerGrinten3.invert = function (x, y) {
    if (!y) return [x, 0];
    var y1 = y / ,
        A = ( *  * (1 - y1 * y1) - x * x) / (2 *  * x);
    return [x ?  * (sgn(x) * Math.sqrt(A * A + 1) - A) : 0, half * Math.sin(2 * Math.atan(y1))];
  };

  (d3.geo.vanDerGrinten3 = function () {
    return projection(vanDerGrinten3);
  }).raw = vanDerGrinten3;
})();

},{"d3":27}],149:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function (window, document, exportName, undefined) {
  'use strict';
  /*
  Added by Mathias Schfer, 9elements:
  Fail fast in IE 8 and other old browser we do not provide
  with interactive charts anyway.
  */

  if (!Object.create) {
    return;
  }

  var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');
  var TYPE_FUNCTION = 'function';
  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;
  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */

  function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
  }
  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */


  function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
      each(arg, context[fn], context);
      return true;
    }

    return false;
  }
  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */


  function each(obj, iterator, context) {
    var i;

    if (!obj) {
      return;
    }

    if (obj.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
      i = 0;

      while (i < obj.length) {
        iterator.call(context, obj[i], i, obj);
        i++;
      }
    } else {
      for (i in obj) {
        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
      }
    }
  }
  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge]
   * @returns {Object} dest
   */


  function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;

    while (i < keys.length) {
      if (!merge || merge && dest[keys[i]] === undefined) {
        dest[keys[i]] = src[keys[i]];
      }

      i++;
    }

    return dest;
  }
  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */


  function merge(dest, src) {
    return extend(dest, src, true);
  }
  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */


  function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;
    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
      extend(childP, properties);
    }
  }
  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */


  function bindFn(fn, context) {
    return function boundFn() {
      return fn.apply(context, arguments);
    };
  }
  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */


  function boolOrFn(val, args) {
    if ((0, _typeof2.default)(val) == TYPE_FUNCTION) {
      return val.apply(args ? args[0] || undefined : undefined, args);
    }

    return val;
  }
  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */


  function ifUndefined(val1, val2) {
    return val1 === undefined ? val2 : val1;
  }
  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function addEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.addEventListener(type, handler, false);
    });
  }
  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function removeEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.removeEventListener(type, handler, false);
    });
  }
  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */


  function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }

      node = node.parentNode;
    }

    return false;
  }
  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */


  function inStr(str, find) {
    return str.indexOf(find) > -1;
  }
  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */


  function splitStr(str) {
    return str.trim().split(/\s+/g);
  }
  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */


  function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
      return src.indexOf(find);
    } else {
      var i = 0;

      while (i < src.length) {
        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
          return i;
        }

        i++;
      }

      return -1;
    }
  }
  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */


  function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  }
  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */


  function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
      var val = key ? src[i][key] : src[i];

      if (inArray(values, val) < 0) {
        results.push(src[i]);
      }

      values[i] = val;
      i++;
    }

    if (sort) {
      if (!key) {
        results = results.sort();
      } else {
        results = results.sort(function sortUniqueArray(a, b) {
          return a[key] > b[key];
        });
      }
    }

    return results;
  }
  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */


  function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);
    var i = 0;

    while (i < VENDOR_PREFIXES.length) {
      prefix = VENDOR_PREFIXES[i];
      prop = prefix ? prefix + camelProp : property;

      if (prop in obj) {
        return prop;
      }

      i++;
    }

    return undefined;
  }
  /**
   * get a unique id
   * @returns {number} uniqueId
   */


  var _uniqueId = 1;

  function uniqueId() {
    return _uniqueId++;
  }
  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */


  function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return doc.defaultView || doc.parentWindow;
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';
  var COMPUTE_INTERVAL = 25;
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;
  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;
  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];
  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */

  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.

    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };

    this.init();
  }

  Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function handler() {},

    /**
     * bind the events
     */
    init: function init() {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function destroy() {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
  };
  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */

  function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
      Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
      Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
      Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
      Type = MouseInput;
    } else {
      Type = TouchMouseInput;
    }

    return new Type(manager, inputHandler);
  }
  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */


  function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
      manager.session = {};
    } // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'


    input.eventType = eventType; // compute scale, rotation etc

    computeInputData(manager, input); // emit secret event

    manager.emit('hammer.input', input);
    manager.recognize(input);
    manager.session.prevInput = input;
  }
  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */


  function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length; // store the first input to calculate the distance and direction

    if (!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    } // to compute scale and rotation we need to store the multiple touches


    if (pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
      session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);
    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
    computeIntervalInputData(session, input); // find the correct target

    var target = manager.element;

    if (hasParent(input.srcEvent.target, target)) {
      target = input.srcEvent.target;
    }

    input.target = target;
  }

  function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
      prevDelta = session.prevDelta = {
        x: prevInput.deltaX || 0,
        y: prevInput.deltaY || 0
      };
      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
  }
  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */


  function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity,
        velocityX,
        velocityY,
        direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
      var deltaX = last.deltaX - input.deltaX;
      var deltaY = last.deltaY - input.deltaY;
      var v = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v.x;
      velocityY = v.y;
      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
      direction = getDirection(deltaX, deltaY);
      session.lastInterval = input;
    } else {
      // use latest velocity info if it doesn't overtake a minimum period
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }
  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */


  function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;

    while (i < input.pointers.length) {
      pointers[i] = {
        clientX: round(input.pointers[i].clientX),
        clientY: round(input.pointers[i].clientY)
      };
      i++;
    }

    return {
      timeStamp: now(),
      pointers: pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }
  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */


  function getCenter(pointers) {
    var pointersLength = pointers.length; // no need to loop when only one touch

    if (pointersLength === 1) {
      return {
        x: round(pointers[0].clientX),
        y: round(pointers[0].clientY)
      };
    }

    var x = 0,
        y = 0,
        i = 0;

    while (i < pointersLength) {
      x += pointers[i].clientX;
      y += pointers[i].clientY;
      i++;
    }

    return {
      x: round(x / pointersLength),
      y: round(y / pointersLength)
    };
  }
  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */


  function getVelocity(deltaTime, x, y) {
    return {
      x: x / deltaTime || 0,
      y: y / deltaTime || 0
    };
  }
  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */


  function getDirection(x, y) {
    if (x === y) {
      return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
      return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }

    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }
  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */


  function getDistance(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.sqrt(x * x + y * y);
  }
  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */


  function getAngle(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
  }
  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */


  function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }
  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */


  function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */

  function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    this.allow = true; // used by Input.TouchMouse to disable mouse events

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

      if (eventType & INPUT_START && ev.button === 0) {
        this.pressed = true;
      }

      if (eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      } // mouse must be down, and mouse events are allowed (see the TouchMouse input)


      if (!this.pressed || !this.allow) {
        return;
      }

      if (eventType & INPUT_END) {
        this.pressed = false;
      }

      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    }
  });
  var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
  }; // in IE10 the pointer types is defined as an enum

  var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

  };
  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

  if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }
  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */


  function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;
    Input.apply(this, arguments);
    this.store = this.manager.session.pointerEvents = [];
  }

  inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
      var store = this.store;
      var removePointer = false;
      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
      var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store

      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      } // it not found, so the pointer hasn't been down (so it's probably a hover)


      if (storeIndex < 0) {
        return;
      } // update the event in the store


      store[storeIndex] = ev;
      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });

      if (removePointer) {
        // remove from the store
        store.splice(storeIndex, 1);
      }
    }
  });
  var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * Touch events input
   * @constructor
   * @extends Input
   */

  function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;
    Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

      if (type === INPUT_START) {
        this.started = true;
      }

      if (!this.started) {
        return;
      }

      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });
  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */

  function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
      all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */

  function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};
    Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);

      if (!touches) {
        return;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });
  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */

  function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
      targetIds[allTouches[0].identifier] = true;
      return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target; // get target touches from touches

    targetTouches = allTouches.filter(function (touch) {
      return hasParent(touch.target, target);
    }); // collect touches

    if (type === INPUT_START) {
      i = 0;

      while (i < targetTouches.length) {
        targetIds[targetTouches[i].identifier] = true;
        i++;
      }
    } // filter changed touches to only contain touches that exist in the collected target ids


    i = 0;

    while (i < changedTouches.length) {
      if (targetIds[changedTouches[i].identifier]) {
        changedTargetTouches.push(changedTouches[i]);
      } // cleanup removed touches


      if (type & (INPUT_END | INPUT_CANCEL)) {
        delete targetIds[changedTouches[i].identifier];
      }

      i++;
    }

    if (!changedTargetTouches.length) {
      return;
    }

    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
  }
  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */


  function TouchMouseInput() {
    Input.apply(this, arguments);
    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
  }

  inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
          isMouse = inputData.pointerType == INPUT_TYPE_MOUSE; // when we're in a touch event, so  block all upcoming mouse events
      // most mobile browser also emit mouseevents, right after touchstart

      if (isTouch) {
        this.mouse.allow = false;
      } else if (isMouse && !this.mouse.allow) {
        return;
      } // reset the allowMouse when we're done


      if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
        this.mouse.allow = true;
      }

      this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    }
  });
  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value

  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */

  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }

  TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function set(value) {
      // find out the touch-action by the event handlers
      if (value == TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }

      if (NATIVE_TOUCH_ACTION) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }

      this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function update() {
      this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function compute() {
      var actions = [];
      each(this.manager.recognizers, function (recognizer) {
        if (boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function preventDefaults(input) {
      // not needed with native support for the touchAction property
      if (NATIVE_TOUCH_ACTION) {
        return;
      }

      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection; // if the touch action did prevented once this session

      if (this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }

      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
        return this.preventSrc(srcEvent);
      }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function preventSrc(srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    }
  };
  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */

  function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // pan-x and pan-y can be combined

    if (hasPanX && hasPanY) {
      return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    } // pan-x OR pan-y


    if (hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    } // manipulation


    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
  }
  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */


  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;
  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */

  function Recognizer(options) {
    this.id = uniqueId();
    this.manager = null;
    this.options = merge(options || {}, this.defaults); // default is enable true

    this.options.enable = ifUndefined(this.options.enable, true);
    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }

  Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function set(options) {
      extend(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

      this.manager && this.manager.touchAction.update();
      return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function recognizeWith(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }

      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }

      return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function requireFailure(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }

      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }

      return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function dropRequireFailure(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);

      if (index > -1) {
        this.requireFail.splice(index, 1);
      }

      return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function hasRequireFailures() {
      return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function canRecognizeWith(otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function emit(input) {
      var self = this;
      var state = this.state;

      function emit(withState) {
        self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
      } // 'panstart' and 'panmove'


      if (state < STATE_ENDED) {
        emit(true);
      }

      emit(); // simple 'eventName' events
      // panend and pancancel

      if (state >= STATE_ENDED) {
        emit(true);
      }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function tryEmit(input) {
      if (this.canEmit()) {
        return this.emit(input);
      } // it's failing anyway


      this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function canEmit() {
      var i = 0;

      while (i < this.requireFail.length) {
        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }

        i++;
      }

      return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function recognize(inputData) {
      // make a new copy of the inputData
      // so we can change the inputData without messing up the other recognizers
      var inputDataClone = extend({}, inputData); // is is enabled and allow recognizing?

      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      } // reset when we've reached the end


      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }

      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
      // so trigger an event

      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function process(inputData) {},
    // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function getTouchAction() {},

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function reset() {}
  };
  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */

  function stateStr(state) {
    if (state & STATE_CANCELLED) {
      return 'cancel';
    } else if (state & STATE_ENDED) {
      return 'end';
    } else if (state & STATE_CHANGED) {
      return 'move';
    } else if (state & STATE_BEGAN) {
      return 'start';
    }

    return '';
  }
  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */


  function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
      return 'down';
    } else if (direction == DIRECTION_UP) {
      return 'up';
    } else if (direction == DIRECTION_LEFT) {
      return 'left';
    } else if (direction == DIRECTION_RIGHT) {
      return 'right';
    }

    return '';
  }
  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */


  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;

    if (manager) {
      return manager.get(otherRecognizer);
    }

    return otherRecognizer;
  }
  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */


  function AttrRecognizer() {
    Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
      /**
       * @type {Number}
       * @default 1
       */
      pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function attrTest(input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function process(input) {
      var state = this.state;
      var eventType = input.eventType;
      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if (isRecognized || isValid) {
        if (eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if (!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }

        return state | STATE_CHANGED;
      }

      return STATE_FAILED;
    }
  });
  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */

  function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);
    this.pX = null;
    this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    },
    getTouchAction: function getTouchAction() {
      var direction = this.options.direction;
      var actions = [];

      if (direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }

      if (direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }

      return actions;
    },
    directionTest: function directionTest(input) {
      var options = this.options;
      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;
      var x = input.deltaX;
      var y = input.deltaY; // lock to axis?

      if (!(direction & options.direction)) {
        if (options.direction & DIRECTION_HORIZONTAL) {
          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x != this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y != this.pY;
          distance = Math.abs(input.deltaY);
        }
      }

      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    },
    attrTest: function attrTest(input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
    },
    emit: function emit(input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;
      var direction = directionStr(input.direction);

      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }

      this._super.emit.call(this, input);
    }
  });
  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */

  function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'pinch',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function getTouchAction() {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function attrTest(input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },
    emit: function emit(input) {
      this._super.emit.call(this, input);

      if (input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        this.manager.emit(this.options.event + inOut, input);
      }
    }
  });
  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */

  function PressRecognizer() {
    Recognizer.apply(this, arguments);
    this._timer = null;
    this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
      event: 'press',
      pointers: 1,
      time: 500,
      // minimal time of the pointer to be pressed
      threshold: 5 // a minimal movement is ok, but keep it low

    },
    getTouchAction: function getTouchAction() {
      return [TOUCH_ACTION_AUTO];
    },
    process: function process(input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;
      this._input = input; // we only allow little movement
      // and we've reached an end event, so a tap is possible

      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
        this.reset();
      } else if (input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeoutContext(function () {
          this.state = STATE_RECOGNIZED;
          this.tryEmit();
        }, options.time, this);
      } else if (input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }

      return STATE_FAILED;
    },
    reset: function reset() {
      clearTimeout(this._timer);
    },
    emit: function emit(input) {
      if (this.state !== STATE_RECOGNIZED) {
        return;
      }

      if (input && input.eventType & INPUT_END) {
        this.manager.emit(this.options.event + 'up', input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    }
  });
  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */

  function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
      event: 'rotate',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function getTouchAction() {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function attrTest(input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
  });
  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */

  function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
      event: 'swipe',
      threshold: 10,
      velocity: 0.65,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    },
    getTouchAction: function getTouchAction() {
      return PanRecognizer.prototype.getTouchAction.call(this);
    },
    attrTest: function attrTest(input) {
      var direction = this.options.direction;
      var velocity;

      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.velocity;
      } else if (direction & DIRECTION_HORIZONTAL) {
        velocity = input.velocityX;
      } else if (direction & DIRECTION_VERTICAL) {
        velocity = input.velocityY;
      }

      return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },
    emit: function emit(input) {
      var direction = directionStr(input.direction);

      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }

      this.manager.emit(this.options.event, input);
    }
  });
  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */

  function TapRecognizer() {
    Recognizer.apply(this, arguments); // previous time and center,
    // used for tap counting

    this.pTime = false;
    this.pCenter = false;
    this._timer = null;
    this._input = null;
    this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 2,
      // a minimal movement is ok, but keep it low
      posThreshold: 10 // a multi-tap can be a bit off the initial position

    },
    getTouchAction: function getTouchAction() {
      return [TOUCH_ACTION_MANIPULATION];
    },
    process: function process(input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;
      this.reset();

      if (input.eventType & INPUT_START && this.count === 0) {
        return this.failTimeout();
      } // we only allow little movement
      // and we've reached an end event, so a tap is possible


      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType != INPUT_END) {
          return this.failTimeout();
        }

        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;

        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }

        this._input = input; // if tap count matches we have recognized it,
        // else it has began recognizing...

        var tapCount = this.count % options.taps;

        if (tapCount === 0) {
          // no failing requirements, immediately trigger the tap event
          // or wait as long as the multitap interval to trigger
          if (!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeoutContext(function () {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.interval, this);
            return STATE_BEGAN;
          }
        }
      }

      return STATE_FAILED;
    },
    failTimeout: function failTimeout() {
      this._timer = setTimeoutContext(function () {
        this.state = STATE_FAILED;
      }, this.options.interval, this);
      return STATE_FAILED;
    },
    reset: function reset() {
      clearTimeout(this._timer);
    },
    emit: function emit() {
      if (this.state == STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    }
  });
  /**
   * Simple way to create an manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */

  function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
  }
  /**
   * @const {string}
   */


  Hammer.VERSION = '2.0.4';
  /**
   * default settings
   * @namespace
   */

  Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
    [RotateRecognizer, {
      enable: false
    }], [PinchRecognizer, {
      enable: false
    }, ['rotate']], [SwipeRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }], [PanRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }, ['swipe']], [TapRecognizer], [TapRecognizer, {
      event: 'doubletap',
      taps: 2
    }, ['tap']], [PressRecognizer]],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
      /**
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userSelect: 'none',

      /**
       * Disable the Windows Phone grippers when pressing an element.
       * @type {String}
       * @default 'none'
       */
      touchSelect: 'none',

      /**
       * Disables the default callout shown when you touch and hold a touch target.
       * On iOS, when you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       * @type {String}
       * @default 'none'
       */
      touchCallout: 'none',

      /**
       * Specifies whether zooming is enabled. Used by IE10>
       * @type {String}
       * @default 'none'
       */
      contentZooming: 'none',

      /**
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userDrag: 'none',

      /**
       * Overrides the highlight color shown when the user taps a link or a JavaScript
       * clickable element in iOS. This property obeys the alpha value, if specified.
       * @type {String}
       * @default 'rgba(0,0,0,0)'
       */
      tapHighlightColor: 'rgba(0,0,0,0)'
    }
  };
  var STOP = 1;
  var FORCED_STOP = 2;
  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */

  function Manager(element, options) {
    options = options || {};
    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(options.recognizers, function (item) {
      var recognizer = this.add(new item[0](item[1]));
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }

  Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function set(options) {
      extend(this.options, options); // Options that need a little more setup

      if (options.touchAction) {
        this.touchAction.update();
      }

      if (options.inputTarget) {
        // Clean up existing event listeners and reinitialize
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }

      return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function stop(force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function recognize(inputData) {
      var session = this.session;

      if (session.stopped) {
        return;
      } // run the touch-action polyfill


      this.touchAction.preventDefaults(inputData);
      var recognizer;
      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
      // if no recognizer is detecting a thing, it is set to `null`

      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
      // or when we're in a new session

      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
        curRecognizer = session.curRecognizer = null;
      }

      var i = 0;

      while (i < recognizers.length) {
        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
        //      that is being recognized.
        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
        //      this can be setup with the `recognizeWith()` method on the recognizer.

        if (session.stopped !== FORCED_STOP && ( // 1
        !curRecognizer || recognizer == curRecognizer || // 2
        recognizer.canRecognizeWith(curRecognizer))) {
          // 3
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
        // current active recognizer. but only if we don't already have an active recognizer


        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          curRecognizer = session.curRecognizer = recognizer;
        }

        i++;
      }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function get(recognizer) {
      if (recognizer instanceof Recognizer) {
        return recognizer;
      }

      var recognizers = this.recognizers;

      for (var i = 0; i < recognizers.length; i++) {
        if (recognizers[i].options.event == recognizer) {
          return recognizers[i];
        }
      }

      return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function add(recognizer) {
      if (invokeArrayArg(recognizer, 'add', this)) {
        return this;
      } // remove existing


      var existing = this.get(recognizer.options.event);

      if (existing) {
        this.remove(existing);
      }

      this.recognizers.push(recognizer);
      recognizer.manager = this;
      this.touchAction.update();
      return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function remove(recognizer) {
      if (invokeArrayArg(recognizer, 'remove', this)) {
        return this;
      }

      var recognizers = this.recognizers;
      recognizer = this.get(recognizer);
      recognizers.splice(inArray(recognizers, recognizer), 1);
      this.touchAction.update();
      return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function on(events, handler) {
      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function off(events, handler) {
      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        if (!handler) {
          delete handlers[event];
        } else {
          handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function emit(event, data) {
      // we also want to trigger dom events
      if (this.options.domEvents) {
        triggerDomEvent(event, data);
      } // no handlers, so skip it all


      var handlers = this.handlers[event] && this.handlers[event].slice();

      if (!handlers || !handlers.length) {
        return;
      }

      data.type = event;

      data.preventDefault = function () {
        data.srcEvent.preventDefault();
      };

      var i = 0;

      while (i < handlers.length) {
        handlers[i](data);
        i++;
      }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function destroy() {
      this.element && toggleCssProps(this, false);
      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    }
  };
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */

  function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function (value, name) {
      element.style[prefixed(element.style, name)] = add ? value : '';
    });
  }
  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */


  function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
  }

  extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,
    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,
    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,
    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,
    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,
    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,
    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
  });

  if ((typeof define === "undefined" ? "undefined" : (0, _typeof2.default)(define)) == TYPE_FUNCTION && define.amd) {
    define(function () {
      return Hammer;
    });
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
  } else {
    window[exportName] = Hammer;
  }
})(window, document, 'Hammer');

},{"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/typeof":24}],150:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require('lodash');

var $ = require('jquery');

var disposal = require('../util/disposal');

var methodBinding = require('../util/method-binding'); // Simple base view class similar to Backbone.View.
// Governs an element (this.el, this.$el) and
// a reference to a model (this.model).
// Might use the render pattern, but doesnt have to.
// Doesnt use an initialize method, but the constructor directly.

/** @typedef {{
 * el: HTMLElement | JQuery<HTMLElement>,
 * model?: Backbone.Model
 * }} BaseViewOptions */

/**
 * @typedef
 */


var BaseView = /*#__PURE__*/function () {
  // Property declarations
  // ---------------------
  //
  // el: Element
  // $el: jQuery
  // model: Model
  // tagName: String
  // disposed: boolean
  // disposedProperties: string[]

  /**
   * @param {BaseViewOptions} options
   */
  function BaseView(options) {
    (0, _classCallCheck2.default)(this, BaseView);

    /** @type {HTMLElement} */
    this.el;
    /** @type {JQuery<HTMLElement>} */

    this.$el;
    /** @type {string} */

    this.tagName;
    /** @type {boolean} */

    this.disposed;
    /** @type {string[]} */

    this.disposedProperties;
    /** @type {Backbone.Model} */

    this.model = options.model;
    this.setEl(options.el);
    this.bindMethods();
  }
  /**
   * @param {JQuery<HTMLElement>} selector
   */


  (0, _createClass2.default)(BaseView, [{
    key: "$",
    value: function $(selector) {
      return this.$el.find(selector);
    }
    /**
     * @param {HTMLElement | JQuery<HTMLElement> | null} el
     */

  }, {
    key: "setEl",
    value: function setEl(el) {
      if (el instanceof $) {
        this.el = el.get(0);
        this.$el = el;
      } else if (el) {
        this.el = el;
        this.$el = $(el);
      } else if (this.tagName) {
        this.el = document.createElement(this.tagName);
        this.$el = $(this.el);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      this.disposed = true; // Remove listeners from the model

      if (typeof this.model.off === 'function') {
        this.model.off(null, null, this);
      }

      disposal.disposeProperties(this);
    }
  }]);
  return BaseView;
}(); // Method binding
// --------------


_.assign(BaseView.prototype, methodBinding); // Disposal
// --------


BaseView.prototype.disposed = false;
BaseView.prototype.disposedProperties = ['el', '$el', 'model'];
module.exports = BaseView;

},{"../util/disposal":123,"../util/method-binding":134,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"jquery":"jquery","lodash":"lodash"}],151:[function(require,module,exports){
/* eslint-disable no-console */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var d3 = require('d3');

var CHART_TYPES = require('../constants/chart-types');

var logError = require('../util/logError');

var BaseView = require('./base-view');
/** @typedef {import('../charts/base-chart')} BaseChart} */

/** @typedef {import('../types/types').ChartDefinition} ChartDefinition */
// The ChartComponent encapsulates choice and creation of chart instance.


var ChartComponent = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(ChartComponent, _BaseView);

  var _super = _createSuper(ChartComponent);

  function ChartComponent() {
    (0, _classCallCheck2.default)(this, ChartComponent);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(ChartComponent, [{
    key: "render",
    value: // Property declarations
    // ---------------------
    //
    // chart: d3.Chart
    // Render with data
    function render(data) {
      // Start performance measurement
      var label, startTime;

      if (window.DDP_MEASURE_PERFORMANCE) {
        label = "".concat(this.model.get('displayType'), " chart");

        if (typeof console.profile === 'function') {
          console.profile(label);
        }

        if (console.time) {
          console.time(label);
        } else {
          startTime = new Date().getTime();
        }
      } // Payload


      this.ensureChart().draw(data); // Finish performance measurement

      if (window.DDP_MEASURE_PERFORMANCE) {
        var endTime = new Date().getTime();

        if (console.timeEnd) {
          console.timeEnd(label);
        } else {
          var diff = endTime - startTime;
          console.log('Duration:', diff);
        }

        if (typeof console.profileEnd === 'function') {
          console.profileEnd(label);
        }
      }

      return this;
    }
    /**
     * Creates an appropriate chart for `data`, saves it as `this.chart`
     * and returns it.
     *
     * @returns {BaseChart}
     */

  }, {
    key: "ensureChart",
    value: function ensureChart() {
      var type = this.model.get('displayType');
      var typeDefinition = CHART_TYPES[type];

      if (!typeDefinition) {
        logError("Unknown chart type ".concat(type));
        return;
      }

      if (this.chart && type === this.type) {
        // Reuse existing chart
        return this.chart;
      } // Store new type


      this.type = type; // Dispose existing chart

      if (this.chart) {
        this.chart.dispose();
      }

      this.$el.find('.ddp-chart-inner').remove();
      this.chart = this.createChart(typeDefinition);
      return this.chart;
    }
    /**
     * Creates a new chart instance
     *
     * @param {ChartDefinition} typeDefinition
     * @returns {BaseChart}
     */

  }, {
    key: "createChart",
    value: function createChart(typeDefinition) {
      var container = this.container(typeDefinition);
      var ChartConstructor = typeDefinition.constructor;
      return new ChartConstructor(container, {
        model: this.model
      });
    }
    /**
     * Creates a container element for the chart and returns a D3 selection.
     *
     * @param {ChartDefinition} typeDefinition
     */

  }, {
    key: "container",
    value: function container(typeDefinition) {
      // Use D3 instead of jQuery because D3 uses the correct SVG namespace.
      var container = d3.select(this.el);

      switch (typeDefinition.containerType) {
        case 'html':
          container = container.append('div').classed('html-chart', true);
          break;

        case 'svg':
          container = container.append('svg').classed('svg-chart', true);
          break;
      }

      container.classed('ddp-chart-inner', true);
      return container;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      this.chart.dispose();
      (0, _get2.default)((0, _getPrototypeOf2.default)(ChartComponent.prototype), "dispose", this).call(this);
    }
  }]);
  return ChartComponent;
}(BaseView); // Disposal
// --------


ChartComponent.prototype.disposedProperties = ['chart'];
module.exports = ChartComponent;

},{"../constants/chart-types":70,"../util/logError":131,"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"d3":27}],152:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var $ = require('jquery');

var I18n = require('../i18n');

var CHART_TYPES = require('../constants/chart-types');

var fullscreen = require('../util/fullscreen');

var analytics = require('../util/analytics');

var latestDataStartTime = require('../util/latest-data-start-time');

var _require = require('../util/download'),
    _downloadSelection = _require.downloadSelection,
    _downloadIndicator = _require.downloadIndicator;

var IndicatorMetadata = require('../models/indicator-metadata');

var AvailableCombinations = require('../models/available-combinations');

var pinboardMediator = require('../models/pinboard-mediator');

var timePeriodNavigation = require('../models/time-period-navigation');

var BaseView = require('./base-view');

var Dropdown = require('./dropdown');

var HighlightedLocationsOverlay = require('./highlighted-locations-overlay');

var EmbeddedShareView = require('./embedded-share-view');

var TimeSliderView = require('./time-slider-view'); // Constants
// ---------
// Meta-type for the Chart tab


var CHART_TYPE_CHART = 'chart'; // Chart types that are summarized under the Chart tab
// (the map has its own tab though its technically a chart)

var CHART_TYPES_AS_CHART = ['line', 'multipleLine', 'bar', 'symbol']; // Selectors
// ---------
// General

var CURRENT_CLASS = 'current';
var DISABLED_CLASS = 'disabled'; // Top controls

var FULLSCREEN_BUTTON_SELECTOR = '.chart-button.fullscreen-btn';
var SHARE_BUTTON_SELECTOR = '.chart-button.share-btn';
var DOWNLOAD_DROPDOWN_SELECTOR = '.download-dropdown';
var DOWNLOAD_SELECTION_SELECTOR = '.download-selection-button';
var DOWNLOAD_INDICATOR_SELECTOR = '.download-indicator-button';
var ADD_TO_PINBOARD_SELECTOR = '.add-to-pinboard-button';
var TYPE_BUTTON_SELECTOR = '.chart-types-button';
var CURRENT_TYPE_SELECTOR = ".chart-types .".concat(CURRENT_CLASS, " a"); // Subjects, measures, frequencies

var SUBJECT_MODE_CHECKBOX_SELECTOR = '.subject-mode-checkbox';
var SINGLE_SUBJECT_SELECTOR = '.single-subject-dropdown';
var MULTIPLE_SUBJECT_SELECTOR = '.multiple-subjects-dropdown';
var MEASURES_SELECTOR = '.dropdown.measures';
var FREQUENCIES_SELECTOR = '.frequencies a';
var CURRENT_FREQUENCY_SELECTOR = ".frequencies .".concat(CURRENT_CLASS, " a"); // Highlighted locations

var HIGHLIGHTED_LOCATIONS_DROPDOWN_SELECTOR = '.highlighted-locations-dropdown'; // Time controls

var USE_LATEST_DATA_CHECKBOX_SELECTOR = '.use-latest-data-checkbox';
var TIME_SLIDER_INNER_SELECTOR = '.time-slider-inner';
var CURRENT_TIME_PERIOD_SELECTOR = '.current-time-period';
var PREVIOUS_TIME_PERIOD_SELECTOR = '.previous-time-period';
var NEXT_TIME_PERIOD_SELECTOR = '.next-time-period';

var ChartControl = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(ChartControl, _BaseView);

  var _super = _createSuper(ChartControl);

  // Property declarations
  // ---------------------
  //
  // chartEl: Element
  //
  // metadata: IndicatorMetadata
  // availableCombinations: AvailableCombinations
  //
  // highlightedLocationsOverlay: HighlightedLocationsOverlay
  // timeSliderView: TimeSliderView
  //
  // subjectModeCheckbox: jQuery
  //
  // singleSubjectDropdown: Dropdown
  // multipleSubjectsDropdown: DropdownMultiple
  //  Present if multiple subjects are supported (symbol chart allowed)
  // measureDropdown: Dropdown
  function ChartControl(options) {
    var _this;

    (0, _classCallCheck2.default)(this, ChartControl);
    _this = _super.call(this, options);
    _this.chartEl = options.chartEl;
    return _this;
  } // Initial rendering
  // -----------------


  (0, _createClass2.default)(ChartControl, [{
    key: "render",
    value: function render() {
      // Init model
      this.registerModelHandlers();
      this.fetchMetadata();
      this.initAvailableCombinations(); // Init DOM

      this.registerDOMHandlers();
      this.initPinboardEditing();
      this.initSubjectModeCheckbox();
      this.initDropdowns();
      this.renderHighlightedLocationsOverlay(); // Initialize SMF controls from the model.
      // The state in the DOM might be overridden by carried over configuration.

      this.setSubjects(this.model.get('subjects'));
      this.setMeasure(this.model.get('measure'));
      this.setFrequency(this.model.get('frequency'));
      var useLatestData = this.model.get('useLatestData');
      this.setUseLatestData(useLatestData);
      this.activateTimePeriodNavigation(!useLatestData); // Update dependent controls using available combinations

      this.updateMeasures();
      this.updateFrequencies();
    } // Event handling
    // --------------

  }, {
    key: "registerModelHandlers",
    value: function registerModelHandlers() {
      var events = [['change:data', this.modelDataChanged], ['change:displayType', this.renderChartTypes], ['change:startTime change:endTime', _.debounce(this.modelTimePeriodsChanged, 10)]];

      for (var i = 0, l = events.length; i < l; i++) {
        var event = events[i];
        this.model.on(event[0], event[1], this);
      }
    }
  }, {
    key: "registerDOMHandlers",
    value: function registerDOMHandlers() {
      var domHandlers = [['click', FULLSCREEN_BUTTON_SELECTOR, this.requestFullscreen], ['click', SHARE_BUTTON_SELECTOR, this.shareChart], ['click', DOWNLOAD_SELECTION_SELECTOR, this.downloadSelection], ['click', DOWNLOAD_INDICATOR_SELECTOR, this.downloadIndicator], ['click', ADD_TO_PINBOARD_SELECTOR, this.addToPinboard], ['click', TYPE_BUTTON_SELECTOR, this.typeChanged], ['change', SUBJECT_MODE_CHECKBOX_SELECTOR, this.subjectModeChanged], ['change', SINGLE_SUBJECT_SELECTOR, this.singleSubjectChanged], ['change', MULTIPLE_SUBJECT_SELECTOR, this.multipleSubjectsChanged], ['change', MEASURES_SELECTOR, this.measureChanged], ['click', FREQUENCIES_SELECTOR, this.frequencyChanged], ['click', USE_LATEST_DATA_CHECKBOX_SELECTOR, this.useLatestDataChanged], ['click', PREVIOUS_TIME_PERIOD_SELECTOR, this.previousTimePeriod], ['click', NEXT_TIME_PERIOD_SELECTOR, this.nextTimePeriod]];

      for (var i = 0, l = domHandlers.length; i < l; i++) {
        var domHandler = domHandlers[i];
        this.$el.on(domHandler[0], domHandler[1], domHandler[2]);
      }
    } // Metadata
    // --------
    // Creates a metadata model from the model and fetches the metadata

  }, {
    key: "fetchMetadata",
    value: function fetchMetadata() {
      this.metadata = new IndicatorMetadata(this.model.pick('baseUrl', 'agencyName', 'dataset', 'indicator', 'language')); // Save metadata on the model so the charts can access it.

      this.model.set('metadata', this.metadata);
      this.metadata.fetch().then(this.applyMetadata);
    } // Use the metadata to fill and update the controls

  }, {
    key: "applyMetadata",
    value: function applyMetadata() {
      // Handle race condition. Metadata might be loaded before model data.
      if (!this.model.get('data')) {
        this.model.once('change:data', this.applyMetadata, this);
        return;
      } // Update controls that depend upon metadata


      this.renderTimeSlider(); // Fill dropdowns with the human-readable labels

      var metadata = this.metadata.get('data');
      this.singleSubjectDropdown.updateLabels(metadata.subjects);

      if (this.multipleSubjectsDropdown) {
        this.multipleSubjectsDropdown.updateLabels(metadata.subjects);
      }

      this.measureDropdown.updateLabels(metadata.measures);
    } // Initializers
    // ------------
    // Creates the AvailableCombinations models for availability queries

  }, {
    key: "initAvailableCombinations",
    value: function initAvailableCombinations() {
      this.availableCombinations = new AvailableCombinations(this.model, this.metadata);
    } // Initializes the pinboard editing if a matching chart model is in edit mode.

  }, {
    key: "initPinboardEditing",
    value: function initPinboardEditing() {
      if (this.editablePinboardChart()) {
        var label = I18n.t('sharing.saveChartToPinboard');
        this.$(ADD_TO_PINBOARD_SELECTOR).text(label);
      }
    }
  }, {
    key: "initSubjectModeCheckbox",
    value: function initSubjectModeCheckbox() {
      this.subjectModeCheckbox = this.$(SUBJECT_MODE_CHECKBOX_SELECTOR).prop('checked', this.model.get('subjects').length > 1);
    } // Dropdown initialization
    // -----------------------
    // Creates shortcuts to the Dropdown instances.

  }, {
    key: "initDropdowns",
    value: function initDropdowns() {
      this.singleSubjectDropdown = this.dropdown(SINGLE_SUBJECT_SELECTOR);
      this.multipleSubjectsDropdown = this.dropdown(MULTIPLE_SUBJECT_SELECTOR);
      this.measureDropdown = this.dropdown(MEASURES_SELECTOR);
      this.updateSubjectDropdownVisibility();
    } // Shows/hides the single and multiple subject dropdown
    // according to the subjects configuration.

  }, {
    key: "updateSubjectDropdownVisibility",
    value: function updateSubjectDropdownVisibility() {
      // Do nothing if there is just a single subject dropdown
      if (!this.multipleSubjectsDropdown) {
        return;
      }

      var hasMultipleSubjects = this.hasMultipleSubjects();
      var display = 'display';
      var visible = '';
      var hidden = 'none'; // Apply visibility

      this.$(SINGLE_SUBJECT_SELECTOR).css(display, hasMultipleSubjects ? hidden : visible);
      return this.$(MULTIPLE_SUBJECT_SELECTOR).css(display, hasMultipleSubjects ? visible : hidden);
    } // Syncs single and multiple subjects dropdown values.
    // Copies over the value from the other dropdown.

  }, {
    key: "syncSubjectDropdowns",
    value: function syncSubjectDropdowns() {
      var setOptions = {
        silent: true
      };

      if (this.hasMultipleSubjects()) {
        // single -> multiple
        var subjects = [this.singleSubjectDropdown.value()];
        this.multipleSubjectsDropdown.value(subjects, setOptions);
      } else {
        // multiple -> single
        var _subjects = this.multipleSubjectsDropdown.value();

        if (_subjects.length) {
          this.singleSubjectDropdown.value(_subjects[0], setOptions);
        }
      }
    } // Returns the Dropdown instance for a given selector.

  }, {
    key: "dropdown",
    value: function dropdown(selector) {
      var el = this.$(selector).get(0);

      if (el) {
        return Dropdown.get(el);
      } else {
        return null;
      }
    } // Renders the HighlightedLocationsOverlay subview

  }, {
    key: "renderHighlightedLocationsOverlay",
    value: function renderHighlightedLocationsOverlay() {
      this.highlightedLocationsOverlay = new HighlightedLocationsOverlay({
        // The components element is the .dropdown element so it may access
        // both the .dropdown-button and the .dropdown-overlay.
        el: this.$(HIGHLIGHTED_LOCATIONS_DROPDOWN_SELECTOR),
        model: this.model,
        metadata: this.metadata
      });
      this.highlightedLocationsOverlay.render();
    } // DOM event handlers
    // ------------------
    // Menu buttons
    // ------------

  }, {
    key: "requestFullscreen",
    value: function requestFullscreen(event) {
      event.preventDefault();
      fullscreen.requestFullscreen(this.chartEl);
    }
  }, {
    key: "shareChart",
    value: function shareChart(event) {
      event.preventDefault();
      var view = EmbeddedShareView.create(this.model);

      if (view) {
        $(this.chartEl).after(view.el);
        view.save();
      }
    }
  }, {
    key: "downloadSelection",
    value: function downloadSelection(event) {
      _downloadSelection(this.model, event.target);

      this.closeDownloadDropdown();
      analytics.trackEvent('Indicator CSV', 'Download', this.model.get('indicator'), 1, true);
    }
  }, {
    key: "downloadIndicator",
    value: function downloadIndicator(event) {
      _downloadIndicator(this.model, event.target);

      this.closeDownloadDropdown();
      analytics.trackEvent('Indicator CSV', 'Download', this.model.get('indicator'), 1, true);
    }
  }, {
    key: "closeDownloadDropdown",
    value: function closeDownloadDropdown() {
      var downloadButton = this.$(DOWNLOAD_DROPDOWN_SELECTOR).get(0);
      Dropdown.get(downloadButton).deactivate();
    }
  }, {
    key: "addToPinboard",
    value: function addToPinboard(event) {
      if (!pinboardMediator.isActive()) {
        event.preventDefault();
        window.alert(I18n.t('sharing.pinboardInactive'));
        return;
      }

      var chart = this.editablePinboardChart();

      if (chart) {
        // Update existing chart in edit mode
        pinboardMediator.updateChart(chart, this.model);
        pinboardMediator.leaveEditMode(chart);
      } else {
        // Add new chart to the pinboard
        pinboardMediator.addChart(this.model);
      }
    } // Returns a matching chart model in edit mode from the pinboard
    // or false if there is no match.

  }, {
    key: "editablePinboardChart",
    value: function editablePinboardChart() {
      var chart = pinboardMediator.editableChart(); // Indicators must match

      if (chart && chart.get('indicator') === this.model.get('indicator')) {
        return chart;
      } else {
        return false;
      }
    } // Change handlers for type, ISMF
    // ------------------------------

  }, {
    key: "typeChanged",
    value: function typeChanged(event) {
      if (!this.activateOption(event)) {
        return;
      }

      var type = this.getType();
      var showsMultipleSubjects = CHART_TYPES[type].showsMultipleSubjects;
      var switchToSingle = this.multipleSubjectsDropdown && this.hasMultipleSubjects() && !showsMultipleSubjects;

      if (switchToSingle) {
        // Change from multiple to single subject mode when the chart type
        // does not support multiple subjects
        this.setSubjectMode(false); // This calls loadConfig eventually

        this.switchSubjectMode(false);
      } else {
        this.loadConfig();
      }
    } // Subject mode checkbox change handler

  }, {
    key: "subjectModeChanged",
    value: function subjectModeChanged() {
      this.switchSubjectMode(true);
    } // Single subject dropdown change handler

  }, {
    key: "singleSubjectChanged",
    value: function singleSubjectChanged() {
      this.handleSubjectChange(true);
    } // Multiple subject dropdown change handler

  }, {
    key: "multipleSubjectsChanged",
    value: function multipleSubjectsChanged() {
      this.handleSubjectChange(true);
    } // Reflects the subject mode change (single <> multiple) in the UI

  }, {
    key: "switchSubjectMode",
    value: function switchSubjectMode(updateMeasureAndFrequency) {
      this.updateSubjectDropdownVisibility();
      this.syncSubjectDropdowns();
      this.handleSubjectChange(updateMeasureAndFrequency);
    } // Reflects the subject change in the UI

  }, {
    key: "handleSubjectChange",
    value: function handleSubjectChange(updateMeasureAndFrequency) {
      if (updateMeasureAndFrequency == null) {
        updateMeasureAndFrequency = true;
      }

      if (!this.getSubject()) {
        return;
      }

      if (updateMeasureAndFrequency) {
        // Update dependent controls
        this.updateMeasures();
        this.updateFrequencies();
        this.updateTimePeriods();
      }

      this.loadConfig();
    }
  }, {
    key: "measureChanged",
    value: function measureChanged() {
      // Update dependent controls
      this.updateFrequencies();
      this.updateTimePeriods();
      this.loadConfig();
    }
  }, {
    key: "frequencyChanged",
    value: function frequencyChanged(event) {
      if (this.activateOption(event)) {
        this.updateTimePeriods();
        this.loadConfig();
      }
    }
  }, {
    key: "useLatestDataChanged",
    value: function useLatestDataChanged() {
      this.activateTimePeriodNavigation(!this.getUseLatestData());
      this.loadConfig();
    } // Activates an option in an option list. Expects a click event.
    // Returns a Boolean that indicates whether the operation was successful.

  }, {
    key: "activateOption",
    value: function activateOption(event) {
      event.preventDefault();
      var el = $(event.currentTarget);

      if (!el.hasClass(DISABLED_CLASS)) {
        el.closest('li').addClass(CURRENT_CLASS).siblings().removeClass(CURRENT_CLASS);
        return true;
      } else {
        return false;
      }
    } // Previous/next time period navigation

  }, {
    key: "previousTimePeriod",
    value: function previousTimePeriod(event) {
      event.preventDefault();

      if (this.model.get('useLatestData')) {
        return;
      }

      timePeriodNavigation.back(this.model);
    }
  }, {
    key: "nextTimePeriod",
    value: function nextTimePeriod(event) {
      event.preventDefault();

      if (this.model.get('useLatestData')) {
        return;
      }

      timePeriodNavigation.forward(this.model);
    } // Model event handlers
    // --------------------

  }, {
    key: "modelDataChanged",
    value: function modelDataChanged() {
      if (!this.model.previous('data')) {
        // First rendering
        this.renderTimeSlider();
      } else {
        // Subsequent rendering: Only update the slider value & label
        this.setTimeSliderToActual();
      }
    }
  }, {
    key: "modelTimePeriodsChanged",
    value: function modelTimePeriodsChanged(model, value, options) {
      if (!options.fromChartControl) {
        this.renderTimeSlider();
      }
    } // Fetch new data
    // --------------
    // Reads all controls, sets the model config to fetch new data

  }, {
    key: "loadConfig",
    value: function loadConfig() {
      // At least one subject is needed.
      // Empty subjects are possible but would query *all* subjects.
      var subjects = this.getSubjects();

      if (!subjects.length) {
        return;
      }

      var type = this.getType();
      var measure = this.getMeasure();
      var frequency = this.getFrequency(); // Handle use latest data

      var useLatestData = this.getUseLatestData();
      var endTime, startTime;

      if (useLatestData) {
        // Calculate start time, unset end time
        startTime = latestDataStartTime(frequency);
        endTime = undefined;
      } else {
        // Use slider values
        var _this$getTimeSliderVa = this.getTimeSliderValue();

        startTime = _this$getTimeSliderVa.startTime;
        endTime = _this$getTimeSliderVa.endTime;
      }

      var config = {
        type: type,
        subjects: subjects,
        measure: measure,
        frequency: frequency,
        useLatestData: useLatestData,
        startTime: startTime,
        endTime: endTime
      };
      this.model.set(config, {
        fromChartControl: true
      });
    } // Getters and setters for SMF controls
    // ------------------------------------
    // Subjects
    // --------
    // Gets the selected subjects. Returns an array of subject ids.

  }, {
    key: "getSubjects",
    value: function getSubjects() {
      if (this.hasMultipleSubjects()) {
        return this.multipleSubjectsDropdown.value();
      } else {
        return [this.singleSubjectDropdown.value()];
      }
    } // Sets the subjects, changing the dropdown.
    // Expects an array of subject ids.

  }, {
    key: "setSubjects",
    value: function setSubjects(subjects) {
      var options = {
        silent: true
      };

      if (this.hasMultipleSubjects()) {
        this.multipleSubjectsDropdown.value(subjects, options);
      } else {
        this.singleSubjectDropdown.value(subjects[0], options);
      }
    } // Returns the first subject. Returns a String with a subject id.

  }, {
    key: "getSubject",
    value: function getSubject() {
      return this.getSubjects()[0];
    } // Returns whether multiple subjects are wanted.
    // Returns a Boolean.

  }, {
    key: "hasMultipleSubjects",
    value: function hasMultipleSubjects() {
      // Checkbox might be absent from the DOM
      var left = this.getSubjectMode();
      return left != null ? left : false;
    } // Returns the value of the subject mode checkbox from the DOM.
    // The checkbox might be absent from the DOM.
    // Returns a Boolean or undefined.

  }, {
    key: "getSubjectMode",
    value: function getSubjectMode() {
      return this.subjectModeCheckbox.prop('checked');
    } // Sets the value of the subject mode checkbox.
    // Expects a Boolean: true = multiple, false = single

  }, {
    key: "setSubjectMode",
    value: function setSubjectMode(value) {
      this.subjectModeCheckbox.prop('checked', value);
    } // Measure
    // -------
    // Gets the measure from the dropdown.

  }, {
    key: "getMeasure",
    value: function getMeasure() {
      return this.measureDropdown.value();
    } // Updates the measure dropdown. Does not fire change events.
    // Expects a measure id string.

  }, {
    key: "setMeasure",
    value: function setMeasure(measure) {
      this.measureDropdown.value(measure, {
        silent: true
      });
    } // Frequency
    // ---------
    // Gets the frequency from the segmented control.
    // Does not fire change events.

  }, {
    key: "getFrequency",
    value: function getFrequency() {
      return this.$(CURRENT_FREQUENCY_SELECTOR).data('value');
    } // Sets the frequency in the segmented control.
    // Expects a frequency id string.

  }, {
    key: "setFrequency",
    value: function setFrequency(frequency) {
      this.$(FREQUENCIES_SELECTOR).each(function (index, el) {
        el = $(el);
        var li = el.closest('li');
        li.toggleClass(CURRENT_CLASS, el.data('value') === frequency);
      });
    } // Enables/disables frequencies items.
    // Expects an array of strings that will be enabled.

  }, {
    key: "toggleFrequencies",
    value: function toggleFrequencies(enabledItems) {
      this.$(FREQUENCIES_SELECTOR).each(function (index, el) {
        el = $(el);
        var value = el.data('value');
        return el.toggleClass(DISABLED_CLASS, enabledItems.indexOf(value) === -1);
      });
    } // Use latest data
    // ---------------

  }, {
    key: "getUseLatestData",
    value: function getUseLatestData() {
      return this.$(USE_LATEST_DATA_CHECKBOX_SELECTOR).prop('checked');
    }
  }, {
    key: "setUseLatestData",
    value: function setUseLatestData(useLatestData) {
      this.$(USE_LATEST_DATA_CHECKBOX_SELECTOR).prop('checked', useLatestData);
    } // Apply available combinations
    // ----------------------------
    // Enables/disables the measures according to the available combinations.

  }, {
    key: "updateMeasures",
    value: function updateMeasures() {
      var result = this.availableCombinations.matchingMeasure(this.getSubject(), this.getMeasure());

      if (!result.fulfilled) {
        // Switch to a matching measure
        this.setMeasure(result.match);
      }

      this.measureDropdown.toggleItems(result.matches);
    } // Enables/disables the frequencies according to the available combinations.

  }, {
    key: "updateFrequencies",
    value: function updateFrequencies() {
      var result = this.availableCombinations.matchingFrequency(this.getSubject(), this.getMeasure(), this.getFrequency());

      if (!result.fulfilled) {
        // Switch to a matching frequency
        this.setFrequency(result.match);
      }

      this.toggleFrequencies(result.matches);
    }
  }, {
    key: "updateTimePeriods",
    value: function updateTimePeriods() {
      this.renderTimeSlider();
    } // Chart type selector
    // -------------------
    //
    // There are three tabs for type selection, Chart, Map and Table.
    // The first one maps to several non-map types, see CHART_TYPES_AS_CHART.
    // Updates the type selector from the model.

  }, {
    key: "renderChartTypes",
    value: function renderChartTypes() {
      var data = this.model.get('data');

      if (!data) {
        return;
      }

      var currentType = this.model.get('displayType');

      if (CHART_TYPES_AS_CHART.indexOf(currentType) >= 0) {
        currentType = CHART_TYPE_CHART;
      }

      this.$(TYPE_BUTTON_SELECTOR).each(function (index, a) {
        var $a = $(a);
        var type = $a.data('type');
        return $a.parent().toggleClass(CURRENT_CLASS, type === currentType) // Do not show the map tab if the data has mixed signs
        .toggle(!(type === 'map' && data.properties.mixedSigns));
      });
    } // Returns the current type as string, one of 'line', 'symbol', 'map', 'table'

  }, {
    key: "getType",
    value: function getType() {
      var type = this.$(CURRENT_TYPE_SELECTOR).data('type'); // Translate chart meta-type

      if (type === CHART_TYPE_CHART) {
        if (this.hasMultipleSubjects()) {
          // Force symbol chart, even though there is only one subject
          type = 'symbol';
        } else {
          // Line/bar (auto-switch in ChartView)
          type = 'line';
        }
      }

      return type;
    } // (De-)activates the slider and the prev/next time period controls

  }, {
    key: "activateTimePeriodNavigation",
    value: function activateTimePeriodNavigation(active) {
      this.$("".concat(PREVIOUS_TIME_PERIOD_SELECTOR, " a, ").concat(NEXT_TIME_PERIOD_SELECTOR, " a")).toggleClass(DISABLED_CLASS, !active);

      if (this.timeSliderView) {
        this.timeSliderView.activate(active);
      }
    } // Time slider
    // -----------
    // Creates or updates the time slider

  }, {
    key: "renderTimeSlider",
    value: function renderTimeSlider() {
      if (!this.timeSliderView) {
        this.timeSliderView = new TimeSliderView({
          model: this.model,
          el: this.$(TIME_SLIDER_INNER_SELECTOR),
          $currentTimePeriod: this.$(CURRENT_TIME_PERIOD_SELECTOR),
          availableCombinations: this.availableCombinations,
          onChange: this.timeSliderChanged
        });
      }

      this.timeSliderView.render({
        frequency: this.getFrequency()
      });
      this.timeSliderView.activate(!this.getUseLatestData());
    }
  }, {
    key: "timeSliderChanged",
    value: function timeSliderChanged() {
      var _this$getTimeSliderVa2 = this.getTimeSliderValue(),
          startTime = _this$getTimeSliderVa2.startTime,
          endTime = _this$getTimeSliderVa2.endTime; // Change from multiple to single subject mode
      // when the user selected different time periods


      var switchToSingle = this.multipleSubjectsDropdown && this.hasMultipleSubjects() && startTime !== endTime;

      if (switchToSingle) {
        this.setSubjectMode(false); // This calls loadConfig eventually

        this.switchSubjectMode(false);
      } else {
        this.loadConfig();
      }
    }
  }, {
    key: "getTimeSliderValue",
    value: function getTimeSliderValue() {
      return this.timeSliderView.getValue();
    }
  }, {
    key: "setTimeSliderToActual",
    value: function setTimeSliderToActual() {
      this.timeSliderView.setValueToActual();
    }
  }]);
  return ChartControl;
}(BaseView);

ChartControl.prototype.boundMethods = ['applyMetadata', 'requestFullscreen', 'shareChart', 'downloadSelection', 'downloadIndicator', 'addToPinboard', 'typeChanged', 'subjectModeChanged', 'singleSubjectChanged', 'multipleSubjectsChanged', 'handleSubjectChange', 'measureChanged', 'frequencyChanged', 'useLatestDataChanged', 'previousTimePeriod', 'nextTimePeriod', 'loadConfig', 'renderChartTypes', 'activateTimePeriodNavigation', 'timeSliderChanged'];
module.exports = ChartControl;

},{"../constants/chart-types":70,"../i18n":82,"../models/available-combinations":85,"../models/indicator-metadata":101,"../models/pinboard-mediator":102,"../models/time-period-navigation":114,"../util/analytics":116,"../util/download":125,"../util/fullscreen":126,"../util/latest-data-start-time":128,"./base-view":150,"./dropdown":162,"./embedded-share-view":163,"./highlighted-locations-overlay":164,"./time-slider-view":175,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery","lodash":"lodash"}],153:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ChartSupplementView = require('./chart-supplement-view');

var ChartFooterView = /*#__PURE__*/function (_ChartSupplementView) {
  (0, _inherits2.default)(ChartFooterView, _ChartSupplementView);

  var _super = _createSuper(ChartFooterView);

  function ChartFooterView() {
    var _this;

    (0, _classCallCheck2.default)(this, ChartFooterView);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.registerDOMHandlers();

    return _this;
  }

  return ChartFooterView;
}(ChartSupplementView);

module.exports = ChartFooterView;

},{"./chart-supplement-view":155,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],154:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var $ = require('jquery');

var domUtil = require('../util/dom');

var createTemplate = require('../util/create-template');

var urlUtil = require('../util/url');

var fullscreen = require('../util/fullscreen');

var _require = require('../util/download'),
    _downloadIndicator = _require.downloadIndicator,
    _downloadSelection = _require.downloadSelection;

var I18n = require('../i18n');

var Configuration = require('../configuration');

var ChartSupplementView = require('./chart-supplement-view');

var EmbeddedShareView = require('./embedded-share-view');

var Dropdown = require('./dropdown');
/** @typedef {import('../types/types').ChartTitleAttributes} ChartTitleAttributes */
// Constants
// ---------
// The state names are used for class names


var IDLE_STATE = 'idle';
var LOADING_STATE = 'loading';
var ERROR_STATE = 'error';
var SUCCESS_STATE = 'success';
var STATES = [IDLE_STATE, LOADING_STATE, ERROR_STATE, SUCCESS_STATE];
var SHARE_BUTTON_SELECTOR = '.share-btn';
var FULLSCREEN_BUTTON_SELECTOR = '.fullscreen-btn';
var DOWNLOAD_DROPDOWN_SELECTOR = '.download-dropdown';
var DOWNLOAD_SELECTION_SELECTOR = '.download-selection-button';
var DOWNLOAD_INDICATOR_SELECTOR = '.download-indicator-button';
var SWITCH_TO_TABLE_SELECTOR = '.chart-switch-to-table'; // Templates
// ---------

var headerTemplate = createTemplate("<div class=\"chart-header\">\n  <div class=\"chart-title-and-subtitle\">\n    <h2 class=\"chart-title\">\n      <a class=\"chart-title-link chart-open-referrer\"></a>\n    </h2>\n    <div class=\"chart-subtitle\"></div>\n  </div>\n  <ul class=\"chart-byline\">\n    <li class=\"chart-byline-clickable info-tooltip info-tooltip-right\" tabindex=\"0\">\n      <i class=\"icon-ddp-info\"></i>\n      <p class=\"info-tooltip-content\"></p>\n    </li>\n    <li>\n      <a href=\"\" class=\"chart-byline-clickable fullscreen-btn\"\n        title=\"{{#t}}chartHeader.fullscreen{{/t}}\">\n        <i class=\"icon-ddp-fullscreen\"></i>\n        <span class=\"btn-label\">{{#t}}chartHeader.fullscreen{{/t}}</span>\n      </a>\n    </li>\n    <li>\n      <div class=\"dropdown download-dropdown\">\n        <a href=\"\"\n          class=\"chart-byline-clickable dropdown-button download-btn\"\n          title=\"{{#t}}chartHeader.download{{/t}}\">\n          <i class=\"icon-ddp-download\"></i>\n          <span class=\"btn-label\">{{#t}}chartHeader.download{{/t}}</span>\n        </a>\n        <div class=\"dropdown-overlay download-dropdown-overlay\">\n          <ul>\n            <li>\n              <!-- The href is filled by JavaScript -->\n              <a href=\"\" class=\"download-dropdown-option download-selection-button\" download>\n                {{#t}}chartHeader.downloadSelected{{/t}}\n              </a>\n            </li>\n            <li>\n              <!-- The href is filled by JavaScript -->\n              <a href=\"\" class=\"download-dropdown-option download-indicator-button\" download>\n               {{#t}}chartHeader.downloadFull{{/t}}\n              </a>\n            </li>\n          </ul>\n        </div><!-- /dropdown-list -->\n      </div><!-- /dropdown -->\n    </li>\n    <li>\n      <a href=\"\" class=\"chart-byline-clickable share-btn\"\n        title=\"{{#t}}chartHeader.share{{/t}}\">\n        <i class=\"icon-ddp-share\"></i>\n        <span class=\"btn-label\">{{#t}}chartHeader.share{{/t}}</span>\n      </a>\n    </li>\n  </ul>\n  <p class=\"chart-accessibility-notice\">\n    {{#t}}chartHeader.accessibilityNotice{{/t}}\n    <a href=\"\" class=\"chart-switch-to-table\">\n      {{#t}}chartHeader.switchToTable{{/t}}\n    </a>\n  </p>\n</div>");
var loadingTemplate = createTemplate("<i class=\"icon-ddp-loading icon-spin chart-header-loading-icon\"></i>\n<span class=\"chart-header-loading-label\">\n  {{#t}}chartHeader.loading{{/t}}\n</span>");
var subtitleTemplate = createTemplate("<span class=\"chart-subtitle-subjects\">{{subjects}},</span>\n<span class=\"chart-subtitle-measure\">{{measure}},</span>\n<span class=\"chart-subtitle-time\">{{time}}</span>\n<span class=\"chart-subtitle-short-time\">{{shortTime}}</span>");
var tooltipTemplate = createTemplate("<ul>\n  <li>{{title}}</li>\n  <li>{{subjects}}</li>\n  <li>{{measure}}</li>\n  <li>{{time}}</li>\n  {{#sourceWithPrefix}}\n    <li>{{sourceWithPrefix}}</li>\n  {{/sourceWithPrefix}}\n</ul>");

var ChartHeaderView = /*#__PURE__*/function (_ChartSupplementView) {
  (0, _inherits2.default)(ChartHeaderView, _ChartSupplementView);

  var _super = _createSuper(ChartHeaderView);

  // Property declarations
  // ---------------------
  //
  // chartEl: Element
  // currentState: String

  /**
   * @param {import('./base-view').BaseViewOptions & { chartEl: HTMLElement }} options
   */
  function ChartHeaderView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, ChartHeaderView);
    _this = _super.call(this, options);
    _this.chartEl = options.chartEl;
    /** @type {string} */

    _this.currentState;

    _this.setEl(options.el || _this.createElement());

    _this.registerDOMHandlers();

    _this.registerModelHandlers();

    _this.initDropdowns();

    _this.enterState(IDLE_STATE);

    return _this;
  }

  (0, _createClass2.default)(ChartHeaderView, [{
    key: "initDropdowns",
    value: function initDropdowns() {
      var downloadDropdown = this.$(DOWNLOAD_DROPDOWN_SELECTOR).get(0);

      if (downloadDropdown) {
        new Dropdown({
          el: downloadDropdown
        });
      }
    } // Returns a new element from the template

  }, {
    key: "createElement",
    value: function createElement() {
      var html = headerTemplate.render();
      return $.parseHTML(html)[0];
    } // State management
    // ----------------

    /**
     * Sets the corresponding state class and removes all others
     *
     * @param {string} state - The new state.
     */

  }, {
    key: "enterState",
    value: function enterState(state) {
      if (state === this.currentState) {
        return;
      }

      this.currentState = state;

      var className = function className(stateForClassName) {
        return "chart-header-".concat(stateForClassName);
      };

      for (var i = 0, l = STATES.length; i < l; i++) {
        var otherState = STATES[i];

        if (otherState !== state) {
          this.$el.removeClass(className(otherState));
        }
      }

      this.$el.addClass(className(state));
    } // DOM event handling
    // ------------------

  }, {
    key: "registerDOMHandlers",
    value: function registerDOMHandlers() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ChartHeaderView.prototype), "registerDOMHandlers", this).call(this);
      this.$(SHARE_BUTTON_SELECTOR).click(this.shareChart);
      this.$(FULLSCREEN_BUTTON_SELECTOR).click(this.toggleFullscreen);
      this.$(DOWNLOAD_SELECTION_SELECTOR).click(this.downloadSelection);
      this.$(DOWNLOAD_INDICATOR_SELECTOR).click(this.downloadIndicator);
      this.$(SWITCH_TO_TABLE_SELECTOR).click(this.switchToTable);
    } // Model event handling
    // --------------------

  }, {
    key: "registerModelHandlers",
    value: function registerModelHandlers() {
      var events = [['config:invalid', this.invalidConfig], ['fetch:start', this.fetchStart], ['fetch:error', this.fetchError], ['fetch:success', this.fetchSuccess], ['change:displayType', this.displayTypeChanged]];

      for (var i = 0, l = events.length; i < l; i++) {
        var event = events[i];
        this.model.on(event[0], event[1], this);
      }
    }
  }, {
    key: "invalidConfig",
    value: function invalidConfig() {
      this.enterState(ERROR_STATE);
      this.renderConfigError();
    }
  }, {
    key: "fetchStart",
    value: function fetchStart() {
      this.enterState(LOADING_STATE);
      this.renderLoadingHeader();
    }
  }, {
    key: "fetchError",
    value: function fetchError() {
      this.enterState(ERROR_STATE);
      this.renderDataError();
    }
  }, {
    key: "fetchSuccess",
    value: function fetchSuccess() {
      this.enterState(SUCCESS_STATE);
      this.renderDataDescription();
    } // this.model.titleAttributes() uses the displayType
    // for the correct time range.
    // But displayType is not set on fetch:success.
    // So update the description on change:displayType.

  }, {
    key: "displayTypeChanged",
    value: function displayTypeChanged() {
      this.renderAccessibilityNotice();
      this.renderDataDescription();
    } // Button event handlers
    // ---------------------

  }, {
    key: "shareChart",
    value: function shareChart(event) {
      var _this2 = this;

      event.preventDefault(); // Leave fullscreen since we cant show the sharing dialog
      // in fullscreen mode

      fullscreen.exitFullscreen(); // Try to create an embedded share view

      var view = EmbeddedShareView.create(this.model);

      if (view) {
        var fulfilled = function fulfilled() {
          view = EmbeddedShareView.create(_this2.model);
          $(_this2.chartEl).after(view.el);
        };

        this.model.save().then(fulfilled);
      } else {
        // Open the standalone share view. First open popup window synchronously
        // to bypass the popup blocker, then fill it with the final URL.
        var shareWindow = window.open('about:blank', '_blank');

        var _fulfilled = function _fulfilled(data) {
          // Change the popup URL when the data is loaded
          shareWindow.location.href = _this2.externalSharingURL(data.id);
        };

        var rejected = function rejected() {
          // Close the window on error
          shareWindow.close();
        };

        this.model.save().then(_fulfilled, rejected);
      }
    } // Returns the URL for the standalone share view.
    // Passes the id and title to the external page

  }, {
    key: "externalSharingURL",
    value: function externalSharingURL(id) {
      return urlUtil.addCurrentProtocol(Configuration.get('chartSaving').externalSharingURL + '?id=' + encodeURIComponent(id) + '&title=' + encodeURIComponent(this.model.title()));
    }
  }, {
    key: "toggleFullscreen",
    value: function toggleFullscreen(event) {
      event.preventDefault();
      fullscreen.toggleFullscreen(this.chartEl);
    }
    /**
     * @param {Event} event
     */

  }, {
    key: "downloadSelection",
    value: function downloadSelection(event) {
      _downloadSelection(this.model, event.target);

      this.closeDownloadDropdown();
    }
    /**
     * @param {Event} event
     */

  }, {
    key: "downloadIndicator",
    value: function downloadIndicator(event) {
      _downloadIndicator(this.model, event.target);

      this.closeDownloadDropdown();
    }
  }, {
    key: "closeDownloadDropdown",
    value: function closeDownloadDropdown() {
      var downloadDropdown = this.$(DOWNLOAD_DROPDOWN_SELECTOR).get(0);
      Dropdown.get(downloadDropdown).deactivate();
    }
  }, {
    key: "switchToTable",
    value: function switchToTable(event) {
      event.preventDefault();
      this.model.set('type', 'table');
    } // Rendering
    // ---------

  }, {
    key: "renderConfigError",
    value: function renderConfigError() {
      this.showOnlyHeaderTitle(I18n.t('chartHeader.configError'));
    } // Shows a loading indicator, hides the other title parts.

  }, {
    key: "renderLoadingHeader",
    value: function renderLoadingHeader() {
      this.renderTitleText('');
      this.$('.chart-subtitle').html(loadingTemplate.render());
      this.$('.info-tooltip-content').text(I18n.t('chartHeader.loading'));
    }
  }, {
    key: "renderDataError",
    value: function renderDataError() {
      this.showOnlyHeaderTitle(I18n.t('chartHeader.dataError'));
    }
  }, {
    key: "showOnlyHeaderTitle",
    value: function showOnlyHeaderTitle(title) {
      this.renderTitleText(title);
      this.$('.chart-subtitle, .info-tooltip-content').text('');
    } // Fill the header with the description from the data

  }, {
    key: "renderDataDescription",
    value: function renderDataDescription() {
      var titleAttributes = this.model.titleAttributes(); // Use custom title or indicator name + single location

      var title = titleAttributes.title ? titleAttributes.title : _.compact([titleAttributes.indicator, titleAttributes.singleLocation]).join(', ');
      this.renderTitleText(title);
      this.renderSubtitle(titleAttributes);
      this.renderTooltip(title, titleAttributes);
    }
  }, {
    key: "renderAccessibilityNotice",
    value: function renderAccessibilityNotice() {
      var displayType = this.model.get('displayType');
      this.$('.chart-accessibility-notice').css('display', displayType === 'table' ? 'none' : 'block');
    }
    /**
     * @param {ChartTitleAttributes} attributes
     */

  }, {
    key: "renderSubtitle",
    value: function renderSubtitle(attributes) {
      var $subtitle = this.$('.chart-subtitle');
      var subtitle = attributes.subtitle; // Render custom subtitle or template

      if (subtitle) {
        $subtitle.text(subtitle);
      } else {
        $subtitle.html(subtitleTemplate.render(attributes));
      }
    }
    /**
     * @param {string} title
     * @param {ChartTitleAttributes} attributes
     */

  }, {
    key: "renderTooltip",
    value: function renderTooltip(title, attributes) {
      var attributesWithTitle = _.clone(attributes);

      attributesWithTitle.title = title;
      this.$('.info-tooltip-content').html(tooltipTemplate.render(attributesWithTitle));
    }
    /**
     * @param {string} title
     */

  }, {
    key: "renderTitleText",
    value: function renderTitleText(title) {
      var linkEl = this.$('.chart-title-link');

      if (linkEl.length) {
        // Fill the link
        linkEl.text(title).attr('title', title); // Set link URL

        var referrer = this.referrer();

        if (referrer) {
          linkEl.attr('href', referrer);
        }
      } else {
        // No link present, fill the span element
        this.$('.chart-title').text(title).attr('title', title);
      }
    } // Returns the height of the chart header.

  }, {
    key: "height",
    value: function height() {
      var el = this.el; // Detect accessible-hide techniques.

      if (getComputedStyle(el).clip !== 'auto') {
        return 0;
      } else {
        return domUtil.outerSize(el).height;
      }
    }
  }]);
  return ChartHeaderView;
}(ChartSupplementView);

ChartHeaderView.prototype.boundMethods = ['shareChart', 'toggleFullscreen', 'downloadSelection', 'downloadIndicator', 'switchToTable'];
module.exports = ChartHeaderView;

},{"../configuration":67,"../i18n":82,"../util/create-template":121,"../util/dom":124,"../util/download":125,"../util/fullscreen":126,"../util/url":143,"./chart-supplement-view":155,"./dropdown":162,"./embedded-share-view":163,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery","lodash":"lodash"}],155:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BaseView = require('./base-view');

var SelectionMediator = require('../models/selection-mediator'); // Base class for views that are associated but external to a ChartView
// (e.g. headers, footers)


var ChartSupplementView = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(ChartSupplementView, _BaseView);

  var _super = _createSuper(ChartSupplementView);

  /**
   * @param {import('./base-view').BaseViewOptions & { chartEl: HTMLElement }} options
   */
  function ChartSupplementView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, ChartSupplementView);
    _this = _super.call(this, options);
    /** @type {import('../models/chart-data')} */

    _this.model;
    _this.chartEl = options.chartEl; // Child constructor needs to call registerDOMHandlers at the right position

    return _this;
  }

  (0, _createClass2.default)(ChartSupplementView, [{
    key: "registerDOMHandlers",
    value: function registerDOMHandlers() {
      this.$('.chart-open-referrer').click(this.openReferrer);
    } // Returns the referrer URL with context for jumping back to the Data Portal.

  }, {
    key: "referrer",
    value: function referrer() {
      var referrer = this.model.get('referrer') || '';
      var context = this.model.get('context');

      if (referrer && context) {
        referrer += referrer.indexOf('?') >= 0 ? '&' : '?';
        referrer += "context=".concat(context);
      }

      return referrer;
    }
  }, {
    key: "openReferrer",
    value: function openReferrer(event) {
      var referrer = this.referrer();

      if (!referrer) {
        return;
      }

      event.preventDefault(); // User selection carry over: Manually store the model config

      SelectionMediator.update(this.model.get('storedConfiguration'), this.model.attributes, false); // If the chart is embedded, open the link in a new tab

      if (window !== top) {
        window.open(referrer, '_blank');
      } else {
        location.href = referrer;
      }
    }
  }]);
  return ChartSupplementView;
}(BaseView);

ChartSupplementView.prototype.boundMethods = ['openReferrer'];
module.exports = ChartSupplementView;

},{"../models/selection-mediator":112,"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],156:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var $ = require('jquery');

var ASPECT_RATIO = require('../constants/aspect-ratio');

var domUtil = require('../util/dom');

var createTemplate = require('../util/create-template');

var support = require('../util/support');

var fullscreen = require('../util/fullscreen');

var displayType = require('../util/display-type');

var BaseView = require('./base-view');

var ChartHeaderView = require('./chart-header-view');

var ChartComponent = require('./chart-component');

var chartMode = require('../charts/chart-mode'); // The ChartView governs a ChartComponent and a ChartHeaderView.
// It determines the correct chart mode, displayed type and
// sets the corresponding HTML class.
// It renders the chart initially and re-renders the chart on resize.


var LOADING_CLASS = 'ddp-chart-loading';
var supportNoticeTemplate = createTemplate('<p>{{#t}}chart.outdatedBrowser{{/t}}</p>');
/**
 * @typedef
 */

var ChartView = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(ChartView, _BaseView);

  var _super = _createSuper(ChartView);

  // Property declarations
  // ---------------------
  //
  // model: ChartData
  // el: Element
  // $el: jQuery
  // header: ChartHeaderView
  // chartComponent: ChartComponent
  // forceSizeChange: Boolean

  /**
   * @param {import('./base-view').BaseViewOptions & { header?: boolean }} options
   */
  function ChartView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, ChartView);
    _this = _super.call(this, options);
    /** @type {import('../models/chart-data')} */

    _this.model;

    if (!_this.supported()) {
      _this.showSupportNotice();

      return (0, _possibleConstructorReturn2.default)(_this);
    } // Create a dependent header view


    if (options.header !== false) {
      _this.header = new ChartHeaderView({
        model: _this.model,
        chartEl: _this.el
      });

      _this.attachHeader();
    } // Create the chart component


    _this.chartComponent = new ChartComponent({
      el: _this.el,
      model: _this.model
    });

    _this.createPublicInterface();

    _this.model.on('fetch:start', _this.handleFetchStart, (0, _assertThisInitialized2.default)(_this)); // Render the chart when the model has fetched new data


    _this.model.on('fetch:success', _this.handleFetchSuccess, (0, _assertThisInitialized2.default)(_this));

    _this.model.on('fetch:error', _this.handleFetchError, (0, _assertThisInitialized2.default)(_this)); // Re-render on resize and enter/leave fullscreen


    _this.handleResize = _.debounce(_this.handleResize, 250);
    $(window).resize(_this.handleResize);
    fullscreen.onChange(_this.handleResize);
    return _this;
  } // Public Chart Interface
  // ----------------------
  // The only public interface exposed by the application is that installed on
  // chart container elements, which allows to get and update the configuration
  // of the chart.


  (0, _createClass2.default)(ChartView, [{
    key: "createPublicInterface",
    value: function createPublicInterface() {
      var _this2 = this;

      this.el.chart = {
        getConfig: function getConfig() {
          return _this2.model.config();
        },
        loadConfig: function loadConfig(config) {
          // The model.config() resets all size attributes.
          // We need to process the size again.
          _this2.forceSizeChange = true;

          _this2.model.config(config || {});

          return _this2;
        }
      };
    } // Browser support
    // ---------------

  }, {
    key: "supported",
    value: function supported() {
      return support.chartsSupported;
    }
  }, {
    key: "showSupportNotice",
    value: function showSupportNotice() {
      this.$el.append(supportNoticeTemplate.render());
    } // Rendering
    // ---------

    /**
     * Renders the chart. The width and height are cached.
     * Pass true to invalidate the cache and to process the size again.
     *
     * @param {boolean?} forceSizeChange
     */

  }, {
    key: "render",
    value: function render() {
      var forceSizeChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (forceSizeChange || this.forceSizeChange) {
        var _this$containerSize = this.containerSize(),
            width = _this$containerSize.width,
            height = _this$containerSize.height,
            rawWidth = _this$containerSize.rawWidth,
            rawHeight = _this$containerSize.rawHeight;

        this.processSize(width, height, rawWidth, rawHeight);
        this.forceSizeChange = false;
      } else {
        // The type might have changed. Update the display type.
        this.setDisplayType(this.model.get('width'), this.model.get('height'));
      }

      return this.chartComponent.render(this.model.get('data'));
    }
  }, {
    key: "handleFetchStart",
    value: function handleFetchStart() {
      this.$el.addClass(LOADING_CLASS);
    }
  }, {
    key: "handleFetchSuccess",
    value: function handleFetchSuccess() {
      this.$el.removeClass(LOADING_CLASS);
      this.render();
    }
  }, {
    key: "handleFetchError",
    value: function handleFetchError() {
      this.$el.removeClass(LOADING_CLASS);
    }
  }, {
    key: "handleResize",
    value: function handleResize() {
      var data = this.model.get('data'); // Do not render without data. This can happen when a resize triggers
      // a render while the data is loading.

      if (!data) {
        return;
      } // Get current container size and compare with the previous


      var _this$containerSize2 = this.containerSize(),
          width = _this$containerSize2.width,
          height = _this$containerSize2.height,
          rawWidth = _this$containerSize2.rawWidth,
          rawHeight = _this$containerSize2.rawHeight;

      var containerRawWidth = this.model.get('containerRawWidth');
      var containerRawHeight = this.model.get('containerRawHeight');

      if (rawWidth !== containerRawWidth || rawHeight !== containerRawHeight) {
        this.processSize(width, height, rawWidth, rawHeight);
        this.chartComponent.render(data);
      }
    }
    /**
     * Sets model attributes that depend on the size
     * (displayType, mode, width, height, rawWidth, rawHeight,
     * containerWidth, containerHeight) and sets mode classes.
     *
     * @param {number} width
     * @param {number} height
     * @param {number} rawWidth
     * @param {number} rawHeight
     */

  }, {
    key: "processSize",
    value: function processSize(width, height, rawWidth, rawHeight) {
      // Calculate height
      // ----------------
      var finalRawHeight = rawHeight;
      var finalHeight = height;
      var heightWasCalculated = false; // If there is no height set or the height is too narrow,
      // calculate it using the standard aspect ratio.

      if (height <= 2) {
        finalRawHeight = rawWidth / ASPECT_RATIO;
        finalHeight = Math.ceil(finalRawHeight);
        heightWasCalculated = true;
      } // Set model attributes that depend on the container size.


      this.setDisplayType(width, finalHeight);
      this.setMode(width, finalHeight); // Header and net height
      // ---------------------

      var netHeight = finalHeight;
      var netRawHeight = finalRawHeight;
      var header = this.header;

      if (header) {
        // Attach header to get its height.
        // This affects the visibility and size of the header.
        this.setCompactHeaderClass();
        this.attachHeader(); // Calculate the net chart height (container minus header)
        // Subtract the header height from the calculated height
        // if the height was not calculated.

        if (!heightWasCalculated) {
          // This forces an immediate render
          var headerHeight = domUtil.outerSize(header.el).height; // If the header has a height of 1, its hidden using %accessible-hide.
          // See _accessible-hide.sass.

          if (headerHeight > 1) {
            netHeight -= headerHeight;
            netRawHeight -= headerHeight;
          }
        }
      } // Save the size in the model


      this.model.set({
        width: width,
        height: netHeight,
        rawWidth: rawWidth,
        rawHeight: netRawHeight,
        containerRawWidth: rawWidth,
        containerRawHeight: rawHeight
      });
    } // Attaches the header to the DOM.

  }, {
    key: "attachHeader",
    value: function attachHeader() {
      var _this$header = this.header,
          el = _this$header.el,
          $el = _this$header.$el;

      if (el.parentNode !== this.el) {
        $el.prependTo(this.el);
      }
    } // Sizes and modes
    // ---------------
    // Returns the container size as
    // {width: Number (Integer), height: Number (Integer),
    // rawWidth: Number (Float), rawHeight: Number (Float)}

  }, {
    key: "containerSize",
    value: function containerSize() {
      // Hide the children in order to get the intrinsic container size
      var header = this.header;

      if (header) {
        header.$el.css('display', 'none');
      }

      var innerChart = this.$('.ddp-chart-inner');
      innerChart.css('display', 'none'); // Read sub-pixel size as floats

      var size = domUtil.innerSize(this.el); // Reset the childrens visibility

      if (header) {
        header.$el.css('display', '');
      }

      innerChart.css('display', '');
      return {
        // Raw sub-pixel size
        rawWidth: size.width,
        rawHeight: size.height,
        // Round down so floats do not drop.
        width: Math.floor(size.width),
        height: Math.floor(size.height)
      };
    } // Determines the chart mode, saves it to the model and sets the appropriate
    // class on the container element.

  }, {
    key: "setMode",
    value: function setMode(width, height) {
      var mode = chartMode.get(width, height);
      this.model.set({
        mode: mode
      });
      chartMode.setClass(this.$el, mode);
    } // Sets the compact header class according to the configuration.

  }, {
    key: "setCompactHeaderClass",
    value: function setCompactHeaderClass() {
      var allowCompactHeader = this.model.get('compactHeader'); // Do not allow a compact header in multiple line charts

      if (this.model.get('displayType') === 'multipleLine') {
        allowCompactHeader = false;
      }

      this.$el.toggleClass('compact-header', allowCompactHeader);
    } // Sets displayType and updates mode if necessary.

  }, {
    key: "setDisplayType",
    value: function setDisplayType(width, height) {
      this.model.set('displayType', displayType(this.model, width, height));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      $(window).off('resize', this.handleResize);
      fullscreen.offChange(this.handleResize);

      if (this.header) {
        this.header.dispose();
      }

      this.chartComponent.dispose();
      (0, _get2.default)((0, _getPrototypeOf2.default)(ChartView.prototype), "dispose", this).call(this);
    }
  }]);
  return ChartView;
}(BaseView);

ChartView.prototype.boundMethods = ['handleResize']; // Flag that indicates whether the container size needs to be read
// and the model attributes need to be updated.

ChartView.prototype.forceSizeChange = true; // Disposal
// --------

ChartView.prototype.disposedProperties = ['header', 'chartComponent'];
module.exports = ChartView;

},{"../charts/chart-mode":45,"../constants/aspect-ratio":68,"../util/create-template":121,"../util/display-type":122,"../util/dom":124,"../util/fullscreen":126,"../util/support":140,"./base-view":150,"./chart-component":151,"./chart-header-view":154,"@babel/runtime/helpers/assertThisInitialized":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery","lodash":"lodash"}],157:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var I18n = require('../i18n');

var BaseView = require('./base-view');

var CitationView = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(CitationView, _BaseView);

  var _super = _createSuper(CitationView);

  function CitationView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, CitationView);
    _this = _super.call(this, options);

    _this.render();

    return _this;
  }

  (0, _createClass2.default)(CitationView, [{
    key: "render",
    value: function render() {
      this.textarea = this.$('textarea');
      this.textarea.click(this.selectText);
      this.addAccessDate();
      return this.adjustHeight();
    }
  }, {
    key: "selectText",
    value: function selectText() {
      this.textarea.select();
    }
  }, {
    key: "addAccessDate",
    value: function addAccessDate() {
      var formatter = I18n.d3Locale.timeFormat(I18n.t('general.dateLong'));
      var date = formatter(new Date());
      var val = this.textarea.val();
      var addition = " (".concat(I18n.t('citation.accessedOn'), " ").concat(date, ")");

      if (val.indexOf(addition) === -1) {
        val += " (".concat(I18n.t('citation.accessedOn'), " ").concat(date, ")");
        this.textarea.val(val);
      }
    }
  }, {
    key: "adjustHeight",
    value: function adjustHeight() {
      this.textarea.css('overflow', 'hidden');
      var scrollHeight = this.textarea.prop('scrollHeight');

      if (!scrollHeight) {
        this.textarea.css('overflow', '');
        return;
      }

      var paddingTop = parseInt(this.textarea.css('padding-top'), 10);
      var paddingBottom = parseInt(this.textarea.css('padding-bottom'), 10);
      var height = scrollHeight - paddingTop - paddingBottom;

      if (height > 0) {
        this.textarea.height(height);
      }
    }
  }]);
  return CitationView;
}(BaseView);

CitationView.prototype.boundMethods = ['selectText'];
module.exports = CitationView;

},{"../i18n":82,"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],158:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Configuration = require('../configuration');

var createTemplate = require('../util/create-template');

var urlUtil = require('../util/url');

var I18n = require('../i18n');

var ShareView = require('./share-view');

var CountryDashboardShareView = /*#__PURE__*/function (_ShareView) {
  (0, _inherits2.default)(CountryDashboardShareView, _ShareView);

  var _super = _createSuper(CountryDashboardShareView);

  function CountryDashboardShareView() {
    (0, _classCallCheck2.default)(this, CountryDashboardShareView);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(CountryDashboardShareView, [{
    key: "renderTitle",
    value: function renderTitle() {
      this.$('.share-selection-title').text(this.prefixedTitle());
    } // Methods that return prepared chart information
    // ----------------------------------------------

  }, {
    key: "titlePrefix",
    value: function titlePrefix() {
      return I18n.t('sharing.countryDashboardPrefix');
    }
  }, {
    key: "title",
    value: function title() {
      return this.model.get('name');
    } // URL and embed code generation
    // -----------------------------

  }, {
    key: "url",
    value: function url() {
      var template = createTemplate(Configuration.get('countryDashboard').embedURL);
      var url = template.render({
        id: this.model.id,
        locale: this.model.get('locale')
      });
      url = urlUtil.addCurrentProtocol(url);
      return url;
    }
  }]);
  return CountryDashboardShareView;
}(ShareView); // Manually inherit static properties since Babel cannot do this in IE


CountryDashboardShareView.create = ShareView.create;
CountryDashboardShareView.selector = ShareView.selector; // Iframe parameters

CountryDashboardShareView.prototype.iframeFallbackWidth = 858;
CountryDashboardShareView.prototype.iframeAspectRatio = 10 / 16;
module.exports = CountryDashboardShareView;

},{"../configuration":67,"../i18n":82,"../util/create-template":121,"../util/url":143,"./share-view":172,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],159:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var $ = require('jquery');

var Configuration = require('../configuration');

var BaseView = require('./base-view');

var CountryDashboardShareView = require('./country-dashboard-share-view');

var urlUtil = require('../util/url');

var CountryDashboardView = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(CountryDashboardView, _BaseView);

  var _super = _createSuper(CountryDashboardView);

  function CountryDashboardView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, CountryDashboardView);
    _this = _super.call(this, options);

    _this.$el.on('click', '.share', _this.share);

    return _this;
  }

  (0, _createClass2.default)(CountryDashboardView, [{
    key: "share",
    value: function share(event) {
      event.preventDefault();
      var view = CountryDashboardShareView.create(this.model);

      if (view) {
        // Share view as overlay
        this.$el.after(view.el);
      } else {
        // Share view as external page (standalone share view)
        // Currently https://data.oecd.org/country-dashboard/
        var url = urlUtil.addCurrentProtocol(Configuration.get('countryDashboard').externalSharingURL + '?' + $.param(this.model.attributes));
        window.open(url, '_blank');
      }
    }
  }]);
  return CountryDashboardView;
}(BaseView);

CountryDashboardView.prototype.boundMethods = ['share'];
module.exports = CountryDashboardView;

},{"../configuration":67,"../util/url":143,"./base-view":150,"./country-dashboard-share-view":158,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery"}],160:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var $ = require('jquery');

var _ = require('lodash');

var objectUtil = require('../util/object');

var createTemplate = require('../util/create-template');

var BaseView = require('./base-view');

var AvailableData = require('../models/available-data');

var CHART_TYPES = [{
  id: 'line',
  name: 'Line'
}, {
  id: 'lineMultipleSubjects',
  name: 'Line, multiple subjects'
}, {
  id: 'bar',
  name: 'Bar'
}, {
  id: 'clusteredBar',
  name: 'Clustered bar'
}, {
  id: 'barPoint',
  name: 'Bar and point'
}, {
  id: 'stackedBar',
  name: 'Stacked bar'
}, {
  id: 'map',
  name: 'Map'
}, {
  id: 'table',
  name: 'Table'
}];

var selectList = function selectList(list) {
  return _.map(list, function (obj, id) {
    return {
      id: id,
      name: obj.name
    };
  });
};

var DevChartControl = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(DevChartControl, _BaseView);

  var _super = _createSuper(DevChartControl);

  function DevChartControl() {
    (0, _classCallCheck2.default)(this, DevChartControl);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(DevChartControl, [{
    key: "render",
    value: // Property declarations
    // ---------------------
    //
    // data: Object
    //   The possible indicator/subject/measure/frequency combinations
    function render() {
      this.typeSelect = this.$('.type-select');
      this.indicatorSelect = this.$('.indicator-select');
      this.subjectSelect = this.$('.subject-select');
      this.measureSelect = this.$('.measure-select');
      this.frequencySelect = this.$('.frequency-select');
      this.registerDOMHandlers();
      this.loadAvailableData().then(this.fill);
    }
  }, {
    key: "registerDOMHandlers",
    value: function registerDOMHandlers() {
      this.indicatorSelect.change(this.indicatorChanged);
      this.subjectSelect.change(this.subjectChanged);
      this.measureSelect.change(this.measureChanged);
      this.$el.on('change', 'select, input', this.updateCharts);
    } // Returns a Promise.

  }, {
    key: "loadAvailableData",
    value: function loadAvailableData() {
      return new AvailableData().fetch();
    }
  }, {
    key: "fill",
    value: function fill(data) {
      this.data = data;
      this.fillSelect(this.typeSelect, CHART_TYPES);
      this.fillSelect(this.indicatorSelect, selectList(this.data), true);
    }
    /**
     *
     * @param {HTMLSelectElement} select
     * @param {import('../types/types').IdAndName[]} list
     * @param {boolean} appendEmpty
     */

  }, {
    key: "fillSelect",
    value: function fillSelect(select, list) {
      var appendEmpty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var options = [];

      if (appendEmpty) {
        options.push(this.createOption('', 'Please select'));
      }

      for (var i = 0, l = list.length; i < l; i++) {
        var item = list[i];
        var value = item.id || item;
        var label = item.name || item;
        options.push(this.createOption(value, label));
      }

      select.empty().append(options).prop('selectedIndex', 0).prop('disabled', list.length < 2);
    }
  }, {
    key: "createOption",
    value: function createOption(value, label) {
      return $('<option>').attr('value', value).text(label);
    }
  }, {
    key: "createCheckboxes",
    value: function createCheckboxes(name, container, list) {
      this.createElements(name, container, list, "<li><label>\n  <input type='checkbox' name=\"{{name}}\" value='{{id}}'\n  {{#checked}}checked{{/checked}}>{{name}}\n</label></li>");
    }
  }, {
    key: "createRadiobuttons",
    value: function createRadiobuttons(name, container, list) {
      this.createElements(name, container, list, "<li><label>\n  <input type='radio' name=\"{{name}}\" value='{{id}}'\n  {{#checked}}checked{{/checked}}>{{name}}\n</label></li>");
    }
  }, {
    key: "createElements",
    value: function createElements(name, container, list, templateString) {
      var template = createTemplate(templateString);
      var items = list.map(function (item, index) {
        var data = _.assign({
          name: name,
          checked: index === 0
        }, item);

        return template.render(data);
      });
      container.empty().append(items);
    }
  }, {
    key: "indicatorChanged",
    value: function indicatorChanged() {
      var indicator = this.indicatorSelect.val();
      var indicatorObj = this.data[indicator];
      var subjects = indicatorObj.subjects;
      this.fillSelect(this.subjectSelect, selectList(subjects));

      var _objectUtil$firstProp = objectUtil.firstProperty(subjects),
          subjectObj = _objectUtil$firstProp.value;

      var measures = subjectObj.measures;
      this.fillSelect(this.measureSelect, selectList(measures));

      var _objectUtil$firstProp2 = objectUtil.firstProperty(measures),
          measureObj = _objectUtil$firstProp2.value;

      var frequencies = measureObj.frequencies;
      this.fillSelect(this.frequencySelect, selectList(frequencies));
    }
  }, {
    key: "subjectChanged",
    value: function subjectChanged() {
      var indicator = this.indicatorSelect.val();
      var subjects = this.subjectSelect.val();
      var subject = subjects[0]; // Find & fill matching measures

      var subjectObj = this.data[indicator].subjects[subject];
      var measures = subjectObj.measures;
      this.fillSelect(this.measureSelect, selectList(measures)); // Find & fill matching frequencies

      var _objectUtil$firstProp3 = objectUtil.firstProperty(measures),
          measureObj = _objectUtil$firstProp3.value;

      var frequencies = measureObj.frequencies;
      this.fillSelect(this.frequencySelect, selectList(frequencies));
    }
  }, {
    key: "measureChanged",
    value: function measureChanged() {
      var indicator = this.indicatorSelect.val();
      var subjects = this.subjectSelect.val();
      var subject = subjects[0];
      var measure = this.measureSelect.val(); // Find & fill matching frequencies

      var measureObj = this.data[indicator].subjects[subject].measures[measure];
      var frequencies = measureObj.frequencies;
      this.fillSelect(this.frequencySelect, selectList(frequencies));
    }
  }, {
    key: "updateCharts",
    value: function updateCharts() {
      var config = this.getConfig(); // Ignore options with undefined/null values

      var reducer = function reducer(result, value, property) {
        if (value != null) {
          result[property] = value;
        }

        return result;
      };

      var cleanConfig = _.reduce(config, reducer, {});

      var type = cleanConfig.type,
          indicator = cleanConfig.indicator,
          subjects = cleanConfig.subjects,
          measure = cleanConfig.measure,
          frequency = cleanConfig.frequency;
      var valid = type && indicator && subjects[0] && measure && frequency;

      if (!valid) {
        return;
      } // Show the current codes


      var subjectsString = subjects.join('+');
      var currentCodes = [indicator, subjectsString, measure, frequency].join('  ');
      this.$('.current-codes').text(currentCodes); // Load config

      this.model.set(cleanConfig);
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        type: this.typeSelect.val(),
        indicator: this.indicatorSelect.val(),
        subjects: this.subjectSelect.val(),
        measure: this.measureSelect.val(),
        frequency: this.frequencySelect.val(),
        startTime: this.$('.time-period .start-time').val(),
        endTime: this.$('.time-period .end-time').val(),
        highlightedLocations: this.$('.highlighted-locations').val().split(/\s*,\s*/),
        baselineComparison: this.$('.baseline-comparison').val(),
        showBaseline: this.$('.show-baseline').prop('checked'),
        showNonBaseline: this.$('.show-non-baseline').prop('checked')
      };
    }
  }]);
  return DevChartControl;
}(BaseView);

DevChartControl.prototype.boundMethods = ['fill', 'indicatorChanged', 'subjectChanged', 'measureChanged', 'updateCharts']; // Disposal
// --------

DevChartControl.prototype.disposedProperties = ['data'];
module.exports = DevChartControl;

},{"../models/available-data":88,"../util/create-template":121,"../util/object":136,"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery","lodash":"lodash"}],161:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var $ = require('jquery');

var Dropdown = require('./dropdown');

var DropdownMultiple = /*#__PURE__*/function (_Dropdown) {
  (0, _inherits2.default)(DropdownMultiple, _Dropdown);

  var _super = _createSuper(DropdownMultiple);

  function DropdownMultiple() {
    (0, _classCallCheck2.default)(this, DropdownMultiple);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(DropdownMultiple, [{
    key: "setupList",
    value: // Property declarations
    // ---------------------
    //
    // checkboxes: Array of Elements
    // maxSelected: Number
    //   Maximum number of selected items
    // emptyLabel: String
    //   The label that is used when no item is selected
    // checkboxSelector: String
    // valueSelector: String
    // numberSelector: String
    function setupList(list) {
      this.checkboxes = this.$(this.checkboxSelector).toArray();
      var maxSelected = this.$el.data('maxSelected');
      this.maxSelected = Math.min(this.checkboxes.length, maxSelected || Infinity);
      this.emptyLabel = this.$el.data('emptyLabel');
      (0, _get2.default)((0, _getPrototypeOf2.default)(DropdownMultiple.prototype), "setupList", this).call(this, list);
    }
  }, {
    key: "registerItemHandlers",
    value: function registerItemHandlers() {
      this.list.on('change', this.checkboxSelector, this.itemChange);
    } // Reads the current value from the button, falls back to the first item.

  }, {
    key: "setInitialValue",
    value: function setInitialValue() {
      var value;
      var buttonValue = $.trim(this.$(this.valueSelector).text());

      if (buttonValue) {
        value = _.compact(buttonValue.split(/\s*,\s*/));
      } // Fall back to the first item


      if (!value || !value.length) {
        value = [this.checkboxes[0].value];
      }

      this.value(value, {
        silent: true
      });
      this.fillButtonNumber();
    } // Sets a new value. Expects an array.

  }, {
    key: "setValue",
    value: function setValue(value, options) {
      if (typeof value.length === 'undefined') {
        throw new Error('DropdownMultiple#setValue: Array expected');
      } // Apply selection maximum


      if (this.maxSelected) {
        value = value.slice(0, this.maxSelected);
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(DropdownMultiple.prototype), "setValue", this).call(this, value, options);
      this.setCheckboxValues(value);
    }
  }, {
    key: "getCheckboxValues",
    value: function getCheckboxValues() {
      return this.checkboxes.filter(function (checkbox) {
        return checkbox.checked && !checkbox.disabled;
      }).map(function (checkbox) {
        return checkbox.value;
      });
    }
  }, {
    key: "setCheckboxValues",
    value: function setCheckboxValues(value) {
      var checkboxes = this.checkboxes;

      for (var i = 0, l = checkboxes.length; i < l; i++) {
        var checkbox = checkboxes[i];
        checkbox.checked = value.indexOf(checkbox.value) >= 0;
      }
    }
  }, {
    key: "itemChange",
    value: function itemChange(event) {
      // Prevent the event from bubbling to the dropdown
      event.stopPropagation();
      var value = this.getCheckboxValues();
      this.applyMaximum(value);
      this.value(value);
    } // Enables/disables items when the maximum is reached

  }, {
    key: "applyMaximum",
    value: function applyMaximum(value) {
      if (!this.maxSelected) {
        return;
      }

      var disabledStates;

      if (value.length >= this.maxSelected) {
        // Disable all remaining, non-checked items
        disabledStates = this.checkboxes.map(function (checkbox) {
          return !checkbox.checked;
        });
      } else {
        // Enable all checkboxes
        disabledStates = this.checkboxes.map(function () {
          return false;
        });
      } // Apply the states


      for (var index = 0; index < this.checkboxes.length; index++) {
        var checkbox = this.checkboxes[index];
        var disabled = disabledStates[index];
        checkbox.disabled = disabled;
        $(checkbox).closest('label').toggleClass('disabled', disabled);
      }
    }
  }, {
    key: "isCurrentValue",
    value: function isCurrentValue(value) {
      return _.isEqual(_.sortBy(this.currentValue), _.sortBy(value));
    }
  }, {
    key: "isValidValue",
    value: function isValidValue(value) {
      var _this = this;

      return value.every(function (individualValue) {
        return Boolean(_this.itemByValue(individualValue));
      });
    } // Fills the button with the new label

  }, {
    key: "fillButton",
    value: function fillButton() {
      var _this2 = this;

      var label;

      if (this.currentValue.length === 0) {
        label = this.emptyLabel ? "<em>".concat(this.emptyLabel, "</em>") : '';
      } else {
        var labels = this.currentValue.map(function (value) {
          return _this2.itemByValue(value).text();
        });
        label = labels.join(', ');
      }

      this.$(this.valueSelector).html(label);
      this.fillButtonNumber();
    }
  }, {
    key: "fillButtonNumber",
    value: function fillButtonNumber() {
      var selected = this.currentValue.length;
      var text = '(' + selected + (this.maxSelected ? "/".concat(this.maxSelected) : '') + ')';
      this.$(this.numberSelector).text(text);
    }
  }]);
  return DropdownMultiple;
}(Dropdown); // Manually inherit static properties since Babel cannot do this in IE


DropdownMultiple.get = Dropdown.get;
DropdownMultiple.prototype.boundMethods = ['itemChange'];
DropdownMultiple.prototype.checkboxSelector = '.dropdown-multiple-checkbox';
DropdownMultiple.prototype.valueSelector = '.dropdown-multiple-value';
DropdownMultiple.prototype.numberSelector = '.dropdown-multiple-number';
module.exports = DropdownMultiple;

},{"./dropdown":162,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery","lodash":"lodash"}],162:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var $ = require('jquery');

var BaseView = require('./base-view');

var ListFilter = require('./list-filter'); // Simple widget that opens the dropdown list and allows to select an item.
// Fires a 'change' event on the button. Has two modes of operation:
// 1. select control that allows to select a value from the options
// 2. overlay mode with arbitrary content, for example a link list or
//    a more complex widget
// See dropdowns.html for examples.
// Constants
// ---------


var PROPERTY_NAME = 'ddpDropdown';

var Dropdown = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(Dropdown, _BaseView);

  var _super = _createSuper(Dropdown);

  /**
   * @param {import('./base-view').BaseViewOptions} options
   */
  function Dropdown(options) {
    var _this;

    (0, _classCallCheck2.default)(this, Dropdown);
    _this = _super.call(this, options); // Connect the element with the Dropdown instance

    _this.el[_this.propertyName] = (0, _assertThisInitialized2.default)(_this);
    _this.button = _this.$(_this.buttonSelector).on('click', _this.buttonClick); // Distinguish between list and overlay only

    var list = _this.$(_this.listSelector);

    if (list.length) {
      _this.setupList(list);
    } else {
      _this.setupOverlay();
    }

    _this.addFocusListeners(); // Hide list accessibly


    _this.toggleList(false);

    return _this;
  }
  /**
   * @param {JQuery} list
   */


  (0, _createClass2.default)(Dropdown, [{
    key: "setupList",
    value: function setupList(list) {
      this.list = list;
      this.registerItemHandlers();
      this.setInitialValue(); // Set up list filtering

      var input = this.$(this.filterInputSelector);

      if (input.length) {
        this.listFilter = new ListFilter({
          el: list,
          input: input
        });
      }
    } // Overlay only

  }, {
    key: "setupOverlay",
    value: function setupOverlay() {
      var list = this.$(this.overlaySelector);

      if (list.length) {
        this.list = list;
      }
    }
  }, {
    key: "addFocusListeners",
    value: function addFocusListeners() {
      this.list.on('focusin', this.focusinHandler);
    } // Opens the dropdown when an element inside gets focus.

  }, {
    key: "focusinHandler",
    value: function focusinHandler() {
      this.activate();
    }
  }, {
    key: "registerItemHandlers",
    value: function registerItemHandlers() {
      this.list.on('click', this.itemSelector, this.itemClick);
    } // Reads the current value from the button, falls back to the first item.

  }, {
    key: "setInitialValue",
    value: function setInitialValue() {
      var _this2 = this;

      /** @type {boolean} */
      var fillButton;
      /** @type {HTMLElement} */

      var item;
      var items = this.getItems();
      var buttonValue = $.trim(this.button.text());

      if (buttonValue) {
        fillButton = false; // The button might contain the label/value of an item.
        // Search for a matching item.

        item = _.find(items, function (candidateItem) {
          candidateItem = $(candidateItem);
          return _this2.getItemValue(candidateItem) === buttonValue || $.trim(candidateItem.text()) === buttonValue;
        });
      } else {
        fillButton = true;
      } // Fall back to the first item


      item = item ? $(item) : items.eq(0);
      var value = this.getItemValue(item);
      this.value(value, {
        fillButton: fillButton,
        silent: true
      });
    } // Event handlers
    // --------------

  }, {
    key: "buttonClick",
    value: function buttonClick(event) {
      event.preventDefault();

      if (this.button.hasClass(this.disabledClass)) {
        return;
      }

      this.toggleActive();
      this.positionDropdown();
    }
  }, {
    key: "positionDropdown",
    value: function positionDropdown() {
      var button = this.button,
          list = this.list;

      if (this.$el.css('position') === 'relative') {
        var position = list.attr('data-position');
        var buttonHeight = button.outerHeight();
        list.css(position === 'top' ? {
          bottom: buttonHeight
        } : {
          top: buttonHeight
        });
      }
    } // Close list when an element is clicked outside

  }, {
    key: "documentClick",
    value: function documentClick(event) {
      if (!this.ownEvent(event)) {
        this.deactivate();
      }
    } // Close list when an element gets focus outside

  }, {
    key: "documentFocusin",
    value: function documentFocusin(event) {
      // IE 9 fires bogus focusin events that have non-focussable elements
      // as targets. We need to ignore these events. They can produce false
      // negatives in the ownEvent check.
      var target = event.target;

      if (target.nodeName === 'DIV' && target.getAttribute('tabindex') === null) {
        return;
      }

      if (!this.ownEvent(event)) {
        this.deactivate();
      }
    } // Returns whether the target is the dropdown element or a child.
    // If the target isnt attached to the document, count it as an own event.

  }, {
    key: "ownEvent",
    value: function ownEvent(event) {
      var el = this.el;
      var target = event.target;

      var same = function same() {
        return el === target;
      };

      var attached = function attached() {
        return $.contains(document.body, target);
      };

      var nested = function nested() {
        return $.contains(el, target);
      };

      return same() || nested() || !attached();
    }
  }, {
    key: "itemClick",
    value: function itemClick(event) {
      var item = $(event.currentTarget); // Leave the behavior of normal links untouched

      var href = item.attr('href');

      if (href !== '' && href !== '#') {
        return;
      }

      event.preventDefault();

      if (item.hasClass(this.disabledClass)) {
        return;
      } // Set the new value


      this.value(this.getItemValue(item)); // Close list

      this.toggleActive(false);
    } // Active state
    // ------------

  }, {
    key: "activate",
    value: function activate() {
      return this.toggleActive(true);
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      return this.toggleActive(false);
    }
    /**
     * Changes the active state to the given state.
     * Toggles if state is not given.
     *
     * @param {boolean} active
     */

  }, {
    key: "toggleActive",
    value: function toggleActive(active) {
      if (this.active === active) {
        return;
      }

      if (active == null) {
        active = !this.active;
      }

      var button = this.button;
      var $document = $(document);

      if (active) {
        $document.on('click', this.documentClick);
        $document.on('focusin', this.documentFocusin);
      } else {
        $document.off('click', this.documentClick);
        $document.off('focusin', this.documentFocusin);
      }

      button.toggleClass('active', active);
      this.toggleList(active);
      this.active = active;
    } // Show/hide the list accessibly

  }, {
    key: "toggleList",
    value: function toggleList(active) {
      this.list.css('display', 'block').toggleClass('accessible-hide', !active);
    } // Value
    // -----

    /**
     * Gets or set the current value. Triggers a change event when setting.
     *
     * @param {string?} value
     * @param {{ fillButton: boolean, silent: boolean } | null} options
     */

  }, {
    key: "value",
    value: function value(_value, options) {
      options = _.assign({
        fillButton: true,
        silent: false
      }, options);

      if (_value != null) {
        this.setValue(_value, options);
        return;
      } else {
        return this.getValue();
      }
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this.currentValue;
    }
    /**
     * @param {string} value
     * @param {{ silent: boolean, fillButton: boolean }} options
     */

  }, {
    key: "setValue",
    value: function setValue(value, options) {
      if (this.isCurrentValue(value) || !this.isValidValue(value)) {
        return;
      }

      this.currentValue = value;

      if (options.fillButton) {
        this.fillButton();
      }

      if (!options.silent) {
        this.$el.trigger('change', value);
      }
    }
  }, {
    key: "isCurrentValue",
    value: function isCurrentValue(value) {
      return value === this.currentValue;
    } // Returns whether a given value is a valid option.

  }, {
    key: "isValidValue",
    value: function isValidValue(value) {
      return Boolean(this.itemByValue(value));
    } // Item element helpers
    // --------------------
    // Returns all item elements as a jQuery object.

  }, {
    key: "getItems",
    value: function getItems() {
      return this.list.find(this.itemSelector);
    } // Returns the item element for a given value.
    // Returns a jQuery object or null.

  }, {
    key: "itemByValue",
    value: function itemByValue(value) {
      var item = this.list.find("[data-".concat(this.dataValueKey, "='").concat(value, "']"));

      if (item.length) {
        return item;
      } else {
        return null;
      }
    }
    /**
     * Returns the value for a given item element.
     *
     * @param {JQuery} item
     * @returns {string}
     */

  }, {
    key: "getItemValue",
    value: function getItemValue(item) {
      return item.data(this.dataValueKey);
    } // Labels
    // ------
    // Fills the button with the new label

  }, {
    key: "fillButton",
    value: function fillButton() {
      this.button.html(this.itemByValue(this.currentValue).text());
    }
    /**
     * Updates the labels in the list.
     *
     * @param {IdAndName} labels
     */

  }, {
    key: "updateLabels",
    value: function updateLabels(labels) {
      for (var i = 0, l = labels.length; i < l; i++) {
        var label = labels[i];
        var item = this.itemByValue(label.id);

        if (item) {
          item.text(label.name);
        }
      }

      this.fillButton();
    } // Item state
    // ----------
    // Toggles the enable/disabled state of the items.
    // Expects an array with item values that are enabled,
    // all others will be disabled.

  }, {
    key: "toggleItems",
    value: function toggleItems(enabledItems) {
      this.getItems().each(function (index, el) {
        el = $(el);
        var value = el.data('value');
        return el.toggleClass('disabled', enabledItems.indexOf(value) === -1);
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      delete this.el[this.propertyName];

      if (this.listFilter) {
        this.listFilter.dispose();
      }

      $(document).off('click', this.documentClick).off('focusin', this.documentFocusin);
      (0, _get2.default)((0, _getPrototypeOf2.default)(Dropdown.prototype), "dispose", this).call(this);
    }
  }], [{
    key: "get",
    value: // Property declarations
    // ---------------------
    //
    // button: jQuery
    // list: jQuery
    // overlay: jQuery
    // currentValue: String
    // listFilter: ListFilter
    // itemTemplate: Function
    // buttonTemplate: Function
    // propertyName: String
    // dataValueKey: String
    // listSelector: String
    // buttonSelector: String
    // itemSelector: String
    // filterInputSelector: String
    // overlaySelector: String
    // disabledClass: String
    // active: Boolean
    // Disposal
    // --------
    // Static properties
    // -----------------

    /**
     * @param {HTMLElement} element
     * @returns {Dropdown}
     */
    function get(element) {
      return element[PROPERTY_NAME];
    }
  }]);
  return Dropdown;
}(BaseView);

Dropdown.prototype.boundMethods = ['focusinHandler', 'buttonClick', 'documentClick', 'documentFocusin', 'itemClick'];
Dropdown.prototype.propertyName = PROPERTY_NAME;
Dropdown.prototype.dataValueKey = 'value';
Dropdown.prototype.listSelector = '.dropdown-list';
Dropdown.prototype.buttonSelector = '.dropdown-button';
Dropdown.prototype.itemSelector = 'a';
Dropdown.prototype.filterInputSelector = 'input[type="text"], input[type="search"]';
Dropdown.prototype.overlaySelector = '.dropdown-overlay';
Dropdown.prototype.disabledClass = 'disabled';
Dropdown.prototype.active = false; // Disposal
// --------

Dropdown.prototype.disposedProperties = ['listFilter'];
module.exports = Dropdown;

},{"./base-view":150,"./list-filter":165,"@babel/runtime/helpers/assertThisInitialized":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery","lodash":"lodash"}],163:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var RSVP = require('rsvp');

var Configuration = require('../configuration');

var I18n = require('../i18n');

var createTemplate = require('../util/create-template');

var timeRange = require('../util/time-range');

var ShareView = require('./share-view');
/** @typedef {import('../models/chart-data').ChartTitleAttributes} ChartTitleAttributes **/

/** @typedef {ChartTitleAttributes & { timeFixedPeriod: string, timeUseLatestData: string, timeForSaving: string }} EmbeddedShareViewTitleAttributes */


var SHARE_SELECTION_TITLE_SELECTOR = '.share-selection-title';
var SHARE_SELECTION_DETAILS_SELECTOR = '.share-selection-details';
var SAVE_METHOD_SELECTOR = 'input[name="save-method"]';
var URL_SELECTOR = '.url';
var EMBED_CODE_SELECTOR = '.embed-code';
var SHARING_URL_COPY_SELECTOR = '.sharing-url-copy';
var EMBED_CODE_COPY_SELECTOR = '.embed-code-copy';
var SAVE_METHOD_WITH_DATA = 'with-data';
var SAVE_METHOD_FIXED_PERIOD = 'fixed-period';
var SAVE_METHOD_LATEST_DATA = 'latest-data'; // Do not emit change events. Were operating on a model clone
// but auto-fetch is enabled.

var setOptionsSilent = {
  silent: true
};
var detailsTemplate = createTemplate("<p>{{subtitle}}</p>\n<p>{{subjects}}, {{measure}}</p>\n<p>{{timeForSaving}}, {{frequency}}</p>\n{{#highlightedLocationsSingular}}\n  <p>\n    {{#t}}sharing.highlightedLocation{{/t}}\n    ({{highlightedLocations}})\n  </p>\n{{/highlightedLocationsSingular}}\n{{#highlightedLocationsPlural}}\n  <p>\n    {{highlightedLocationsLength}}\n    {{#t}}sharing.highlightedLocations{{/t}}\n    ({{highlightedLocations}})\n  </p>\n{{/highlightedLocationsPlural}}\n{{#baselineComparison}}\n  <p>\n    {{#t}}sharing.baselineIntro{{/t}}\n    {{baselineComparison}}{{#showNonBaseline}},\n      {{#t}}sharing.showNonBaseline{{/t}}\n    {{/showNonBaseline}}\n  </p>\n{{/baselineComparison}}"); // Share view embedded in the code of the Data Portal pages.
// Shown when the share button of charts on Data Portal pages is activated.

var EmbeddedShareView = /*#__PURE__*/function (_ShareView) {
  (0, _inherits2.default)(EmbeddedShareView, _ShareView);

  var _super = _createSuper(EmbeddedShareView);

  function EmbeddedShareView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, EmbeddedShareView);
    _this = _super.call(this, options);
    /** @type {import('../models/chart-data')} */

    _this.model;

    _this.monitorSaving();

    return _this;
  } // Rendering
  // ---------


  (0, _createClass2.default)(EmbeddedShareView, [{
    key: "render",
    value: function render() {
      // No super call
      this.registerDOMHandlers();

      if (this.model.get('data')) {
        this.renderTitle();
        this.renderTimes();
      }

      if (this.model.id) {
        this.updateCodes();
      } // Focus the overlay


      this.$el.attr('tabindex', '0').focus(); // Check the first save method. The state on the cloned template
      // gets lost after the first dialog.

      this.$(SAVE_METHOD_SELECTOR).first().prop('checked', true);
    }
  }, {
    key: "registerDOMHandlers",
    value: function registerDOMHandlers() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(EmbeddedShareView.prototype), "registerDOMHandlers", this).call(this);
      this.$el.on('change', SAVE_METHOD_SELECTOR, this.saveMethodChanged);
      this.$el.on('click', SHARING_URL_COPY_SELECTOR, this.sharingURLCopy);
      this.$el.on('click', EMBED_CODE_COPY_SELECTOR, this.embedCodeCopy);
    }
  }, {
    key: "renderTitle",
    value: function renderTitle() {
      var attributes = this.titleAttributes();
      var highlightedLocations = this.model.get('highlightedLocations');
      var length = highlightedLocations.length;

      _.assign(attributes, {
        highlightedLocations: highlightedLocations.join(', '),
        highlightedLocationsLength: length,
        highlightedLocationsSingular: length === 1,
        highlightedLocationsPlural: length > 1,
        baselineComparison: this.model.get('baselineComparison'),
        showNonBaseline: this.model.get('showNonBaseline')
      });

      this.$(SHARE_SELECTION_TITLE_SELECTOR).text(attributes.finalTitle);
      this.$(SHARE_SELECTION_DETAILS_SELECTOR).html(detailsTemplate.render(attributes));
    }
  }, {
    key: "renderTimes",
    value: function renderTimes() {
      var attrs = this.titleAttributes();
      this.$(".time-period-".concat(SAVE_METHOD_FIXED_PERIOD)).text(attrs.timeFixedPeriod);
      this.$(".time-period-".concat(SAVE_METHOD_LATEST_DATA)).text(attrs.timeUseLatestData);
    } // Methods for getting prepared chart information
    // ----------------------------------------------

  }, {
    key: "title",
    value: function title() {
      var attributes = this.titleAttributes();
      return _.compact([attributes.finalTitle, attributes.subtitle ? attributes.subtitle : undefined, attributes.subjects, attributes.measure, attributes.frequency, attributes.timeForSaving]).join(', ');
    }
    /**
     * Returns the titleAttributes from the model, augmented with:
     *
     * timeFixedPeriod:
     *   Time span when the selected save method is
     *   SAVE_METHOD_WITH_DATA or SAVE_METHOD_FIXED_PERIOD
     * timeUseLatestData:
     *   Time span when the selected save method is
     *   SAVE_METHOD_LATEST_DATA
     * timeForSaving:
     *   Time span for the selected save method
     *
     * @returns {EmbeddedShareViewTitleAttributes}
     */

  }, {
    key: "titleAttributes",
    value: function titleAttributes() {
      var attrs = this.model.titleAttributes();
      var saveMethod = this.saveMethod();
      attrs.timeFixedPeriod = this.timeFixedPeriod(attrs);
      attrs.timeUseLatestData = this.timeUseLatestData(attrs); // Time span for the selected save method

      attrs.timeForSaving = saveMethod === SAVE_METHOD_LATEST_DATA ? attrs.timeUseLatestData : attrs.timeFixedPeriod;
      return attrs;
    }
    /**
     * Time span for the with data and fixed period saving methods
     *
     * @param {ChartTitleAttributes} attrs
     */

  }, {
    key: "timeFixedPeriod",
    value: function timeFixedPeriod(attrs) {
      return timeRange(attrs.startTime, attrs.endTime, this.model.shownTimePeriods(), // Always show range, irrespective of useLatestData
      false).time;
    }
    /**
     * Time span for the use latest data saving method
     *
     * @param {ChartTitleAttributes} attrs
     * @returns {string}
     */

  }, {
    key: "timeUseLatestData",
    value: function timeUseLatestData(attrs) {
      if (this.model.get('useLatestData')) {
        // Case 1: useLatestData on: e.g. latest 5 years
        var frequency = this.model.get('frequency');
        var templateString = I18n.t('latestXTimePeriods')[frequency];
        var timePeriodCount = Configuration.get('latestDataTimePeriods')[frequency];
        return createTemplate(templateString).render({
          timePeriodCount: timePeriodCount
        });
      } else {
        // Case 2: useLatestData off: fixed start time, omit end time
        var shownTimePeriods = this.model.shownTimePeriods();
        var endTimeLabel = I18n.t('sharing.omitEndTime');

        if (shownTimePeriods > 1) {
          // e.g. 2000 - latest
          return "".concat(attrs.startTime, " \u2013 ").concat(endTimeLabel);
        } else {
          // e.g. latest
          return endTimeLabel;
        }
      }
    } // Saving
    // ------

  }, {
    key: "saveMethodChanged",
    value: function saveMethodChanged() {
      this.renderTitle();
      this.save();
    } // Saves the model with the checked options. Returns a promise.

  }, {
    key: "save",
    value: function save() {
      var model = this.model,
          originalModel = this.originalModel;
      var saveMethod = this.saveMethod(); // Save with data

      var saveOptions;

      if (saveMethod === SAVE_METHOD_WITH_DATA) {
        saveOptions = {
          withData: true
        };
      }

      if (saveMethod === SAVE_METHOD_WITH_DATA || saveMethod === SAVE_METHOD_FIXED_PERIOD) {
        // Fixed period with or without data
        // ---------------------------------
        // Set start and end time to actual
        model.set('startTime', originalModel.actualStartTime().id, setOptionsSilent);
        model.set('endTime', originalModel.actualEndTime().id, setOptionsSilent);
      } else if (saveMethod === SAVE_METHOD_LATEST_DATA) {
        // Use latest data
        // ---------------
        var useLatestData = model.get('useLatestData');

        if (useLatestData) {
          // Case 1: useLatestData activated
          // Remove startTime and endTime
          // The startTime is calculated when the chart is initialized (see
          // `ChartData#normalizeAttributes`).
          model.unset('startTime', setOptionsSilent);
          model.unset('endTime', setOptionsSilent);
        } else {
          // Case 2: useLatestData not activated
          // Fixed start time, open end time
          // Set startTime, remove endTime
          model.set('startTime', originalModel.actualStartTime().id, setOptionsSilent);
          model.unset('endTime', setOptionsSilent);
        }
      }

      return model.save(saveOptions);
    } // Returns the selected save method.
    // Returns SAVE_METHOD_WITH_DATA, SAVE_METHOD_FIXED_PERIOD or
    // SAVE_METHOD_LATEST_DATA (strings).

  }, {
    key: "saveMethod",
    value: function saveMethod() {
      return this.$("".concat(SAVE_METHOD_SELECTOR, ":checked")).val();
    }
  }, {
    key: "sharingURLCopy",
    value: function sharingURLCopy() {
      this.copyToClipboard(this.$(URL_SELECTOR));
    }
  }, {
    key: "embedCodeCopy",
    value: function embedCodeCopy() {
      this.copyToClipboard(this.$(EMBED_CODE_SELECTOR));
    }
    /**
     * Copies the text of the given field to the clipboard
     * @param {JQuery<HTMLInputElement | HTMLTextAreaElement>} field
     */

  }, {
    key: "copyToClipboard",
    value: function copyToClipboard(field) {
      var _this2 = this;

      var text = field.val();

      var copyClipboardAPI = function copyClipboardAPI() {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          return navigator.clipboard.writeText(text);
        } else {
          return new RSVP.Promise.reject();
        }
      };

      var copyExecCommand = function copyExecCommand() {
        return new RSVP.Promise(function (fulfill, reject) {
          _this2.selectField(field);

          var result = document.execCommand('copy');

          if (result) {
            fulfill();
          } else {
            reject();
          }
        });
      };

      copyClipboardAPI().catch(copyExecCommand);
    } // Preview
    // -------

  }, {
    key: "preview",
    value: function preview() {
      if (this.model.id) {
        (0, _get2.default)((0, _getPrototypeOf2.default)(EmbeddedShareView.prototype), "preview", this).call(this);
      }
    }
  }]);
  return EmbeddedShareView;
}(ShareView); // Manually inherit static properties since Babel cannot do this in IE


EmbeddedShareView.create = ShareView.create;
EmbeddedShareView.selector = ShareView.selector;
EmbeddedShareView.prototype.boundMethods = ['saveMethodChanged', 'save', 'saveMethod', 'sharingURLCopy', 'embedCodeCopy'];
module.exports = EmbeddedShareView;

},{"../configuration":67,"../i18n":82,"../util/create-template":121,"../util/time-range":142,"./share-view":172,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"lodash":"lodash","rsvp":32}],164:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var $ = require('jquery');

var _ = require('lodash');

var LOCATION_GROUPS = require('../constants/location-groups');

var LOCATION_GROUP_IDS = require('../constants/location-group-ids');

var createTemplate = require('../util/create-template');

var BaseView = require('./base-view');

var Dropdown = require('./dropdown');

var ListFilter = require('./list-filter');

var HighlightService = require('../charts/highlight-service');

var _allLocations = require('../models/all-locations');
/**
 * @typedef {{
 * el: JQuery<HTMLElement>,
 * model: import('../models/chart-data'),
 * metadata: import('../models/indicator-metadata')
 * }} ConstructorOptions
 */
// Constants
// ---------


var HIGHLIGHTED_LOCATIONS = 'highlightedLocations';
var ALL_LOCATIONS_ID = '_ALL';
var HIGHLIGHTED_LOCATIONS_ID = '_HIGHLIGHTED';
var locationTemplate = createTemplate("<li class=\"location-list-item\" data-id=\"{{id}}\">\n  <a href=\"\" class=\"location-list-link\">\n    <span class=\"location-id location-list-id\">{{id}}</span>\n    <span class=\"location-list-name\">{{name}}</span>\n  </a>\n</li>");
var highlightedLocationTemplate = createTemplate("<li data-id=\"{{id}}\" class=\"highlighted-location\n  {{#isHighlighted}}\n    is-highlighted highlight-{{highlightNumber}}\n  {{/isHighlighted}}\">\n  <a href=\"\" title=\"{{name}}\"\n    class=\"location-id highlighted-location-link\">\n    <span class=\"highlighted-location-id\">{{id}}</span>\n    <span class=\"highlighted-location-icon\">\u2715</span>\n  </a>\n</li>");

var HighlightedLocationsOverlay = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(HighlightedLocationsOverlay, _BaseView);

  var _super = _createSuper(HighlightedLocationsOverlay);

  // Property declarations
  // ---------------------
  //
  // metadata: IndicatorMetadata
  // dropdown: Dropdown
  // locationList: jQuery
  // listFilter: ListFilter
  // highlightService: HighlightService
  // closeButtonSelector: String
  // Filters
  // searchFilterSelector: String
  // Location list
  // locationsSelector: String
  // locationSelector: String
  // Current highlighted locations
  // highlightedLocationNumberSelector: String
  // highlightedLocationsSelector: String
  // highlightedLocationSelector: String
  // removeAllSelector: String
  // Comparison
  // comparisonRadioSelector: String
  // baselineCheckboxSelector: String
  // baselineLabelSelector: String

  /**
   * @param {ConstructorOptions} options
   */
  function HighlightedLocationsOverlay(options) {
    var _this;

    (0, _classCallCheck2.default)(this, HighlightedLocationsOverlay);
    _this = _super.call(this, options);
    _this.metadata = options.metadata;
    _this.dropdown = Dropdown.get(_this.el);
    _this.locationList = _this.$(_this.locationsSelector);
    _this.listFilter = new ListFilter({
      el: _this.locationList,
      input: _this.$(_this.searchFilterSelector)
    });
    _this.highlightService = new HighlightService(_this.model);

    _this.registerDOMHandlers();

    _this.registerModelHandlers();

    return _this;
  }

  (0, _createClass2.default)(HighlightedLocationsOverlay, [{
    key: "render",
    value: function render() {
      this.renderPlaceholder();
      this.updateComparison();
      this.updateBaselineCheckbox();
      this.updateRemoveAll();
    } // DOM event handling
    // ------------------

  }, {
    key: "registerDOMHandlers",
    value: function registerDOMHandlers() {
      var events = [['click', this.closeButtonSelector, this.close], // Location list filtering
      ['keyup', this.searchFilterSelector, this.searchFilterKeyup], // Location list
      ['click', this.locationSelector, this.locationClick], // Current highlighted locations
      ['click', this.highlightedLocationSelector, this.highlightedLocationClick], ['click', this.removeAllSelector, this.removeAllClick], // Comparison
      ['click', this.comparisonRadioSelector, this.comparisonChanged], ['click', this.baselineCheckboxSelector, this.baselineChanged]];

      for (var i = 0, l = events.length; i < l; i++) {
        var event = events[i];
        this.$el.on(event[0], event[1], event[2]);
      }
    }
  }, {
    key: "close",
    value: function close(event) {
      event.preventDefault();
      this.dropdown.toggleActive(false);
    } // Model binding
    // -------------

  }, {
    key: "registerModelHandlers",
    value: function registerModelHandlers() {
      var events = [['change:data', this.modelDataChanged], ['change:highlightedLocations', this.modelHighlightedLocationsChanged]];

      for (var i = 0, l = events.length; i < l; i++) {
        var event = events[i];
        this.model.on(event[0], event[1], this);
      } // Metadata model


      this.metadata.on('change:data', this.metadataChanged, this);
    }
  }, {
    key: "modelDataChanged",
    value: function modelDataChanged() {
      this.updateHighlightedLocationNumber();
      this.renderHighlightedLocations();
      this.updateBaselineLabel();
      this.renderLocations();
    }
  }, {
    key: "modelHighlightedLocationsChanged",
    value: function modelHighlightedLocationsChanged() {
      // We need the server response
      if (!this.model.get('data')) {
        return;
      }

      this.updateHighlightedLocationNumber();
      this.renderHighlightedLocations();
      this.setComparisonLocations();
      this.updateLocations();
      this.updateRemoveAll();
    }
  }, {
    key: "metadataChanged",
    value: function metadataChanged() {
      // Handle race condition. Metadata might be loaded before model data.
      if (!this.model.get('data')) {
        this.model.once('change:data', this.metadataChanged, this);
        return;
      }

      this.renderHighlightedLocations();
      this.renderLocations();
    } // Getting and manipulating highlighted locations
    // ----------------------------------------------
    // Gets the highlighted locations from the model.
    // Returns an array of ids.

  }, {
    key: "getHighlightedLocations",
    value: function getHighlightedLocations() {
      return this.model.get(HIGHLIGHTED_LOCATIONS);
    } // Sets the highlighted locations on the model.

  }, {
    key: "setHighlightedLocations",
    value: function setHighlightedLocations(highlightedLocations) {
      this.model.set(HIGHLIGHTED_LOCATIONS, highlightedLocations);
    }
  }, {
    key: "toggleHighlightedLocation",
    value: function toggleHighlightedLocation(id) {
      if (this.getHighlightedLocations().indexOf(id) >= 0) {
        this.removeHighlightedLocation(id);
      } else {
        this.addHighlightedLocation(id);
      }
    }
  }, {
    key: "addHighlightedLocation",
    value: function addHighlightedLocation(id) {
      var locations = _.chain(this.getHighlightedLocations()).concat(id).sort().uniq(true).value();

      this.setHighlightedLocations(locations);
    }
  }, {
    key: "removeHighlightedLocation",
    value: function removeHighlightedLocation(id) {
      this.setHighlightedLocations(_.without(this.getHighlightedLocations(), id));
    } // Location list filtering
    // -----------------------

  }, {
    key: "renderPlaceholder",
    value: function renderPlaceholder() {
      var searchFilter = this.$(this.searchFilterSelector);

      if ('placeholder' in searchFilter.get(0)) {
        return;
      }

      var showPlaceholder = function showPlaceholder() {
        searchFilter.val(placeholder).addClass('placeholder-visible');
      };

      var hidePlaceholder = function hidePlaceholder() {
        searchFilter.val('').removeClass('placeholder-visible');
      };

      var placeholder = searchFilter.attr('placeholder');
      showPlaceholder();
      searchFilter.focus(function () {
        if (searchFilter.val() === placeholder) {
          hidePlaceholder();
        }
      }).blur(function () {
        if (searchFilter.val() === '') {
          showPlaceholder();
        }
      });
    }
  }, {
    key: "searchFilterKeyup",
    value: function searchFilterKeyup(event) {
      // On enter, toggle the first search result
      if (event.which === 13) {
        var locationItem = this.$("".concat(this.locationSelector, ":visible"));
        var id = locationItem.data('id');

        if (id) {
          this.toggleHighlightedLocation(id);
        }
      }
    } // Location list
    // -------------

  }, {
    key: "locationClick",
    value: function locationClick(event) {
      event.preventDefault();
      var id = $(event.currentTarget).data('id');
      this.toggleHighlightedLocation(id);
    } // Renders the location list.
    // This method is called at least two times:
    // 1. data available, metadata not available
    // 2. data available, metadata available

  }, {
    key: "renderLocations",
    value: function renderLocations() {
      var _this2 = this;

      var items = this.allSortedLocations().map(function (item) {
        var $el = $(locationTemplate.render(item)); // Set classes before adding to the DOM

        _this2.updateLocation(item.id, $el);

        return $el.get(0);
      });
      this.locationList.html(items);
    } // Updates the status of locations already in the DOM.

  }, {
    key: "updateLocations",
    value: function updateLocations() {
      var _this3 = this;

      this.$(this.locationSelector).each(function (index, el) {
        var $el = $(el);
        var id = $el.data('id');

        _this3.updateLocation(id, $el);
      });
    } // Updates a location element, sets several classes.
    // Expects an id and a jQuery object.

  }, {
    key: "updateLocation",
    value: function updateLocation(id, el) {
      // Type
      el.toggleClass('is-group', LOCATION_GROUP_IDS.indexOf(id) >= 0); // Set color classes for highlight / baseline comparison

      this.highlightService.update(el.get(0), id);
    } // Location list helpers
    // ---------------------
    // Returns all known locations of the indicator.
    // Returns an array of { id, name }.

  }, {
    key: "allLocations",
    value: function allLocations() {
      return _allLocations(this.model, this.metadata);
    } // All sorted locations. Order: First groups, then countries.

  }, {
    key: "allSortedLocations",
    value: function allSortedLocations() {
      return _.chain(this.allLocations()).map(function (location) {
        // Add a sort id
        var prefix = LOCATION_GROUP_IDS.indexOf(location.id) >= 0 ? 0 : 1;
        return _.extend({}, location, {
          sortId: "".concat(prefix, "_").concat(location.id)
        });
      }).sortBy('sortId').value();
    } // Current highlighted locations
    // -----------------------------
    // Updates the location number on the button

  }, {
    key: "updateHighlightedLocationNumber",
    value: function updateHighlightedLocationNumber() {
      return this.$(this.highlightedLocationNumberSelector).text(this.getHighlightedLocations().length);
    } // Fills the highlighted locations list

  }, {
    key: "renderHighlightedLocations",
    value: function renderHighlightedLocations() {
      var _this4 = this;

      var locations = this.allLocations();
      var items = this.getHighlightedLocations().map(function (id) {
        // Get the name for the id
        var location = _.find(locations, {
          id: id
        });

        var name = location ? location.name : ''; // Location might be highlighted but not present in the data
        // (no number/color assigned)

        var highlightNumber = _this4.model.highlightNumber(id);

        return highlightedLocationTemplate.render({
          id: id,
          name: name,
          isHighlighted: highlightNumber !== false,
          highlightNumber: highlightNumber
        });
      });
      this.$(this.highlightedLocationsSelector).html(items);
    }
  }, {
    key: "highlightedLocationClick",
    value: function highlightedLocationClick(event) {
      event.preventDefault();
      var id = $(event.currentTarget).data('id');
      this.removeHighlightedLocation(id);
    }
  }, {
    key: "updateRemoveAll",
    value: function updateRemoveAll() {
      this.$(this.removeAllSelector).css('display', this.getHighlightedLocations().length > 0 ? '' : 'none');
    }
  }, {
    key: "removeAllClick",
    value: function removeAllClick(event) {
      event.preventDefault();
      this.setHighlightedLocations([]);
    } // Comparison locations
    // --------------------
    // Translates legacy `showNonBaseline` to only highlighted comparison option
    // (Select background: none in the UI)

  }, {
    key: "updateComparison",
    value: function updateComparison() {
      if (!this.model.get('showNonBaseline')) {
        this.$(this.comparisonRadioSelector).filter(function (index, el) {
          return el.value === HIGHLIGHTED_LOCATIONS_ID;
        }).prop('checked', true);
      }
    }
  }, {
    key: "comparisonChanged",
    value: function comparisonChanged() {
      this.setComparisonLocations();
    } // Reads the comparison fields, sets `locations` accordingly

  }, {
    key: "setComparisonLocations",
    value: function setComparisonLocations() {
      var groupId = this.$(this.comparisonRadioSelector).filter(':checked').val();
      var baselineComparison = this.model.get('showBaseline') ? [this.model.get('baselineComparison')] : [];
      var highlightedLocations = this.getHighlightedLocations(); // Create locations list

      var locations = groupId === ALL_LOCATIONS_ID ? // All locations
      [] : groupId === HIGHLIGHTED_LOCATIONS_ID ? // Baseline + highlighted
      baselineComparison.concat(highlightedLocations) : // Baseline + highlighted + group locations
      baselineComparison.concat(highlightedLocations).concat(_.find(LOCATION_GROUPS, {
        id: groupId
      }).locations);
      locations = _.chain(locations).sort().uniq(true).value(); // Reset legacy config `showNonBaseline`

      this.model.set({
        locations: locations,
        showNonBaseline: true
      });
    } // Baseline comparison
    // -------------------
    // Updates the baseline comparison checkbox from the model.

  }, {
    key: "updateBaselineCheckbox",
    value: function updateBaselineCheckbox() {
      this.$(this.baselineCheckboxSelector).prop('checked', this.model.get('showBaseline'));
    } // Shows the human-readable baseline comparison name.

  }, {
    key: "updateBaselineLabel",
    value: function updateBaselineLabel() {
      var data = this.model.get('data');

      if (!data) {
        return;
      }

      var location = _.find(this.allLocations(), {
        id: this.model.get('baselineComparison')
      });

      if (location) {
        this.$(this.baselineLabelSelector).text(location.name);
      }
    } // Event handler for the baseline checkbox. Updates model from DOM.

  }, {
    key: "baselineChanged",
    value: function baselineChanged(event) {
      this.model.set('showBaseline', $(event.target).prop('checked'));
      this.setComparisonLocations();
    }
  }]);
  return HighlightedLocationsOverlay;
}(BaseView);

HighlightedLocationsOverlay.prototype.boundMethods = ['close', 'searchFilterKeyup', 'locationClick', 'highlightedLocationClick', 'removeAllClick', 'comparisonChanged', 'baselineChanged'];
HighlightedLocationsOverlay.prototype.closeButtonSelector = '.close-btn'; // Filters

HighlightedLocationsOverlay.prototype.searchFilterSelector = '.search-filter-input'; // Location list

HighlightedLocationsOverlay.prototype.locationsSelector = '.location-list';
HighlightedLocationsOverlay.prototype.locationSelector = '.location-list-item'; // Current highlighted locations

HighlightedLocationsOverlay.prototype.highlightedLocationNumberSelector = '.selected-locations-count';
HighlightedLocationsOverlay.prototype.highlightedLocationsSelector = '.highlighted-locations';
HighlightedLocationsOverlay.prototype.highlightedLocationSelector = '.highlighted-location';
HighlightedLocationsOverlay.prototype.removeAllSelector = '.remove-all-button'; // Comparison

HighlightedLocationsOverlay.prototype.comparisonRadioSelector = '.comparison-radio';
HighlightedLocationsOverlay.prototype.baselineCheckboxSelector = '.baseline-comparison-checkbox';
HighlightedLocationsOverlay.prototype.baselineLabelSelector = '.baseline-comparison-label';
module.exports = HighlightedLocationsOverlay;

},{"../charts/highlight-service":48,"../constants/location-group-ids":73,"../constants/location-groups":74,"../models/all-locations":84,"../util/create-template":121,"./base-view":150,"./dropdown":162,"./list-filter":165,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery","lodash":"lodash"}],165:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var $ = require('jquery');

var Backbone = require('backbone');

var createTemplate = require('../util/create-template');

var BaseView = require('./base-view'); // Allows to filter an HTML list using a text input field


var ListFilter = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(ListFilter, _BaseView);

  var _super = _createSuper(ListFilter);

  // Property declarations
  // ---------------------
  //
  // input: jQuery
  // noResultsTemplate: Hogan template
  // noResults: jQuery
  // Mandatory options: { input: Element or jQuery }
  function ListFilter(options) {
    var _this;

    (0, _classCallCheck2.default)(this, ListFilter);
    _this = _super.call(this, options);
    _this.input = $(options.input);

    _this.input.on('input change', _this.inputChangeHandler);

    _this.noResultsTemplate = createTemplate("<p class='".concat(_this.noResultsClass, "'>{{#t}}listFilter.noResults{{/t}}</p>"));
    return _this;
  }

  (0, _createClass2.default)(ListFilter, [{
    key: "inputChangeHandler",
    value: function inputChangeHandler(event) {
      var searchTerm = $.trim(event.target.value.toLowerCase());
      this.filterByText(searchTerm);
    }
  }, {
    key: "filterByText",
    value: function filterByText(text) {
      var predicate;

      if (!text) {
        predicate = function predicate() {
          return true;
        };
      } else {
        var regExp = new RegExp(_.escapeRegExp(text), 'i');

        predicate = function predicate(_item, candidateText) {
          return regExp.test(candidateText);
        };
      }

      this.filter(predicate);
      this.trigger('filterByText', text);
    } // Returns the items as a jQuery object.

  }, {
    key: "items",
    value: function items() {
      return this.$(this.itemSelector);
    } // Filters the list by a given predicate function.
    // The function gets element: jQuery, text: String parameters.

  }, {
    key: "filter",
    value: function filter(predicate) {
      var items = this.items();
      var found = false;
      items.each(function (index, el) {
        var item = $(el);
        var text = item.text();
        var visible = predicate(item, text);

        if (visible) {
          found = true;
        }

        return item.css('display', visible ? '' : 'none');
      });

      if (found) {
        this.hideNoResults();
      } else {
        this.showNoResults();
      }
    } // Resets the filter, shows all items.

  }, {
    key: "resetFilter",
    value: function resetFilter() {
      this.items().css('display', '');
    } // Shows a notice that the filtering yielded no results.

  }, {
    key: "showNoResults",
    value: function showNoResults() {
      this.hideNoResults();
      var el = $.parseHTML(this.noResultsTemplate.render());
      this.noResults = $(el);
      this.$el.append(el);
    } // Remove tehs notice that the filtering yielded no results.

  }, {
    key: "hideNoResults",
    value: function hideNoResults() {
      if (this.noResults) {
        this.noResults.remove();
      }
    } // Disposal
    // --------

  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      this.input.off('input change', this.filter);
      (0, _get2.default)((0, _getPrototypeOf2.default)(ListFilter.prototype), "dispose", this).call(this);
    }
  }]);
  return ListFilter;
}(BaseView);

_.assign(ListFilter.prototype, Backbone.Events);

ListFilter.prototype.boundMethods = ['inputChangeHandler'];
ListFilter.prototype.itemSelector = 'li';
ListFilter.prototype.noResultsClass = 'no-results';
module.exports = ListFilter;

},{"../util/create-template":121,"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"backbone":"backbone","jquery":"jquery","lodash":"lodash"}],166:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var $ = require('jquery');

var createTemplate = require('../util/create-template');

var I18n = require('../i18n');

var BaseView = require('./base-view');

var CLOSED_CLASS = 'closed';
var linkTemplate = createTemplate("<a href=\"\" class=\"link-more\">{{#t}}moreSection.more{{/t}}</a>");

var MoreSection = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(MoreSection, _BaseView);

  var _super = _createSuper(MoreSection);

  function MoreSection(options) {
    var _this;

    (0, _classCallCheck2.default)(this, MoreSection);
    _this = _super.call(this, options);
    _this.maxHeight = options.maxHeight != null ? options.maxHeight : 120;

    if (_this.$el.height() > _this.maxHeight) {
      var html = linkTemplate.render();
      _this.moreLink = $(html).click(_this.toggle);

      _this.$el.addClass(CLOSED_CLASS).after(_this.moreLink);
    }

    return _this;
  }

  (0, _createClass2.default)(MoreSection, [{
    key: "toggle",
    value: function toggle(event) {
      event.preventDefault();
      this.$el.toggleClass(CLOSED_CLASS);
      var label = I18n.t(this.$el.hasClass(CLOSED_CLASS) ? 'moreSection.more' : 'moreSection.less');
      this.moreLink.text(label);
    }
  }]);
  return MoreSection;
}(BaseView);

MoreSection.prototype.boundMethods = ['toggle'];
module.exports = MoreSection;

},{"../i18n":82,"../util/create-template":121,"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery"}],167:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var $ = require('jquery');

var _ = require('lodash');

var I18n = require('../i18n');

var createTemplate = require('../util/create-template');

var BaseView = require('./base-view');

var SelectionMediator = require('../models/selection-mediator');

var pinboardMediator = require('../models/pinboard-mediator');

var ChartView = require('./chart-view');

var PinboardShareView = require('./pinboard-share-view'); // The pinboard editor does not have a direct this.model reference
// but is using the pinboardMediator to access the pinboard model.


var LAYOUT_SMALL_TILES = 'small-tiles';
var LAYOUT_PRIMARY_WITH_SECONDARIES = 'primary-with-secondaries';
var LAYOUT_VERTICAL = 'vertical';
var LAYOUTS = [LAYOUT_SMALL_TILES, LAYOUT_PRIMARY_WITH_SECONDARIES, LAYOUT_VERTICAL];
var CHART_CLASS = 'chart';
var CHART_SELECTOR = ".".concat(CHART_CLASS);
var DDP_CHART_CLASS = 'ddp-chart';
var DDP_CHART_SELECTOR = ".".concat(DDP_CHART_CLASS);
var CHART_DRAGHOVER_CLASS = 'chart-draghover';
var EDITOR_DRAGGING_CLASS = 'editor-dragging';
var CHART_DRAGGING_CLASS = 'chart-dragging'; // The transparent overlay covers the whole .chart and
// catches drag* events. Simplifies the event handling.
// Its also used for highlighting the chart.

var OVERLAY_CLASS = 'drag-overlay';

var DRAGGABLE_SUPPORTED = function () {
  return 'draggable' in document.createElement('div');
}();

var chartTemplate = createTemplate("<div class=\"".concat(CHART_CLASS, "\">\n<div class=\"chart-inner\">\n<div class=\"").concat(DDP_CHART_CLASS, "\"></div>\n<ul class=\"chart-controls\">\n<li>\n  <a class=\"move-chart\">\n    <i class=\"icon-ddp-hamburger\"></i>\n  </a>\n</li>\n<li>\n  <a href=\"\" class=\"edit-chart\" title=\"{{editChartTitle}}\">\n    <i class=\"icon-ddp-settings\"></i>\n  </a>\n</li>\n<li>\n  <a href=\"\" class=\"remove-chart\">\n    <i class=\"icon-ddp-close\"></i>\n  </a>\n</li>\n</ul>\n<div class=\"").concat(OVERLAY_CLASS, "\"></div>\n</div>\n</div>"));

var PinboardEditorView = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(PinboardEditorView, _BaseView);

  var _super = _createSuper(PinboardEditorView);

  // Property declarations
  // ---------------------
  //
  // chartContainer: jQuery
  // chartViews: Array
  //   Array with all chart views. Ordered by creation time,
  //   NOT in sync with the model or the DOM.
  function PinboardEditorView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, PinboardEditorView);
    _this = _super.call(this, options);
    _this.chartViews = [];
    _this.chartContainer = _this.$('.pinboard-editor-charts');

    _this.$el.on('click', '.pinboard-layout li', _this.layoutChanged).on('click', '.export-options .share-btn', _this.share).on('click', '.export-options .download-btn', _this.download).on('click', '.edit-chart', _this.editChart).on('click', '.remove-chart', _this.removeChart);

    _this.initDragAndDrop();

    _this.render(true);

    return _this;
  } // Rendering
  // ---------
  // Initial rendering


  (0, _createClass2.default)(PinboardEditorView, [{
    key: "render",
    value: function render(initialRender) {
      if (initialRender == null) {
        initialRender = false;
      }

      var charts = pinboardMediator.charts();

      if (charts.length) {
        this.setLayoutClasses();

        if (initialRender) {
          // Create views
          for (var i = 0, l = charts.length; i < l; i++) {
            var model = charts[i];
            this.renderChart(model);
          }
        } else {
          // Re-render views, forcing the size change
          var chartViews = this.chartViews;

          for (var _i = 0, _l = chartViews.length; _i < _l; _i++) {
            var view = chartViews[_i];
            view.render(true);
          }
        }
      } else {
        this.chartContainer.text(I18n.t('sharing.pinboardNoChartsAdded'));
      }
    } // Creates a ChartView for the given model, inserts and renders it

  }, {
    key: "renderChart",
    value: function renderChart(model) {
      // Create new container, append to DOM
      var editChartTitle = I18n.t('sharing.pinboardEditChart');
      var chartEl = $(chartTemplate.render({
        editChartTitle: editChartTitle
      }));
      this.chartContainer.append(chartEl); // Create the chart itself

      var chartViewEl = this.chartViewEl(chartEl);
      var view = new ChartView({
        el: chartViewEl,
        model: model
      });
      SelectionMediator.observe(model);
      this.chartViews.push(view); // Engage!

      model.fetchInitially();
    } // Layout
    // ------

  }, {
    key: "setLayoutClasses",
    value: function setLayoutClasses() {
      var layout = pinboardMediator.layout(); // Update the segmented control

      var li = this.$(".pinboard-layout li[data-layout='".concat(layout, "']"));
      li.addClass('current').siblings().removeClass('current'); // Set layout classes

      var classes = LAYOUTS.map(this.layoutClass).join(' ');
      var charts = pinboardMediator.charts();
      this.chartContainer.removeClass(classes).addClass(this.layoutClass(layout)).toggleClass('less-than-four-charts', charts.length < 4).toggleClass('four-plus-charts', charts.length >= 4);
    } // Returns the class name for a given layout name

  }, {
    key: "layoutClass",
    value: function layoutClass(layout) {
      return "layout-".concat(layout);
    }
  }, {
    key: "layoutChanged",
    value: function layoutChanged(event) {
      event.preventDefault();
      var layout = $(event.currentTarget).data('layout');
      pinboardMediator.layout(layout);
      this.render();
    } // Pinboard actions
    // ----------------

  }, {
    key: "share",
    value: function share(event) {
      var _this2 = this;

      event.preventDefault();
      var model = pinboardMediator.model;
      var view = PinboardShareView.create(model);

      if (view) {
        var fulfilled = function fulfilled() {
          view = PinboardShareView.create(model);

          _this2.$el.after(view.el);
        };

        pinboardMediator.save().then(fulfilled);
      }
    }
  }, {
    key: "download",
    value: function download(event) {
      event.preventDefault(); // model = pinboardMediator.model

      alert('Not implemented');
    }
  }, {
    key: "editChart",
    value: function editChart(event) {
      event.preventDefault();
      var chartEl = this.closestChartEl(event.currentTarget);
      var model = this.modelByEl(chartEl); // Activate edit mode for the model

      pinboardMediator.enterEditMode(model); // User selection carry over: Manually store the model config

      SelectionMediator.update(model.get('storedConfiguration'), model.attributes, false); // Redirect to indicator page

      location.href = model.get('referrer') + '#indicator-chart';
    }
  }, {
    key: "removeChart",
    value: function removeChart(event) {
      event.preventDefault();
      var chartEl = this.closestChartEl(event.currentTarget);
      var chartElIndex = this.chartElIndex(chartEl); // Remove model from pinboard

      var model = this.modelByEl(chartEl);
      pinboardMediator.removeChart(model); // Dispose view

      var view = this.viewByEl(chartEl);
      view.dispose();
      chartEl.remove();
      this.chartViews = _.without(this.chartViews, view); // Re-render the first chart in primary with secondaries layout.
      // The dimensions might have changed.

      var reRender = pinboardMediator.layout() === LAYOUT_PRIMARY_WITH_SECONDARIES && chartElIndex === 0;

      if (reRender) {
        var firstView = this.firstView();

        if (firstView) {
          firstView.render(true);
        }
      }
    }
  }, {
    key: "initDragAndDrop",
    value: function initDragAndDrop() {
      this.$el.on('mouseenter', '.move-chart', this.enableDragging).on('mouseleave', '.move-chart', this.disableDragging).on('dragstart', CHART_SELECTOR, this.dragstartHandler).on('dragenter', CHART_SELECTOR, this.dragenterHandler).on('dragover', CHART_SELECTOR, this.dragoverHandler).on('dragleave', CHART_SELECTOR, this.dragleaveHandler).on('dragend', CHART_SELECTOR, this.dragendHandler).on('drop', CHART_SELECTOR, this.dropHandler);
    }
  }, {
    key: "enableDragging",
    value: function enableDragging(event) {
      var link = event.currentTarget;
      var chartEl = this.closestChartEl(link);

      if (DRAGGABLE_SUPPORTED) {
        chartEl.attr('draggable', 'true');
      } else {
        // For IE, make the link draggable
        link.href = '';
      }
    }
  }, {
    key: "disableDragging",
    value: function disableDragging(event) {
      if (DRAGGABLE_SUPPORTED) {
        this.closestChartEl(event.target).removeAttr('draggable');
      }
    }
  }, {
    key: "dragstartHandler",
    value: function dragstartHandler(event) {
      var chartEl = event.currentTarget;
      this.$el.addClass(EDITOR_DRAGGING_CLASS);
      $(chartEl).addClass(CHART_DRAGGING_CLASS);
      this.dragFromElement = chartEl;
      var dataTransfer = event.originalEvent.dataTransfer;

      if (dataTransfer) {
        // Necessary for Firefox to start the drag.
        dataTransfer.setData('text', 'whatever');
        dataTransfer.effectAllowed = 'move';
        dataTransfer.dropEffect = 'move'; // Use the chart as dragged element, if supported.
        // https://developer.mozilla.org/de/docs/Web/API/DataTransfer

        if (dataTransfer.addElement) {
          var chartViewEl = this.chartViewEl(chartEl);
          dataTransfer.addElement(chartViewEl);
        }
      }
    }
  }, {
    key: "dragenterHandler",
    value: function dragenterHandler(event) {
      event.preventDefault(); // Accept dragenter

      var chartEl = $(event.currentTarget);

      if (!chartEl.hasClass(CHART_DRAGHOVER_CLASS)) {
        chartEl.addClass(CHART_DRAGHOVER_CLASS).siblings().removeClass(CHART_DRAGHOVER_CLASS);
      }
    }
  }, {
    key: "dragoverHandler",
    value: function dragoverHandler(event) {
      event.preventDefault(); // Accept dragover
    }
  }, {
    key: "dragleaveHandler",
    value: function dragleaveHandler(event) {
      if ($(event.target).hasClass(OVERLAY_CLASS)) {
        $(event.currentTarget).removeClass(CHART_DRAGHOVER_CLASS);
      }
    }
  }, {
    key: "dropHandler",
    value: function dropHandler(event) {
      event.preventDefault(); // Accept drop

      this.moveChart(this.dragFromElement, event.currentTarget);
    }
  }, {
    key: "dragendHandler",
    value: function dragendHandler() {
      this.$el.removeClass(EDITOR_DRAGGING_CLASS);
      this.chartElements().removeClass(CHART_DRAGHOVER_CLASS).removeClass(CHART_DRAGGING_CLASS);
    } // Moves a chart. Expects a chart element to move and an element
    // as insertion point.

  }, {
    key: "moveChart",
    value: function moveChart(fromElement, toElement) {
      if (fromElement === toElement) {
        return;
      }

      var fromIndex = this.chartElIndex(fromElement);
      var toIndex = this.chartElIndex(toElement); // Update model and DOM

      var charts = pinboardMediator.charts();
      var chart = charts[fromIndex];

      if (fromIndex < toIndex) {
        // Move to the right
        charts.splice(toIndex + 1, 0, chart);
        charts.splice(fromIndex, 1);
        $(fromElement).insertAfter(toElement);
      } else {
        // Move to the left
        charts.splice(toIndex, 0, chart);
        charts.splice(fromIndex + 1, 1);
        $(fromElement).insertBefore(toElement);
      } // Save changes to the model


      pinboardMediator.charts(charts); // Re-render the moved chart and the first chart in primary with
      // secondaries layout. The dimensions might have changed.

      var reRender = pinboardMediator.layout() === LAYOUT_PRIMARY_WITH_SECONDARIES && (fromIndex === 0 || toIndex === 0);

      if (reRender) {
        this.viewByEl(fromElement).render(true);

        if (fromIndex === 0) {
          this.firstView().render(true);
        } else if (toIndex === 0) {
          this.viewByEl(toElement).render(true);
        }
      }
    } // DOM helper methods
    // ------------------
    // Chart element access
    // --------------------
    // Returns all chart elements in a jQuery object.

  }, {
    key: "chartElements",
    value: function chartElements() {
      return this.$(CHART_SELECTOR);
    } // Returns the closest chart element for a given element.

  }, {
    key: "closestChartEl",
    value: function closestChartEl(el) {
      return $(el).closest(CHART_SELECTOR);
    } // Returns the index for a chart element.

  }, {
    key: "chartElIndex",
    value: function chartElIndex(el) {
      return this.chartElements().index(el);
    } // Model access
    // ------------
    // Returns the ChartData model for a chart element.

  }, {
    key: "modelByEl",
    value: function modelByEl(el) {
      var index = this.chartElIndex(el);
      return this.modelByIndex(index);
    } // Returns the ChartData model for the given index.

  }, {
    key: "modelByIndex",
    value: function modelByIndex(index) {
      return pinboardMediator.charts()[index];
    } // View access
    // -----------
    // Returns the ChartView for a chart element.
    // Expects an element or a jQuery object.

  }, {
    key: "viewByEl",
    value: function viewByEl(el) {
      var chartViewEl = this.chartViewEl(el);
      return _.find(this.chartViews, {
        el: chartViewEl
      });
    } // Returns the actual nested .ddp-chart element for a chart element.
    // Expects an element or a jQuery object.

  }, {
    key: "chartViewEl",
    value: function chartViewEl(el) {
      return $(el).find(DDP_CHART_SELECTOR).get(0);
    } // Returns the view for the first chart or false if no chart present.

  }, {
    key: "firstView",
    value: function firstView() {
      var model = pinboardMediator.charts()[0];

      if (model) {
        return _.find(this.chartViews, {
          model: model
        });
      } else {
        return false;
      }
    }
  }]);
  return PinboardEditorView;
}(BaseView);

PinboardEditorView.prototype.boundMethods = ['layoutChanged', 'share', 'editChart', 'removeChart', 'enableDragging', 'disableDragging', 'dragstartHandler', 'dropHandler', 'dragendHandler']; // Saves the chart element a drag originates from

PinboardEditorView.prototype.dragFromElement = null;
module.exports = PinboardEditorView;

},{"../i18n":82,"../models/pinboard-mediator":102,"../models/selection-mediator":112,"../util/create-template":121,"./base-view":150,"./chart-view":156,"./pinboard-share-view":168,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery","lodash":"lodash"}],168:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var I18n = require('../i18n');

var createTemplate = require('../util/create-template');

var ShareView = require('./share-view');

var PinboardShareView = /*#__PURE__*/function (_ShareView) {
  (0, _inherits2.default)(PinboardShareView, _ShareView);

  var _super = _createSuper(PinboardShareView);

  function PinboardShareView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, PinboardShareView);
    _this = _super.call(this, options);

    _this.monitorSaving();

    return _this;
  }

  (0, _createClass2.default)(PinboardShareView, [{
    key: "renderTitle",
    value: function renderTitle() {
      return this.$('.share-selection-title').text(this.title());
    } // Methods that return prepared chart information
    // ----------------------------------------------

  }, {
    key: "title",
    value: function title() {
      return I18n.t('sharing.pinboardTitle');
    }
  }]);
  return PinboardShareView;
}(ShareView); // Static properties
// -----------------


PinboardShareView.selector = '.pinboard-sharebox'; // Saving
// ------

PinboardShareView.prototype.saveStartTemplate = createTemplate("<p class=\"save-status-message\">\n<i class=\"icon-ddp-loading icon-spin\"></i>\n{{#t}}sharing.savingPinboard{{/t}}\n</p>");
module.exports = PinboardShareView;

},{"../i18n":82,"../util/create-template":121,"./share-view":172,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],169:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var $ = require('jquery');

var BaseView = require('./base-view');

var MARKER_CLASS = 'current';
/*
A ProgressMenu wraps around a list of internal links and adds a marker
class to the list item containing the reference to a page section once the
section becomes topmost in the content area.

Expects
- a `referenceTop` jQuery container in the options from which the top
  of the content area is determined,
- a `sticky` StickyElement, so that marker classes are only set when
  the StickyElement is in sticky state.
*/

var ProgressMenu = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(ProgressMenu, _BaseView);

  var _super = _createSuper(ProgressMenu);

  // Property declarations
  // ---------------------
  //
  // sticky: StickElement
  // $links: jQuery
  // sections: Array.<jQuery>
  // contentAreaOffset: Number
  // viewportWidth: Number
  // viewportHeight: Number
  // minViewportWidth: Number
  // currentSectionId: String
  function ProgressMenu(options) {
    var _this;

    (0, _classCallCheck2.default)(this, ProgressMenu);
    _this = _super.call(this, options); // Get internal links within widget's base el

    _this.$links = _this.$('a[href^="#"]'); // Get associated sections by ID

    _this.sections = _this.$links.map(function (index, el) {
      var id = el.getAttribute('href').substring(1);
      return document.getElementById(id);
    });
    _this.contentAreaOffset = options.referenceTop.outerHeight();
    _this.sticky = options.sticky; // Store for currently topmost section

    _this.currentSectionId = null;

    _this.updateViewportSize(); // Execute the handlers every x milliseconds


    var wait = 200;
    var debounceOptions = {
      maxWait: wait
    };
    _this.resizeHandler = _.debounce(_this.resizeHandler, wait, debounceOptions);
    _this.scrollHandler = _.debounce(_this.scrollHandler, wait, debounceOptions);
    $(window).resize(_this.resizeHandler).scroll(_this.scrollHandler);
    return _this;
  }

  (0, _createClass2.default)(ProgressMenu, [{
    key: "resizeHandler",
    value: function resizeHandler() {
      this.updateViewportSize();
      this.updateMenuItems();
    }
  }, {
    key: "scrollHandler",
    value: function scrollHandler() {
      this.updateMenuItems();
    }
  }, {
    key: "updateViewportSize",
    value: function updateViewportSize() {
      var $window = $(window);
      this.viewportWidth = $window.width();
      this.viewportHeight = $window.height();
      this.minViewportWidth = 768;
    }
  }, {
    key: "updateMenuItems",
    value: function updateMenuItems() {
      // Only operate in mode >= small
      if (this.viewportWidth < this.minViewportWidth) {
        return;
      } // Only operate in sticky mode


      if (!this.sticky.sticky) {
        // Remove existing marker
        if (this.currentSectionId) {
          this.removeMarker(this.currentSectionId);
          this.currentSectionId = null;
        }

        return;
      }

      var threshold = $(window).scrollTop() + this.contentAreaOffset + (this.viewportHeight - this.contentAreaOffset) / 4; // Current section is the last whose top reached content area top

      var currentSection = _.findLast(this.sections, function (el) {
        return $(el).offset().top <= threshold;
      });

      var sectionId = currentSection ? currentSection.id : null; // Nothing to do if sectionId didn't change

      if (sectionId !== this.currentSectionId) {
        if (this.currentSectionId) {
          this.removeMarker(this.currentSectionId);
        }

        if (sectionId) {
          this.addMarker(sectionId);
        }

        this.currentSectionId = sectionId;
      }
    }
  }, {
    key: "addMarker",
    value: function addMarker(id) {
      return this.linkItemById(id).addClass(MARKER_CLASS);
    }
  }, {
    key: "removeMarker",
    value: function removeMarker(id) {
      return this.linkItemById(id).removeClass(MARKER_CLASS);
    }
  }, {
    key: "linkItemById",
    value: function linkItemById(id) {
      return this.$links.filter("[href='#".concat(id, "']")).parent();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      $(window).off('resize', this.resizeHandler).off('scroll', this.scrollHandler);
      (0, _get2.default)((0, _getPrototypeOf2.default)(ProgressMenu.prototype), "dispose", this).call(this);
    }
  }]);
  return ProgressMenu;
}(BaseView);

ProgressMenu.prototype.boundMethods = ['resizeHandler', 'scrollHandler', 'updateViewportSize', 'updateMenuItems'];
module.exports = ProgressMenu;

},{"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery","lodash":"lodash"}],170:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var $ = require('jquery');

var createTemplate = require('../util/create-template');

var I18n = require('../i18n');

var SelectionMediator = require('../models/selection-mediator');

var ChartDataSchema = require('../models/chart-data-schema');

var BaseView = require('./base-view');

var templates = {
  message: createTemplate("<div class=\"alert alert-info\">\n{{>message}}\n<button class=\"alert-btn unset\">{{#t}}userMessage.remove{{/t}}</button>\n</div>"),
  simpleValue: createTemplate("<span class=\"value\">{{value}}</span>"),
  listValue: createTemplate("<ol class=\"setting-list\">\n{{#value}}\n<li class=\"setting-list-item\" data-value=\"{{.}}\">\n<a href>{{.}}</a>\n</li>\n{{/value}}\n</ol>")
};

var SelectionView = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(SelectionView, _BaseView);

  var _super = _createSuper(SelectionView);

  function SelectionView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, SelectionView);
    _this = _super.call(this, options);

    _this.$el.on('click', '.alert-btn', _this.unsetSelection);

    _this.$el.on('click', '.setting-list-item', _this.unsetItem);

    return _this;
  }

  (0, _createClass2.default)(SelectionView, [{
    key: "unsetSelection",
    value: function unsetSelection(event) {
      event.preventDefault();
      SelectionMediator.unsetSelection(this.model);
      return this.forceUpdate();
    }
  }, {
    key: "unsetItem",
    value: function unsetItem(event) {
      event.preventDefault();
      var item = $(event.currentTarget).closest('.setting-list-item').data('value');
      SelectionMediator.unsetSelection(this.model, item);
      return this.forceUpdate();
    }
  }, {
    key: "forceUpdate",
    value: function forceUpdate() {
      // Trigger reload to force reprocessing of stored selections.
      // Online updating of charts would require further listening
      // of chart models to changes in selections.
      location.reload();
    }
  }, {
    key: "render",
    value: function render() {
      var plural, singular, valuePartial;
      var _this$model = this.model,
          name = _this$model.name,
          context = _this$model.context;
      var type = ChartDataSchema[this.model.name] || 'string';
      var value = this.model.valueOf(); // Lists vs. primitives

      if (type === 'list') {
        value = _.compact(value);
        valuePartial = templates.listValue;
        singular = value.length === 1;
        plural = value.length > 1;
      } else {
        valuePartial = templates.simpleValue;
      }

      var key = "userMessage.selections.".concat(name); // Handle booleans

      if (value === true) {
        key = "".concat(key, ".true");
      } else if (value === false) {
        key = "".concat(key, ".false");
      }

      var messagePartial = createTemplate(I18n.t(key));
      return this.$el.html(templates.message.render({
        name: name,
        context: context,
        value: value,
        singular: singular,
        plural: plural
      }, {
        message: messagePartial,
        value: valuePartial
      }));
    }
  }]);
  return SelectionView;
}(BaseView);

SelectionView.prototype.boundMethods = ['unsetSelection', 'unsetItem'];
SelectionView.prototype.tagName = 'div';
module.exports = SelectionView;

},{"../i18n":82,"../models/chart-data-schema":91,"../models/selection-mediator":112,"../util/create-template":121,"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery","lodash":"lodash"}],171:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = require('lodash');

var createTemplate = require('../util/create-template');

var I18n = require('../i18n');

var SelectionMediator = require('../models/selection-mediator');

var BaseView = require('./base-view');

var SelectionView = require('./selection-view');

var template = createTemplate("<div class=\"panel-heading\">\n  {{summary}}\n  <button class=\"alert-btn unset-all\">\n    {{#t}}userMessage.removeAll{{/t}}\n  </button>\n  {{#filteredLength}}\n    <button class=\"show-btn toggle-messages\">\n      {{#t}}userMessage.show{{/t}}\n    </button>\n  {{/filteredLength}}\n</div>\n<div class=\"notifications-list panel-body\"></div>");

var SelectionsView = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(SelectionsView, _BaseView);

  var _super = _createSuper(SelectionsView);

  function SelectionsView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, SelectionsView);
    _this = _super.call(this, options);

    _this.$el.addClass('panel panel-info').on('click', '.unset-all', _this.unsetAll).on('click', '.toggle-messages', _this.toggleMessages);

    _this.render();

    return _this;
  }

  (0, _createClass2.default)(SelectionsView, [{
    key: "toggleMessages",
    value: function toggleMessages() {
      if (this.$list.is(':visible')) {
        this.$list.hide();
        this.$('.show-btn').text(I18n.t('userMessage.show'));
      } else {
        this.$list.show();
        this.$('.show-btn').text(I18n.t('userMessage.hide'));
      }
    }
  }, {
    key: "unsetAll",
    value: function unsetAll() {
      var object = this.model.get('selections');

      for (var context in object) {
        var selection = object[context];
        SelectionMediator.unsetSelection(selection);
      }

      return this.forceUpdate();
    }
  }, {
    key: "forceUpdate",
    value: function forceUpdate() {
      // Trigger reload to force reprocessing of stored selections.
      // Online updating of charts would require further listening
      // of chart models to changes in selections.
      location.reload();
    }
  }, {
    key: "render",
    value: function render() {
      // Use a different summary if all selections come from the embedded context
      var fromEmbedded = _.every(this.model.get('selections'), function (selection) {
        return selection.context === 'embedded';
      });

      var summary = I18n.t(fromEmbedded ? 'userMessage.summaryEmbeddedContext' : 'userMessage.summary');
      var filteredSelections = this.model.get('filteredSelections');

      var filteredLength = _.size(filteredSelections);

      this.$el.html(template.render({
        summary: summary,
        filteredLength: filteredLength
      })); // Render child views

      this.$list = this.$('.notifications-list');
      var object = this.model.get('filteredSelections');

      for (var name in object) {
        var model = object[name];
        var view = new SelectionView({
          model: model
        });
        this.$list.append(view.el);
        view.render();
      }
    }
  }]);
  return SelectionsView;
}(BaseView);

SelectionsView.prototype.boundMethods = ['toggleMessages', 'unsetAll'];
module.exports = SelectionsView;

},{"../i18n":82,"../models/selection-mediator":112,"../util/create-template":121,"./base-view":150,"./selection-view":170,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"lodash":"lodash"}],172:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var $ = require('jquery');

var createTemplate = require('../util/create-template');

var sharingUtil = require('../util/sharing');

var I18n = require('../i18n');

var BaseView = require('./base-view'); // Abstract class for several share views


var ShareView = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(ShareView, _BaseView);

  var _super = _createSuper(ShareView);

  // Instances properties
  // --------------------
  // Property declarations
  // ---------------------
  //
  // originalModel: ChartData
  // saveStatus: jQuery
  // setTimeout handle:
  // hideSaveStatusHandle: Number

  /**
   * @param {import('./base-view').BaseViewOptions & {
   * originalModel: import('../models/chart-data')
   * }} options
   */
  function ShareView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, ShareView);
    _this = _super.call(this, options);
    _this.originalModel = options.originalModel;
    return _this;
  }

  (0, _createClass2.default)(ShareView, [{
    key: "render",
    value: function render() {
      this.registerDOMHandlers();
      this.renderTitle();
      this.updateCodes();
      return this;
    }
  }, {
    key: "registerDOMHandlers",
    value: function registerDOMHandlers() {
      this.$el.on('click', '.share-facebook', this.shareViaFacebook).on('click', '.share-twitter', this.shareViaTwitter).on('click', '.share-email', this.shareViaEmail).on('click', '.url', this.selectURL).on('click', '.embed-code', this.selectEmbedCode).on('keyup input change', '.width', this.updateCodes).on('click', '.preview', this.preview).on('click', '.sharebox-close', this.closeOnButtonClick);
      $(document).keydown(this.closeOnEscape);
    }
  }, {
    key: "renderTitle",
    value: function renderTitle() {
      throw new Error('ShareView#renderTitle must to be overridden');
    } // Methods for getting prepared chart information
    // ----------------------------------------------

  }, {
    key: "titlePrefix",
    value: function titlePrefix() {
      return I18n.t('sharing.titlePrefix');
    }
  }, {
    key: "prefixedTitle",
    value: function prefixedTitle() {
      return "".concat(this.titlePrefix(), ": ").concat(this.title());
    }
  }, {
    key: "title",
    value: function title() {
      return this.model.title();
    }
  }, {
    key: "url",
    value: function url() {
      return this.model.url();
    } // Social media share buttons
    // --------------------------

  }, {
    key: "shareViaFacebook",
    value: function shareViaFacebook() {
      if (!this.model.id) {
        return;
      }

      sharingUtil.facebook(this.url());
    }
  }, {
    key: "shareViaTwitter",
    value: function shareViaTwitter() {
      if (!this.model.id) {
        return;
      }

      sharingUtil.twitter("".concat(this.prefixedTitle(), "\n").concat(this.url()));
    }
  }, {
    key: "shareViaEmail",
    value: function shareViaEmail() {
      if (!this.model.id) {
        return;
      }

      var subject = this.prefixedTitle();
      var body = "".concat(this.prefixedTitle(), "\n").concat(this.url());
      sharingUtil.email(subject, body);
    } // URL and embed code generation
    // -----------------------------

  }, {
    key: "updateCodes",
    value: function updateCodes() {
      if (!this.model.id) {
        return;
      }

      this.updateURL();
      this.updateEmbedCode();
    }
  }, {
    key: "updateURL",
    value: function updateURL() {
      this.$('.url').val(this.url());
    }
  }, {
    key: "updateEmbedCode",
    value: function updateEmbedCode() {
      var _this$size = this.size(),
          width = _this$size.width,
          height = _this$size.height;

      var url = this.url();
      var html = this.embedCodeTemplate.render({
        url: url,
        width: width,
        height: height,
        alternative: this.iframeAlternative()
      });
      this.$('.embed-code').val(html);
    }
  }, {
    key: "iframeAlternative",
    value: function iframeAlternative() {
      return this.prefixedTitle();
    }
  }, {
    key: "selectURL",
    value: function selectURL() {
      this.selectField(this.$('.url'));
    }
  }, {
    key: "selectEmbedCode",
    value: function selectEmbedCode() {
      this.selectField(this.$('.embed-code'));
    }
    /**
     * @param {JQuery<HTMLElement>} field
     */

  }, {
    key: "selectField",
    value: function selectField(field) {
      field.focus().select();
    } // Opens the shared URL in a popup window for preview.

  }, {
    key: "preview",
    value: function preview() {
      var url = this.url();

      var _this$size2 = this.size(),
          width = _this$size2.width,
          height = _this$size2.height;

      var options = "width=".concat(width, ",height=").concat(height, ",centerscreen");

      if (this.previewWindow) {
        this.previewWindow.close();
      }

      this.previewWindow = window.open(url, 'preview', options);

      if (this.previewWindow) {
        this.previewWindow.focus();
      }
    } // Returns the iframe size as { width, height }.
    // Calculates it from the width input field using a 4:3 ratio.

  }, {
    key: "size",
    value: function size() {
      var width = parseInt(this.$('.width').val(), 10) || this.iframeFallbackWidth;
      var height = Math.ceil(width * this.iframeAspectRatio);
      return {
        width: width,
        height: height
      };
    } // Closing the modal dialog
    // ------------------------

  }, {
    key: "closeOnEscape",
    value: function closeOnEscape(event) {
      if (event.keyCode === 27) {
        this.close();
      }
    }
  }, {
    key: "closeOnButtonClick",
    value: function closeOnButtonClick(event) {
      if (event) {
        event.preventDefault();
      }

      this.close();
    } // Remove sharebox if it is an overlay

  }, {
    key: "close",
    value: function close() {
      this.$el.remove();
      this.dispose();
    } // Saving
    // ------
    // Monitors the saving process

  }, {
    key: "monitorSaving",
    value: function monitorSaving() {
      var events = [['change:id', this.updateCodes], ['save:start', this.saveStart], ['save:success', this.saveSuccess], ['save:error', this.saveError]];

      for (var i = 0, l = events.length; i < l; i++) {
        var event = events[i];
        this.model.on(event[0], event[1], this);
      }
    } // Save start handler.
    // While saving, show an overlay that covers the right part.

  }, {
    key: "saveStart",
    value: function saveStart() {
      if (!this.saveStatus) {
        this.saveStatus = $('<div class="save-status">').appendTo(this.$('.sharebox-right'));
      }

      clearTimeout(this.hideSaveStatusHandle);
      this.saveStatus // Stop animation, reset state
      .stop(true, true).show().html(this.saveStartTemplate.render()); // Reset flash animation

      this.$('.url, .embed-code').removeClass('updated');
    } // Save success handler.
    // After successful save, hide the overlay and flash the updated fields.

  }, {
    key: "saveSuccess",
    value: function saveSuccess() {
      var _this2 = this;

      this.saveStatus.html(this.saveSuccessTemplate.render());

      var fadeOut = function fadeOut() {
        _this2.saveStatus.fadeOut();

        _this2.$('.url, .embed-code').addClass('updated');
      };

      clearTimeout(this.hideSaveStatusHandle);
      this.hideSaveStatusHandle = setTimeout(fadeOut, 500);
    } // Save error handler.
    // Shows a saving error.

  }, {
    key: "saveError",
    value: function saveError() {
      this.saveStatus.html(this.saveErrorTemplate.render());
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      if (this.previewWindow) {
        this.previewWindow.close();
      }

      $(document).off('keydown', this.closeOnEscape);
      clearTimeout(this.hideSaveStatusHandle);
      (0, _get2.default)((0, _getPrototypeOf2.default)(ShareView.prototype), "dispose", this).call(this);
    }
  }], [{
    key: "create",
    value: // Static methods
    // --------------
    // Creates an instance from a template in the DOM found by the selector
    // property. Returns the view or false.
    function create(model) {
      var template = $(this.selector).filter(':first');

      if (!template.length) {
        return false;
      }

      var $el = template.clone().css('display', 'block'); // Clone the model

      var originalModel = model;
      var clonedModel = model.clone();
      var view = new this({
        model: clonedModel,
        originalModel: originalModel,
        el: $el
      });
      view.render();
      return view;
    }
  }]);
  return ShareView;
}(BaseView); // Static properties
// -----------------


ShareView.selector = '.sharebox'; // Properties
// ----------

ShareView.prototype.boundMethods = ['shareViaFacebook', 'shareViaTwitter', 'shareViaEmail', 'updateCodes', 'updateEmbedCode', 'selectURL', 'selectEmbedCode', 'preview', 'closeOnEscape', 'closeOnButtonClick', 'close']; // Templates
// ---------

ShareView.prototype.embedCodeTemplate = createTemplate("<iframe src=\"{{url}}\" width=\"{{width}}\" height=\"{{height}}\" style=\"border: 0\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" allowfullscreen=\"true\"><a href=\"{{url}}\" target=\"_blank\">{{alternative}}</a></iframe>"); // Iframe parameters

ShareView.prototype.iframeFallbackWidth = 640;
ShareView.prototype.iframeAspectRatio = 3 / 4;
ShareView.prototype.saveStartTemplate = createTemplate("<p class=\"save-status-message\">\n  <i class=\"icon-ddp-loading icon-spin\"></i>\n  {{#t}}sharing.savingChart{{/t}}\n</p>");
ShareView.prototype.saveSuccessTemplate = createTemplate("<p class=\"save-status-message\">{{#t}}sharing.saved{{/t}}</p>");
ShareView.prototype.saveErrorTemplate = createTemplate("<span class=\"save-status-message save-status-error\">\n  {{#t}}sharing.savingError{{/t}}\n</span>"); // Disposal
// --------

ShareView.prototype.disposedProperties = ['originalModel', 'previewWindow'];
module.exports = ShareView;

},{"../i18n":82,"../util/create-template":121,"../util/sharing":137,"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery"}],173:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ShareView = require('./share-view'); // Share view on a standalone page
// Currently located at https://data.oecd.org/sharebox/ for the OECD Data Portal


var StandaloneShareView = /*#__PURE__*/function (_ShareView) {
  (0, _inherits2.default)(StandaloneShareView, _ShareView);

  var _super = _createSuper(StandaloneShareView);

  function StandaloneShareView() {
    (0, _classCallCheck2.default)(this, StandaloneShareView);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(StandaloneShareView, [{
    key: "renderTitle",
    value: // Override title logic, use the combined title attribute instead of
    // generating a title with this.model.title()
    function renderTitle() {
      this.$('.share-selection-title').text(this.title());
    }
  }, {
    key: "title",
    value: function title() {
      return this.model.get('title');
    }
  }]);
  return StandaloneShareView;
}(ShareView);

module.exports = StandaloneShareView;

},{"./share-view":172,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18}],174:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var $ = require('jquery');

var BaseView = require('./base-view'); // Creates a sticky element that gets fixed when the user scrolls past it.


var StickyElement = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(StickyElement, _BaseView);

  var _super = _createSuper(StickyElement);

  // Property declarations
  // ---------------------
  //
  // sticky: Boolean
  // retainSize: Boolean
  // initialY: Number
  // size: { width: Number, height: Number }
  // threshold: Number
  // referenceTop: jQuery
  // referenceTopHeight: Number
  // belowSticky: jQuery
  // belowStickyY: Number
  // placeholder: jQuery
  // viewportWidth: Number
  // viewportHeight: Number
  // minViewportWidth: Number
  // minViewportHeight: Number
  // scrollTop: Number
  // Options:
  // el: Element: The element that should be sticky (position: fixed)
  // fixScrollPosition: Boolean (opt): Whether to scroll a bit down
  //   automatically when jumping to anchors (URL#anchor) to reveal the
  //   content below the sticky element. Defaults to false.
  // referenceTop: Element (opt): An element the sticky should be positioned
  //   under (e.g. another StickyElement).
  // belowSticky: Element (opt): An element which clears the sticky, i.e.
  //   which is never shown below the sticky.
  // retainSize: Boolean (opt): Whether to transfer the size of the static
  //   version to the fixed version. Defaults to false.
  function StickyElement(options) {
    var _this;

    (0, _classCallCheck2.default)(this, StickyElement);
    _this = _super.call(this, options);
    var $window = $(window);
    var $document = $(document);
    _this.sticky = false; // Options

    _this.fixScrollPosition = options.fixScrollPosition || false;
    _this.retainSize = options.retainSize || false;
    var referenceTop = options.referenceTop;

    if (referenceTop && referenceTop.length) {
      _this.referenceTop = referenceTop;
    }

    var belowSticky = options.belowSticky;

    if (belowSticky && belowSticky.length) {
      _this.belowSticky = belowSticky.eq(0);
    }

    _this.placeholder = $('<div class="sticky-placeholder">');
    $window.scroll(_this.scrollHandler).resize(_this.resizeHandler);

    _this.calculatePositionsAndSizes();

    _this.setScrollY();

    _this.positionElement();

    if (_this.fixScrollPosition) {
      // Fix scroll position on document load
      _this.initialScrollFix(); // Fix scroll position on hash changes


      $document.on('click', 'a', _this.anchorClickHandler);
      $window.on('hashchange', _this.hashChangeHandler);
    }

    return _this;
  }

  (0, _createClass2.default)(StickyElement, [{
    key: "scrollHandler",
    value: function scrollHandler() {
      this.setScrollY();
      this.positionElement();
    }
  }, {
    key: "resizeHandler",
    value: function resizeHandler() {
      this.calculatePositionsAndSizes();
      this.positionElement();
    }
  }, {
    key: "setScrollY",
    value: function setScrollY() {
      this.scrollY = $(window).scrollTop();
    }
  }, {
    key: "calculatePositionsAndSizes",
    value: function calculatePositionsAndSizes() {
      // Save sticky state
      var sticky = this.sticky; // Unstick to get the original element position and size

      if (sticky) {
        this.unstick();
      }

      var el = this.$el;
      this.initialY = el.offset().top;
      this.size = {
        width: el.outerWidth(),
        height: el.outerHeight()
      };
      this.threshold = this.initialY; // Restore stickyness

      if (sticky) {
        this.stick();
      } // Get the height of the reference element


      this.referenceTopHeight = this.referenceTop ? this.referenceTop.outerHeight() : 0; // Scrolling threshold

      this.threshold -= this.referenceTopHeight; // Get position of the element below the sticky

      if (this.belowSticky) {
        this.belowStickyY = this.belowSticky.offset().top;
      } // Viewport sizes


      var $window = $(window);
      this.viewportWidth = $window.width();
      this.viewportHeight = $window.height(); // Require a mininum viewport size. The sticky doesnt get active
      // on small viewports.

      this.minViewportWidth = 768;
      this.minViewportHeight = this.size.height + this.referenceTopHeight;
    }
  }, {
    key: "positionElement",
    value: function positionElement() {
      var sticky = // Check viewport size
      this.viewportWidth >= this.minViewportWidth && this.viewportHeight >= this.minViewportHeight && // Check scroll threshold
      this.scrollY >= this.threshold && (!this.belowSticky || this.scrollY + this.referenceTopHeight + this.size.height < this.belowStickyY);

      if (sticky) {
        this.stick();
      } else {
        this.unstick();
      }
    } // Transition to sticky mode

  }, {
    key: "stick",
    value: function stick() {
      if (this.sticky) {
        return;
      }

      this.$el.addClass('fixed'); // Apply position and size

      if (this.referenceTopHeight) {
        this.$el.css({
          top: "".concat(this.referenceTopHeight, "px")
        });
      }

      if (this.retainSize) {
        this.$el.css(this.size);
      } // Insert placeholder


      this.placeholder.css(this.size).insertAfter(this.el);
      this.sticky = true;
    } // Transition to normal, non-sticky mode

  }, {
    key: "unstick",
    value: function unstick() {
      if (!this.sticky) {
        return;
      }

      this.$el.removeClass('fixed'); // Reset position and size

      if (this.referenceTopHeight) {
        this.$el.css('top', '');
      }

      if (this.retainSize) {
        this.$el.css({
          width: '',
          height: ''
        });
      } // Remove placeholder


      this.placeholder.detach();
      this.sticky = false;
    } // Scroll fix for fragment identifiers (anchors)
    // ---------------------------------------------
    // Fix initial scroll position if an anchor is present

  }, {
    key: "initialScrollFix",
    value: function initialScrollFix() {
      if (location.hash) {
        if (this.sticky) {
          window.scrollBy(0, -this.size.height);
        } else if (this.scrollY === 0) {
          // Try again once after some time. This is a browser timing issue.
          // Most browsers have scrolled to the anchor when the load
          // event fires, IE doesnt. Wait for the next scroll event.
          $(window).one('scroll', this.initialScrollFix);
        }
      }
    }
  }, {
    key: "anchorClickHandler",
    value: function anchorClickHandler(event) {
      var href = event.target.getAttribute('href');

      if (href == null || !href.match(/^#.+/)) {
        return;
      }

      if (href === location.hash) {
        // The same link was clicked again
        event.preventDefault();
        this.scrollToTarget(href);
      } else {
        // Record the scroll position so it can be restored onhashchange
        this.lastScrollPosition = $(window).scrollTop();
      }
    }
  }, {
    key: "hashChangeHandler",
    value: function hashChangeHandler() {
      if (!this.sticky) {
        return;
      }

      var _location = location,
          hash = _location.hash;

      if (hash) {
        this.scrollToTarget(hash);
      } else if (this.lastScrollPosition != null) {
        // Restore last scroll position
        window.scrollTo(0, this.lastScrollPosition);
        this.lastScrollPosition = null;
      }
    } // Scroll to an element, make sure its visible below the sticky element
    // Accepts an anchor URL '#foo'

  }, {
    key: "scrollToTarget",
    value: function scrollToTarget(href) {
      if (!this.sticky) {
        return;
      }

      var target = $(href);

      if (!target.length) {
        return;
      }

      var _target$offset = target.offset(),
          left = _target$offset.left,
          top = _target$offset.top;

      var adjustedTop = Math.ceil(top) - this.size.height;
      window.scrollTo(left, adjustedTop);
    } // Disposal
    // --------

  }, {
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return;
      }

      $(window).off('scroll', this.scrollHandler).off('resize', this.resizeHandler).off('hashchange', this.hashChangeHandler);
      $(document).off('click', 'a', this.anchorClickHandler);
      this.unstick();
      this.placeholder.remove();
      (0, _get2.default)((0, _getPrototypeOf2.default)(StickyElement.prototype), "dispose", this).call(this);
    }
  }]);
  return StickyElement;
}(BaseView);

StickyElement.prototype.boundMethods = ['scrollHandler', 'resizeHandler', 'calculatePositionsAndSizes', 'positionElement', 'initialScrollFix', 'anchorClickHandler', 'hashChangeHandler'];
module.exports = StickyElement;

},{"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"jquery":"jquery"}],175:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

require('jquery.nouislider');

var _ = require('lodash');

var createTemplate = require('../util/create-template');

var timePeriodConversion = require('../util/time-period-conversion');

var BaseView = require('./base-view');

var idToNumber = timePeriodConversion.idToNumber,
    idToNumberDetectFrequency = timePeriodConversion.idToNumberDetectFrequency,
    numberToId = timePeriodConversion.numberToId,
    longTimePeriod = timePeriodConversion.longTimePeriod; // Current time period (startTime - endTime)
// -----------------------------------------

var twoTimePeriodsTemplate = createTemplate("<span class=\"start\">{{startTime}}</span>\n<span class=\"end\">{{endTime}}</span>");

var TimeSliderView = /*#__PURE__*/function (_BaseView) {
  (0, _inherits2.default)(TimeSliderView, _BaseView);

  var _super = _createSuper(TimeSliderView);

  // Property declarations
  // ---------------------
  //
  // oneTimePeriod: Number
  //   Saves the time period when there is only one time period available.
  // timeSliderCreated: Boolean
  //   Saves whether the noUISlider was created.
  function TimeSliderView(options) {
    var _this;

    (0, _classCallCheck2.default)(this, TimeSliderView);
    _this = _super.call(this, options);
    _this.$currentTimePeriod = options.$currentTimePeriod;
    _this.availableCombinations = options.availableCombinations;
    _this.onChange = options.onChange;
    return _this;
  }

  (0, _createClass2.default)(TimeSliderView, [{
    key: "render",
    value: function render(options) {
      var _this$getSettings = this.getSettings(options.frequency),
          step = _this$getSettings.step,
          range = _this$getSettings.range,
          selectedRange = _this$getSettings.selectedRange;

      var _range = (0, _slicedToArray2.default)(range, 2),
          startRange = _range[0],
          endRange = _range[1];

      if (startRange === endRange) {
        // There is only one time period, dont show a slider at all
        this.showOneTimePeriod(startRange);
      } else {
        // There are several time periods, render the slider
        this.createOrUpdate(step, range, selectedRange);
      }
    } // Returns the current slider value
    // (start time period id and end time period id).
    // Returns { startTime: String, endTime: String }

  }, {
    key: "getValue",
    value: function getValue() {
      var endTime, startTime;
      var oneTimePeriod = this.oneTimePeriod;

      if (oneTimePeriod) {
        // There is no slider, only one time period
        startTime = oneTimePeriod;
        endTime = oneTimePeriod;
      } else {
        var _this$$el$val = this.$el.val();

        var _this$$el$val2 = (0, _slicedToArray2.default)(_this$$el$val, 2);

        startTime = _this$$el$val2[0];
        endTime = _this$$el$val2[1];
      }

      var frequency = this.model.get('frequency');
      return {
        startTime: numberToId(frequency, startTime),
        endTime: numberToId(frequency, endTime)
      };
    } // Sets the slider value and updates the label.
    // Expects startTime: Number, endTime: Number.

  }, {
    key: "setValue",
    value: function setValue(startTime, endTime) {
      if (this.oneTimePeriod) {
        return;
      }

      this.$el.val([startTime, endTime]);
      this.renderCurrentTimePeriod();
    } // Set the slider value to the actual start/end time of the model data

  }, {
    key: "setValueToActual",
    value: function setValueToActual() {
      this.setValue(this.actualStartTime(), this.actualEndTime());
    } // (De-)activates the slider

  }, {
    key: "activate",
    value: function activate(active) {
      if (active) {
        this.$el.removeAttr('disabled');
      } else {
        this.$el.attr('disabled', true);
      }
    } // Private methods
    // ---------------
    // Settings for the noUiSlider
    //
    // This method is called at least two times:
    // 1. data available, metadata not available
    // 2. data available, metadata available
    //
    // First it returns the range of the data,
    // then it returns the full available range.
    //
    // Returns an object: {
    //   step: Number,
    //   range: [ start: Number, end: Number ],
    //   selectedRange: [ start: Number, end: Number ]
    // }

  }, {
    key: "getSettings",
    value: function getSettings(frequency) {
      // Actual start and end time
      var firstTimePeriod, lastTimePeriod;
      var startTime = this.actualStartTime();
      var endTime = this.actualEndTime(); // Applicable time periods from metadata
      // Returns false if metadata isnt available yet

      var timePeriods = this.availableCombinations.timePeriodsForFrequency(frequency);

      if (timePeriods && timePeriods.length) {
        firstTimePeriod = idToNumber(frequency, timePeriods[0].id);
        lastTimePeriod = idToNumber(frequency, _.last(timePeriods).id);
      } // Step


      var step = timePeriodConversion.numberStep(frequency); // Full range

      var rangeStart = firstTimePeriod || startTime;
      var rangeEnd = lastTimePeriod || endTime; // Selected range

      var selectedRangeStart = startTime;
      var selectedRangeEnd = endTime; // Ensure the selection is in the range

      if (selectedRangeStart < rangeStart) {
        selectedRangeStart = rangeStart;
      }

      if (selectedRangeEnd > rangeEnd) {
        selectedRangeEnd = rangeEnd;
      }

      var range = [rangeStart, rangeEnd];
      var selectedRange = [selectedRangeStart, selectedRangeEnd];
      return {
        step: step,
        range: range,
        selectedRange: selectedRange
      };
    } // Mode: One time period, no slider
    // --------------------------------
    // Expects a number

  }, {
    key: "showOneTimePeriod",
    value: function showOneTimePeriod(timePeriod) {
      this.oneTimePeriod = timePeriod;
      this.destroy();
      this.renderCurrentTimePeriod();
    } // Mode: Multiple time periods, show slider
    // ----------------------------------------

  }, {
    key: "createOrUpdate",
    value: function createOrUpdate(step, range, selectedRange) {
      delete this.oneTimePeriod;
      this.$el.show();

      if (this.timeSliderCreated) {
        this.update(step, range, selectedRange);
      } else {
        this.create(step, range, selectedRange);
      }

      this.renderCurrentTimePeriod();
    } // Creates a slider from scratch

  }, {
    key: "create",
    value: function create(step, range, selectedRange) {
      // http://refreshless.com/nouislider/slider-options
      this.$el.noUiSlider({
        step: step,
        range: {
          min: range[0],
          max: range[1]
        },
        start: selectedRange,
        behaviour: 'tap-drag',
        connect: true
      }).on('slide', this.renderCurrentTimePeriod).on('change', this.renderCurrentTimePeriod).on('change', this.onChange);
      this.timeSliderCreated = true;
    } // Updates existing slider

  }, {
    key: "update",
    value: function update(step, range, selectedRange) {
      // http://refreshless.com/nouislider/update-range-slider
      this.$el.noUiSlider({
        step: step,
        range: {
          min: range[0],
          max: range[1]
        },
        start: selectedRange
      }, // rebuild:
      true);
    } // Destroys the slider properly

  }, {
    key: "destroy",
    value: function destroy() {
      var el = this.$el.hide().get(0);
      if (el.destroy) el.destroy();
      this.timeSliderCreated = false;
    } // Returns the actual start time as a Number.

  }, {
    key: "actualStartTime",
    value: function actualStartTime() {
      return idToNumberDetectFrequency(this.model.actualStartTime().id);
    } // Returns the actual end time as a Number.

  }, {
    key: "actualEndTime",
    value: function actualEndTime() {
      return idToNumberDetectFrequency(this.model.actualEndTime().id);
    } // Renders the current time selection. Either one or two time periods.

  }, {
    key: "renderCurrentTimePeriod",
    value: function renderCurrentTimePeriod() {
      var frequency = this.model.get('frequency'); // Label formatting

      var timeSliderValue = _.mapValues(this.getValue(), function (timePeriod) {
        return longTimePeriod(frequency, timePeriod);
      });

      var html = timeSliderValue.startTime === timeSliderValue.endTime ? // One time period
      timeSliderValue.startTime : // Two time periods
      twoTimePeriodsTemplate.render(timeSliderValue);
      this.$currentTimePeriod.html(html);
    }
  }]);
  return TimeSliderView;
}(BaseView);

TimeSliderView.prototype.boundMethods = ['renderCurrentTimePeriod'];
TimeSliderView.prototype.timeSliderCreated = false;
module.exports = TimeSliderView;

},{"../util/create-template":121,"../util/time-period-conversion":141,"./base-view":150,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":18,"@babel/runtime/helpers/slicedToArray":20,"jquery.nouislider":"jquery.nouislider","lodash":"lodash"}],"backbone":[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

//     Backbone.js 1.1.2
// Changed by Mathias Schfer, 9elements:
// Modified version that only contains Backbone.Events, Backbone.Model and
// its dependencies.
// Backbone.View, Backbone.sync, Backbone.Router and Backbone.History
// are commented-out.
// The sync methods of the Model are commented-out, too.
// UMD definition removed in favor of CommonJS.
// (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
// Backbone may be freely distributed under the MIT license.
// For all details and documentation:
// http://backbonejs.org
var _ = require('underscore');

var $ = require('jquery');

var Backbone = {}; // Initial Setup
// -------------
// Save the previous value of the `Backbone` variable, so that it can be
// restored later on, if `noConflict` is used.

/*
var previousBackbone = root.Backbone;
*/
// Create local references to array methods we'll want to use later.

var array = []; // var push = array.push;

var slice = array.slice; // var splice = array.splice;
// Current version of the library. Keep in sync with `package.json`.

Backbone.VERSION = '1.1.2'; // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
// the `$` variable.

Backbone.$ = $;
/*
// Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
// to its previous owner. Returns a reference to this Backbone object.
Backbone.noConflict = function() {
  root.Backbone = previousBackbone;
  return this;
};

// Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
// will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
// set a `X-Http-Method-Override` header.
Backbone.emulateHTTP = false;

// Turn on `emulateJSON` to support legacy servers that can't deal with direct
// `application/json` requests ... will encode the body as
// `application/x-www-form-urlencoded` instead and will send the model in a
// form param named `model`.
Backbone.emulateJSON = false;
*/
// Backbone.Events
// ---------------
// A module that can be mixed in to *any object* in order to provide it with
// custom events. You may bind with `on` or remove with `off` callback
// functions to an event; `trigger`-ing an event fires all callbacks in
// succession.
//
//     var object = {};
//     _.extend(object, Backbone.Events);
//     object.on('expand', function(){ alert('expanded'); });
//     object.trigger('expand');
//

var Events = Backbone.Events = {
  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  on: function on(name, callback, context) {
    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
    this._events || (this._events = {});
    var events = this._events[name] || (this._events[name] = []);
    events.push({
      callback: callback,
      context: context,
      ctx: context || this
    });
    return this;
  },
  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, it will be removed.
  once: function once(name, callback, context) {
    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
    var self = this;

    var once = _.once(function () {
      self.off(name, once);
      callback.apply(this, arguments);
    });

    once._callback = callback;
    return this.on(name, once, context);
  },
  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  off: function off(name, callback, context) {
    var retain, ev, events, names, i, l, j, k;
    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;

    if (!name && !callback && !context) {
      this._events = void 0;
      return this;
    }

    names = name ? [name] : _.keys(this._events);

    for (i = 0, l = names.length; i < l; i++) {
      name = names[i];

      if (events = this._events[name]) {
        this._events[name] = retain = [];

        if (callback || context) {
          for (j = 0, k = events.length; j < k; j++) {
            ev = events[j];

            if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
              retain.push(ev);
            }
          }
        }

        if (!retain.length) delete this._events[name];
      }
    }

    return this;
  },
  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  trigger: function trigger(name) {
    if (!this._events) return this;
    var args = slice.call(arguments, 1);
    if (!eventsApi(this, 'trigger', name, args)) return this;
    var events = this._events[name];
    var allEvents = this._events.all;
    if (events) triggerEvents(events, args);
    if (allEvents) triggerEvents(allEvents, arguments);
    return this;
  },
  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  stopListening: function stopListening(obj, name, callback) {
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;
    var remove = !name && !callback;
    if (!callback && (0, _typeof2.default)(name) === 'object') callback = this;
    if (obj) (listeningTo = {})[obj._listenId] = obj;

    for (var id in listeningTo) {
      obj = listeningTo[id];
      obj.off(name, callback, this);
      if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
    }

    return this;
  }
}; // Regular expression used to split event strings.

var eventSplitter = /\s+/; // Implement fancy features of the Events API such as multiple event
// names `"change blur"` and jQuery-style event maps `{change: action}`
// in terms of the existing API.

var eventsApi = function eventsApi(obj, action, name, rest) {
  if (!name) return true; // Handle event maps.

  if ((0, _typeof2.default)(name) === 'object') {
    for (var key in name) {
      obj[action].apply(obj, [key, name[key]].concat(rest));
    }

    return false;
  } // Handle space separated event names.


  if (eventSplitter.test(name)) {
    var names = name.split(eventSplitter);

    for (var i = 0, l = names.length; i < l; i++) {
      obj[action].apply(obj, [names[i]].concat(rest));
    }

    return false;
  }

  return true;
}; // A difficult-to-believe, but optimized internal dispatch function for
// triggering events. Tries to keep the usual cases speedy (most internal
// Backbone events have 3 arguments).


var triggerEvents = function triggerEvents(events, args) {
  var ev,
      i = -1,
      l = events.length,
      a1 = args[0],
      a2 = args[1],
      a3 = args[2];

  switch (args.length) {
    case 0:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx);
      }

      return;

    case 1:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx, a1);
      }

      return;

    case 2:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx, a1, a2);
      }

      return;

    case 3:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
      }

      return;

    default:
      while (++i < l) {
        (ev = events[i]).callback.apply(ev.ctx, args);
      }

      return;
  }
};

var listenMethods = {
  listenTo: 'on',
  listenToOnce: 'once'
}; // Inversion-of-control versions of `on` and `once`. Tell *this* object to
// listen to an event in another object ... keeping track of what it's
// listening to.

_.each(listenMethods, function (implementation, method) {
  Events[method] = function (obj, name, callback) {
    var listeningTo = this._listeningTo || (this._listeningTo = {});

    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));

    listeningTo[id] = obj;
    if (!callback && (0, _typeof2.default)(name) === 'object') callback = this;
    obj[implementation](name, callback, this);
    return this;
  };
}); // Aliases for backwards compatibility.


Events.bind = Events.on;
Events.unbind = Events.off; // Allow the `Backbone` object to serve as a global event bus, for folks who
// want global "pubsub" in a convenient place.

_.extend(Backbone, Events); // Backbone.Model
// --------------
// Backbone **Models** are the basic data object in the framework --
// frequently representing a row in a table in a database on your server.
// A discrete chunk of data and a bunch of useful, related methods for
// performing computations and transformations on that data.
// Create a new model with the specified attributes. A client id (`cid`)
// is automatically generated and assigned for you.


var Model = Backbone.Model = function (attributes, options) {
  var attrs = attributes || {};
  options || (options = {});
  this.cid = _.uniqueId('c');
  this.attributes = {};
  if (options.collection) this.collection = options.collection;
  if (options.parse) attrs = this.parse(attrs, options) || {};
  attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
  this.set(attrs, options);
  this.changed = {};
  this.initialize.apply(this, arguments);
}; // Attach all inheritable methods to the Model prototype.


_.extend(Model.prototype, Events, {
  // A hash of attributes whose current and previous value differ.
  changed: null,
  // The value returned during the last failed validation.
  validationError: null,
  // The default name for the JSON `id` attribute is `"id"`. MongoDB and
  // CouchDB users may want to set this to `"_id"`.
  idAttribute: 'id',
  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function initialize() {},
  // Return a copy of the model's `attributes` object.
  toJSON: function toJSON(options) {
    return _.clone(this.attributes);
  },

  /*
    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },
  */
  // Get the value of an attribute.
  get: function get(attr) {
    return this.attributes[attr];
  },
  // Get the HTML-escaped value of an attribute.
  escape: function escape(attr) {
    return _.escape(this.get(attr));
  },
  // Returns `true` if the attribute contains a value that is not null
  // or undefined.
  has: function has(attr) {
    return this.get(attr) != null;
  },
  // Set a hash of model attributes on the object, firing `"change"`. This is
  // the core primitive operation of a model, updating the data and notifying
  // anyone who needs to know about the change in state. The heart of the beast.
  set: function set(key, val, options) {
    var attr, attrs, unset, changes, silent, changing, prev, current;
    if (key == null) return this; // Handle both `"key", value` and `{key: value}` -style arguments.

    if ((0, _typeof2.default)(key) === 'object') {
      attrs = key;
      options = val;
    } else {
      (attrs = {})[key] = val;
    }

    options || (options = {}); // Run validation.

    if (!this._validate(attrs, options)) return false; // Extract attributes and options.

    unset = options.unset;
    silent = options.silent;
    changes = [];
    changing = this._changing;
    this._changing = true;

    if (!changing) {
      this._previousAttributes = _.clone(this.attributes);
      this.changed = {};
    }

    current = this.attributes, prev = this._previousAttributes; // Check for changes of `id`.

    if (this.idAttribute in attrs) this.id = attrs[this.idAttribute]; // For each `set` attribute, update or delete the current value.

    for (attr in attrs) {
      val = attrs[attr];
      if (!_.isEqual(current[attr], val)) changes.push(attr);

      if (!_.isEqual(prev[attr], val)) {
        this.changed[attr] = val;
      } else {
        delete this.changed[attr];
      }

      unset ? delete current[attr] : current[attr] = val;
    } // Trigger all relevant attribute changes.


    if (!silent) {
      if (changes.length) this._pending = options;

      for (var i = 0, l = changes.length; i < l; i++) {
        this.trigger('change:' + changes[i], this, current[changes[i]], options);
      }
    } // You might be wondering why there's a `while` loop here. Changes can
    // be recursively nested within `"change"` events.


    if (changing) return this;

    if (!silent) {
      while (this._pending) {
        options = this._pending;
        this._pending = false;
        this.trigger('change', this, options);
      }
    }

    this._pending = false;
    this._changing = false;
    return this;
  },
  // Remove an attribute from the model, firing `"change"`. `unset` is a noop
  // if the attribute doesn't exist.
  unset: function unset(attr, options) {
    return this.set(attr, void 0, _.extend({}, options, {
      unset: true
    }));
  },
  // Clear all attributes on the model, firing `"change"`.
  clear: function clear(options) {
    var attrs = {};

    for (var key in this.attributes) {
      attrs[key] = void 0;
    }

    return this.set(attrs, _.extend({}, options, {
      unset: true
    }));
  },
  // Determine if the model has changed since the last `"change"` event.
  // If you specify an attribute name, determine if that attribute has changed.
  hasChanged: function hasChanged(attr) {
    if (attr == null) return !_.isEmpty(this.changed);
    return _.has(this.changed, attr);
  },
  // Return an object containing all the attributes that have changed, or
  // false if there are no changed attributes. Useful for determining what
  // parts of a view need to be updated and/or what attributes need to be
  // persisted to the server. Unset attributes will be set to undefined.
  // You can also pass an attributes object to diff against the model,
  // determining if there *would be* a change.
  changedAttributes: function changedAttributes(diff) {
    if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
    var val,
        changed = false;
    var old = this._changing ? this._previousAttributes : this.attributes;

    for (var attr in diff) {
      if (_.isEqual(old[attr], val = diff[attr])) continue;
      (changed || (changed = {}))[attr] = val;
    }

    return changed;
  },
  // Get the previous value of an attribute, recorded at the time the last
  // `"change"` event was fired.
  previous: function previous(attr) {
    if (attr == null || !this._previousAttributes) return null;
    return this._previousAttributes[attr];
  },
  // Get all of the attributes of the model at the time of the previous
  // `"change"` event.
  previousAttributes: function previousAttributes() {
    return _.clone(this._previousAttributes);
  },

  /*
    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },
  
    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;
  
      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }
  
      options = _.extend({validate: true}, options);
  
      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }
  
      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }
  
      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
  
      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);
  
      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;
  
      return xhr;
    },
  
    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
  
      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };
  
      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };
  
      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);
  
      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },
  
    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },
  
    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },
  */
  // Create a new model with identical attributes to this one.
  clone: function clone() {
    return new this.constructor(this.attributes);
  },
  // A model is new if it has never been saved to the server, and lacks an id.
  isNew: function isNew() {
    return !this.has(this.idAttribute);
  },
  // Check if the model is currently in a valid state.
  isValid: function isValid(options) {
    return this._validate({}, _.extend(options || {}, {
      validate: true
    }));
  },
  // Run validation against the next complete set of model attributes,
  // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
  _validate: function _validate(attrs, options) {
    if (!options.validate || !this.validate) return true;
    attrs = _.extend({}, this.attributes, attrs);
    var error = this.validationError = this.validate(attrs, options) || null;
    if (!error) return true;
    this.trigger('invalid', this, error, _.extend(options, {
      validationError: error
    }));
    return false;
  }
}); // Underscore methods that we want to implement on the Model.


var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit']; // Mix in each Underscore method as a proxy to `Model#attributes`.

_.each(modelMethods, function (method) {
  Model.prototype[method] = function () {
    var args = slice.call(arguments);
    args.unshift(this.attributes);
    return _[method].apply(_, args);
  };
});
/*
// Backbone.Collection
// -------------------

// If models tend to represent a single row of data, a Backbone Collection is
// more analagous to a table full of data ... or a small slice or page of that
// table, or a collection of rows that belong together for a particular reason
// -- all of the messages in this particular folder, all of the documents
// belonging to this particular author, and so on. Collections maintain
// indexes of their models, both in order, and for lookup by `id`.

// Create a new **Collection**, perhaps to contain a specific type of `model`.
// If a `comparator` is specified, the Collection will maintain
// its models in sort order, as they're added and removed.
var Collection = Backbone.Collection = function(models, options) {
  options || (options = {});
  if (options.model) this.model = options.model;
  if (options.comparator !== void 0) this.comparator = options.comparator;
  this._reset();
  this.initialize.apply(this, arguments);
  if (models) this.reset(models, _.extend({silent: true}, options));
};

// Default options for `Collection#set`.
var setOptions = {add: true, remove: true, merge: true};
var addOptions = {add: true, remove: false};

// Define the Collection's inheritable methods.
_.extend(Collection.prototype, Events, {

  // The default model for a collection is just a **Backbone.Model**.
  // This should be overridden in most cases.
  model: Model,

  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function(){},

  // The JSON representation of a Collection is an array of the
  // models' attributes.
  toJSON: function(options) {
    return this.map(function(model){ return model.toJSON(options); });
  },

  // Proxy `Backbone.sync` by default.
  sync: function() {
    return Backbone.sync.apply(this, arguments);
  },

  // Add a model, or list of models to the set.
  add: function(models, options) {
    return this.set(models, _.extend({merge: false}, options, addOptions));
  },

  // Remove a model, or a list of models from the set.
  remove: function(models, options) {
    var singular = !_.isArray(models);
    models = singular ? [models] : _.clone(models);
    options || (options = {});
    var i, l, index, model;
    for (i = 0, l = models.length; i < l; i++) {
      model = models[i] = this.get(models[i]);
      if (!model) continue;
      delete this._byId[model.id];
      delete this._byId[model.cid];
      index = this.indexOf(model);
      this.models.splice(index, 1);
      this.length--;
      if (!options.silent) {
        options.index = index;
        model.trigger('remove', model, this, options);
      }
      this._removeReference(model, options);
    }
    return singular ? models[0] : models;
  },

  // Update a collection by `set`-ing a new list of models, adding new ones,
  // removing models that are no longer present, and merging models that
  // already exist in the collection, as necessary. Similar to **Model#set**,
  // the core operation for updating the data contained by the collection.
  set: function(models, options) {
    options = _.defaults({}, options, setOptions);
    if (options.parse) models = this.parse(models, options);
    var singular = !_.isArray(models);
    models = singular ? (models ? [models] : []) : _.clone(models);
    var i, l, id, model, attrs, existing, sort;
    var at = options.at;
    var targetModel = this.model;
    var sortable = this.comparator && (at == null) && options.sort !== false;
    var sortAttr = _.isString(this.comparator) ? this.comparator : null;
    var toAdd = [], toRemove = [], modelMap = {};
    var add = options.add, merge = options.merge, remove = options.remove;
    var order = !sortable && add && remove ? [] : false;

    // Turn bare objects into model references, and prevent invalid models
    // from being added.
    for (i = 0, l = models.length; i < l; i++) {
      attrs = models[i] || {};
      if (attrs instanceof Model) {
        id = model = attrs;
      } else {
        id = attrs[targetModel.prototype.idAttribute || 'id'];
      }

      // If a duplicate is found, prevent it from being added and
      // optionally merge it into the existing model.
      if (existing = this.get(id)) {
        if (remove) modelMap[existing.cid] = true;
        if (merge) {
          attrs = attrs === model ? model.attributes : attrs;
          if (options.parse) attrs = existing.parse(attrs, options);
          existing.set(attrs, options);
          if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
        }
        models[i] = existing;

      // If this is a new, valid model, push it to the `toAdd` list.
      } else if (add) {
        model = models[i] = this._prepareModel(attrs, options);
        if (!model) continue;
        toAdd.push(model);
        this._addReference(model, options);
      }

      // Do not add multiple models with the same `id`.
      model = existing || model;
      if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
      modelMap[model.id] = true;
    }

    // Remove nonexistent models if appropriate.
    if (remove) {
      for (i = 0, l = this.length; i < l; ++i) {
        if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
      }
      if (toRemove.length) this.remove(toRemove, options);
    }

    // See if sorting is needed, update `length` and splice in new models.
    if (toAdd.length || (order && order.length)) {
      if (sortable) sort = true;
      this.length += toAdd.length;
      if (at != null) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          this.models.splice(at + i, 0, toAdd[i]);
        }
      } else {
        if (order) this.models.length = 0;
        var orderedModels = order || toAdd;
        for (i = 0, l = orderedModels.length; i < l; i++) {
          this.models.push(orderedModels[i]);
        }
      }
    }

    // Silently sort the collection if appropriate.
    if (sort) this.sort({silent: true});

    // Unless silenced, it's time to fire all appropriate add/sort events.
    if (!options.silent) {
      for (i = 0, l = toAdd.length; i < l; i++) {
        (model = toAdd[i]).trigger('add', model, this, options);
      }
      if (sort || (order && order.length)) this.trigger('sort', this, options);
    }

    // Return the added (or merged) model (or models).
    return singular ? models[0] : models;
  },

  // When you have more items than you want to add or remove individually,
  // you can reset the entire set with a new list of models, without firing
  // any granular `add` or `remove` events. Fires `reset` when finished.
  // Useful for bulk operations and optimizations.
  reset: function(models, options) {
    options || (options = {});
    for (var i = 0, l = this.models.length; i < l; i++) {
      this._removeReference(this.models[i], options);
    }
    options.previousModels = this.models;
    this._reset();
    models = this.add(models, _.extend({silent: true}, options));
    if (!options.silent) this.trigger('reset', this, options);
    return models;
  },

  // Add a model to the end of the collection.
  push: function(model, options) {
    return this.add(model, _.extend({at: this.length}, options));
  },

  // Remove a model from the end of the collection.
  pop: function(options) {
    var model = this.at(this.length - 1);
    this.remove(model, options);
    return model;
  },

  // Add a model to the beginning of the collection.
  unshift: function(model, options) {
    return this.add(model, _.extend({at: 0}, options));
  },

  // Remove a model from the beginning of the collection.
  shift: function(options) {
    var model = this.at(0);
    this.remove(model, options);
    return model;
  },

  // Slice out a sub-array of models from the collection.
  slice: function() {
    return slice.apply(this.models, arguments);
  },

  // Get a model from the set by id.
  get: function(obj) {
    if (obj == null) return void 0;
    return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
  },

  // Get the model at the given index.
  at: function(index) {
    return this.models[index];
  },

  // Return models with matching attributes. Useful for simple cases of
  // `filter`.
  where: function(attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return this[first ? 'find' : 'filter'](function(model) {
      for (var key in attrs) {
        if (attrs[key] !== model.get(key)) return false;
      }
      return true;
    });
  },

  // Return the first model with matching attributes. Useful for simple cases
  // of `find`.
  findWhere: function(attrs) {
    return this.where(attrs, true);
  },

  // Force the collection to re-sort itself. You don't need to call this under
  // normal circumstances, as the set will maintain sort order as each item
  // is added.
  sort: function(options) {
    if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
    options || (options = {});

    // Run sort based on type of `comparator`.
    if (_.isString(this.comparator) || this.comparator.length === 1) {
      this.models = this.sortBy(this.comparator, this);
    } else {
      this.models.sort(_.bind(this.comparator, this));
    }

    if (!options.silent) this.trigger('sort', this, options);
    return this;
  },

  // Pluck an attribute from each model in the collection.
  pluck: function(attr) {
    return _.invoke(this.models, 'get', attr);
  },

  // Fetch the default set of models for this collection, resetting the
  // collection when they arrive. If `reset: true` is passed, the response
  // data will be passed through the `reset` method instead of `set`.
  fetch: function(options) {
    options = options ? _.clone(options) : {};
    if (options.parse === void 0) options.parse = true;
    var success = options.success;
    var collection = this;
    options.success = function(resp) {
      var method = options.reset ? 'reset' : 'set';
      collection[method](resp, options);
      if (success) success(collection, resp, options);
      collection.trigger('sync', collection, resp, options);
    };
    wrapError(this, options);
    return this.sync('read', this, options);
  },

  // Create a new instance of a model in this collection. Add the model to the
  // collection immediately, unless `wait: true` is passed, in which case we
  // wait for the server to agree.
  create: function(model, options) {
    options = options ? _.clone(options) : {};
    if (!(model = this._prepareModel(model, options))) return false;
    if (!options.wait) this.add(model, options);
    var collection = this;
    var success = options.success;
    options.success = function(model, resp) {
      if (options.wait) collection.add(model, options);
      if (success) success(model, resp, options);
    };
    model.save(null, options);
    return model;
  },

  // **parse** converts a response into a list of models to be added to the
  // collection. The default implementation is just to pass it through.
  parse: function(resp, options) {
    return resp;
  },

  // Create a new collection with an identical list of models as this one.
  clone: function() {
    return new this.constructor(this.models);
  },

  // Private method to reset all internal state. Called when the collection
  // is first initialized or reset.
  _reset: function() {
    this.length = 0;
    this.models = [];
    this._byId  = {};
  },

  // Prepare a hash of attributes (or other model) to be added to this
  // collection.
  _prepareModel: function(attrs, options) {
    if (attrs instanceof Model) return attrs;
    options = options ? _.clone(options) : {};
    options.collection = this;
    var model = new this.model(attrs, options);
    if (!model.validationError) return model;
    this.trigger('invalid', this, model.validationError, options);
    return false;
  },

  // Internal method to create a model's ties to a collection.
  _addReference: function(model, options) {
    this._byId[model.cid] = model;
    if (model.id != null) this._byId[model.id] = model;
    if (!model.collection) model.collection = this;
    model.on('all', this._onModelEvent, this);
  },

  // Internal method to sever a model's ties to a collection.
  _removeReference: function(model, options) {
    if (this === model.collection) delete model.collection;
    model.off('all', this._onModelEvent, this);
  },

  // Internal method called every time a model in the set fires an event.
  // Sets need to update their indexes when models change ids. All other
  // events simply proxy through. "add" and "remove" events that originate
  // in other collections are ignored.
  _onModelEvent: function(event, model, collection, options) {
    if ((event === 'add' || event === 'remove') && collection !== this) return;
    if (event === 'destroy') this.remove(model, options);
    if (model && event === 'change:' + model.idAttribute) {
      delete this._byId[model.previous(model.idAttribute)];
      if (model.id != null) this._byId[model.id] = model;
    }
    this.trigger.apply(this, arguments);
  }

});

// Underscore methods that we want to implement on the Collection.
// 90% of the core usefulness of Backbone Collections is actually implemented
// right here:
var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
  'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
  'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
  'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
  'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
  'lastIndexOf', 'isEmpty', 'chain', 'sample'];

// Mix in each Underscore method as a proxy to `Collection#models`.
_.each(methods, function(method) {
  Collection.prototype[method] = function() {
    var args = slice.call(arguments);
    args.unshift(this.models);
    return _[method].apply(_, args);
  };
});

// Underscore methods that take a property name as an argument.
var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

// Use attributes instead of properties.
_.each(attributeMethods, function(method) {
  Collection.prototype[method] = function(value, context) {
    var iterator = _.isFunction(value) ? value : function(model) {
      return model.get(value);
    };
    return _[method](this.models, iterator, context);
  };
});

// Backbone.View
// -------------

// Backbone Views are almost more convention than they are actual code. A View
// is simply a JavaScript object that represents a logical chunk of UI in the
// DOM. This might be a single item, an entire list, a sidebar or panel, or
// even the surrounding frame which wraps your whole app. Defining a chunk of
// UI as a **View** allows you to define your DOM events declaratively, without
// having to worry about render order ... and makes it easy for the view to
// react to specific changes in the state of your models.

// Creating a Backbone.View creates its initial element outside of the DOM,
// if an existing element is not provided...
var View = Backbone.View = function(options) {
  this.cid = _.uniqueId('view');
  options || (options = {});
  _.extend(this, _.pick(options, viewOptions));
  this._ensureElement();
  this.initialize.apply(this, arguments);
  this.delegateEvents();
};

// Cached regex to split keys for `delegate`.
var delegateEventSplitter = /^(\S+)\s*(.*)$/;

// List of view options to be merged as properties.
var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

// Set up all inheritable **Backbone.View** properties and methods.
_.extend(View.prototype, Events, {

  // The default `tagName` of a View's element is `"div"`.
  tagName: 'div',

  // jQuery delegate for element lookup, scoped to DOM elements within the
  // current view. This should be preferred to global lookups where possible.
  $: function(selector) {
    return this.$el.find(selector);
  },

  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function(){},

  // **render** is the core function that your view should override, in order
  // to populate its element (`this.el`), with the appropriate HTML. The
  // convention is for **render** to always return `this`.
  render: function() {
    return this;
  },

  // Remove this view by taking the element out of the DOM, and removing any
  // applicable Backbone.Events listeners.
  remove: function() {
    this.$el.remove();
    this.stopListening();
    return this;
  },

  // Change the view's element (`this.el` property), including event
  // re-delegation.
  setElement: function(element, delegate) {
    if (this.$el) this.undelegateEvents();
    this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
    this.el = this.$el[0];
    if (delegate !== false) this.delegateEvents();
    return this;
  },

  // Set callbacks, where `this.events` is a hash of
  //
  // *{"event selector": "callback"}*
  //
  //     {
  //       'mousedown .title':  'edit',
  //       'click .button':     'save',
  //       'click .open':       function(e) { ... }
  //     }
  //
  // pairs. Callbacks will be bound to the view, with `this` set properly.
  // Uses event delegation for efficiency.
  // Omitting the selector binds the event to `this.el`.
  // This only works for delegate-able events: not `focus`, `blur`, and
  // not `change`, `submit`, and `reset` in Internet Explorer.
  delegateEvents: function(events) {
    if (!(events || (events = _.result(this, 'events')))) return this;
    this.undelegateEvents();
    for (var key in events) {
      var method = events[key];
      if (!_.isFunction(method)) method = this[events[key]];
      if (!method) continue;

      var match = key.match(delegateEventSplitter);
      var eventName = match[1], selector = match[2];
      method = _.bind(method, this);
      eventName += '.delegateEvents' + this.cid;
      if (selector === '') {
        this.$el.on(eventName, method);
      } else {
        this.$el.on(eventName, selector, method);
      }
    }
    return this;
  },

  // Clears all callbacks previously bound to the view with `delegateEvents`.
  // You usually don't need to use this, but may wish to if you have multiple
  // Backbone views attached to the same DOM element.
  undelegateEvents: function() {
    this.$el.off('.delegateEvents' + this.cid);
    return this;
  },

  // Ensure that the View has a DOM element to render into.
  // If `this.el` is a string, pass it through `$()`, take the first
  // matching element, and re-assign it to `el`. Otherwise, create
  // an element from the `id`, `className` and `tagName` properties.
  _ensureElement: function() {
    if (!this.el) {
      var attrs = _.extend({}, _.result(this, 'attributes'));
      if (this.id) attrs.id = _.result(this, 'id');
      if (this.className) attrs['class'] = _.result(this, 'className');
      var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
      this.setElement($el, false);
    } else {
      this.setElement(_.result(this, 'el'), false);
    }
  }

});

// Backbone.sync
// -------------

// Override this function to change the manner in which Backbone persists
// models to the server. You will be passed the type of request, and the
// model in question. By default, makes a RESTful Ajax request
// to the model's `url()`. Some possible customizations could be:
//
// * Use `setTimeout` to batch rapid-fire updates into a single request.
// * Send up the models as XML instead of JSON.
// * Persist models via WebSockets instead of Ajax.
//
// Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
// as `POST`, with a `_method` parameter containing the true HTTP method,
// as well as all requests with the body as `application/x-www-form-urlencoded`
// instead of `application/json` with the model in a param named `model`.
// Useful when interfacing with server-side languages like **PHP** that make
// it difficult to read the body of `PUT` requests.
Backbone.sync = function(method, model, options) {
  var type = methodMap[method];

  // Default options, unless specified.
  _.defaults(options || (options = {}), {
    emulateHTTP: Backbone.emulateHTTP,
    emulateJSON: Backbone.emulateJSON
  });

  // Default JSON-request options.
  var params = {type: type, dataType: 'json'};

  // Ensure that we have a URL.
  if (!options.url) {
    params.url = _.result(model, 'url') || urlError();
  }

  // Ensure that we have the appropriate request data.
  if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
    params.contentType = 'application/json';
    params.data = JSON.stringify(options.attrs || model.toJSON(options));
  }

  // For older servers, emulate JSON by encoding the request into an HTML-form.
  if (options.emulateJSON) {
    params.contentType = 'application/x-www-form-urlencoded';
    params.data = params.data ? {model: params.data} : {};
  }

  // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
  // And an `X-HTTP-Method-Override` header.
  if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
    params.type = 'POST';
    if (options.emulateJSON) params.data._method = type;
    var beforeSend = options.beforeSend;
    options.beforeSend = function(xhr) {
      xhr.setRequestHeader('X-HTTP-Method-Override', type);
      if (beforeSend) return beforeSend.apply(this, arguments);
    };
  }

  // Don't process data on a non-GET request.
  if (params.type !== 'GET' && !options.emulateJSON) {
    params.processData = false;
  }

  // If we're sending a `PATCH` request, and we're in an old Internet Explorer
  // that still has ActiveX enabled by default, override jQuery to use that
  // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
  if (params.type === 'PATCH' && noXhrPatch) {
    params.xhr = function() {
      return new ActiveXObject("Microsoft.XMLHTTP");
    };
  }

  // Make the request, allowing the user to override any Ajax options.
  var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
  model.trigger('request', model, xhr, options);
  return xhr;
};

var noXhrPatch =
  typeof window !== 'undefined' && !!window.ActiveXObject &&
    !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

// Map from CRUD to HTTP for our default `Backbone.sync` implementation.
var methodMap = {
  'create': 'POST',
  'update': 'PUT',
  'patch':  'PATCH',
  'delete': 'DELETE',
  'read':   'GET'
};

// Set the default implementation of `Backbone.ajax` to proxy through to `$`.
// Override this if you'd like to use a different library.
Backbone.ajax = function() {
  return Backbone.$.ajax.apply(Backbone.$, arguments);
};

// Backbone.Router
// ---------------

// Routers map faux-URLs to actions, and fire events when routes are
// matched. Creating a new one sets its `routes` hash, if not set statically.
var Router = Backbone.Router = function(options) {
  options || (options = {});
  if (options.routes) this.routes = options.routes;
  this._bindRoutes();
  this.initialize.apply(this, arguments);
};

// Cached regular expressions for matching named param parts and splatted
// parts of route strings.
var optionalParam = /\((.*?)\)/g;
var namedParam    = /(\(\?)?:\w+/g;
var splatParam    = /\*\w+/g;
var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

// Set up all inheritable **Backbone.Router** properties and methods.
_.extend(Router.prototype, Events, {

  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function(){},

  // Manually bind a single named route to a callback. For example:
  //
  //     this.route('search/:query/p:num', 'search', function(query, num) {
  //       ...
  //     });
  //
  route: function(route, name, callback) {
    if (!_.isRegExp(route)) route = this._routeToRegExp(route);
    if (_.isFunction(name)) {
      callback = name;
      name = '';
    }
    if (!callback) callback = this[name];
    var router = this;
    Backbone.history.route(route, function(fragment) {
      var args = router._extractParameters(route, fragment);
      router.execute(callback, args);
      router.trigger.apply(router, ['route:' + name].concat(args));
      router.trigger('route', name, args);
      Backbone.history.trigger('route', router, name, args);
    });
    return this;
  },

  // Execute a route handler with the provided parameters.  This is an
  // excellent place to do pre-route setup or post-route cleanup.
  execute: function(callback, args) {
    if (callback) callback.apply(this, args);
  },

  // Simple proxy to `Backbone.history` to save a fragment into the history.
  navigate: function(fragment, options) {
    Backbone.history.navigate(fragment, options);
    return this;
  },

  // Bind all defined routes to `Backbone.history`. We have to reverse the
  // order of the routes here to support behavior where the most general
  // routes can be defined at the bottom of the route map.
  _bindRoutes: function() {
    if (!this.routes) return;
    this.routes = _.result(this, 'routes');
    var route, routes = _.keys(this.routes);
    while ((route = routes.pop()) != null) {
      this.route(route, this.routes[route]);
    }
  },

  // Convert a route string into a regular expression, suitable for matching
  // against the current location hash.
  _routeToRegExp: function(route) {
    route = route.replace(escapeRegExp, '\\$&')
                  .replace(optionalParam, '(?:$1)?')
                  .replace(namedParam, function(match, optional) {
                    return optional ? match : '([^/?]+)';
                  })
                  .replace(splatParam, '([^?]*?)');
    return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
  },

  // Given a route, and a URL fragment that it matches, return the array of
  // extracted decoded parameters. Empty or unmatched parameters will be
  // treated as `null` to normalize cross-browser behavior.
  _extractParameters: function(route, fragment) {
    var params = route.exec(fragment).slice(1);
    return _.map(params, function(param, i) {
      // Don't decode the search params.
      if (i === params.length - 1) return param || null;
      return param ? decodeURIComponent(param) : null;
    });
  }

});

// Backbone.History
// ----------------

// Handles cross-browser history management, based on either
// [pushState](http://diveintohtml5.info/history.html) and real URLs, or
// [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
// and URL fragments. If the browser supports neither (old IE, natch),
// falls back to polling.
var History = Backbone.History = function() {
  this.handlers = [];
  _.bindAll(this, 'checkUrl');

  // Ensure that `History` can be used outside of the browser.
  if (typeof window !== 'undefined') {
    this.location = window.location;
    this.history = window.history;
  }
};

// Cached regex for stripping a leading hash/slash and trailing space.
var routeStripper = /^[#\/]|\s+$/g;

// Cached regex for stripping leading and trailing slashes.
var rootStripper = /^\/+|\/+$/g;

// Cached regex for detecting MSIE.
var isExplorer = /msie [\w.]+/;

// Cached regex for removing a trailing slash.
var trailingSlash = /\/$/;

// Cached regex for stripping urls of hash.
var pathStripper = /#.*$/;

// Has the history handling already been started?
History.started = false;

// Set up all inheritable **Backbone.History** properties and methods.
_.extend(History.prototype, Events, {

  // The default interval to poll for hash changes, if necessary, is
  // twenty times a second.
  interval: 50,

  // Are we at the app root?
  atRoot: function() {
    return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
  },

  // Gets the true hash value. Cannot use location.hash directly due to bug
  // in Firefox where location.hash will always be decoded.
  getHash: function(window) {
    var match = (window || this).location.href.match(/#(.*)$/);
    return match ? match[1] : '';
  },

  // Get the cross-browser normalized URL fragment, either from the URL,
  // the hash, or the override.
  getFragment: function(fragment, forcePushState) {
    if (fragment == null) {
      if (this._hasPushState || !this._wantsHashChange || forcePushState) {
        fragment = decodeURI(this.location.pathname + this.location.search);
        var root = this.root.replace(trailingSlash, '');
        if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
      } else {
        fragment = this.getHash();
      }
    }
    return fragment.replace(routeStripper, '');
  },

  // Start the hash change handling, returning `true` if the current URL matches
  // an existing route, and `false` otherwise.
  start: function(options) {
    if (History.started) throw new Error("Backbone.history has already been started");
    History.started = true;

    // Figure out the initial configuration. Do we need an iframe?
    // Is pushState desired ... is it available?
    this.options          = _.extend({root: '/'}, this.options, options);
    this.root             = this.options.root;
    this._wantsHashChange = this.options.hashChange !== false;
    this._wantsPushState  = !!this.options.pushState;
    this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
    var fragment          = this.getFragment();
    var docMode           = document.documentMode;
    var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

    // Normalize root to always include a leading and trailing slash.
    this.root = ('/' + this.root + '/').replace(rootStripper, '/');

    if (oldIE && this._wantsHashChange) {
      var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
      this.iframe = frame.hide().appendTo('body')[0].contentWindow;
      this.navigate(fragment);
    }

    // Depending on whether we're using pushState or hashes, and whether
    // 'onhashchange' is supported, determine how we check the URL state.
    if (this._hasPushState) {
      Backbone.$(window).on('popstate', this.checkUrl);
    } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
      Backbone.$(window).on('hashchange', this.checkUrl);
    } else if (this._wantsHashChange) {
      this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
    }

    // Determine if we need to change the base url, for a pushState link
    // opened by a non-pushState browser.
    this.fragment = fragment;
    var loc = this.location;

    // Transition from hashChange to pushState or vice versa if both are
    // requested.
    if (this._wantsHashChange && this._wantsPushState) {

      // If we've started off with a route from a `pushState`-enabled
      // browser, but we're currently in a browser that doesn't support it...
      if (!this._hasPushState && !this.atRoot()) {
        this.fragment = this.getFragment(null, true);
        this.location.replace(this.root + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._hasPushState && this.atRoot() && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        this.history.replaceState({}, document.title, this.root + this.fragment);
      }

    }

    if (!this.options.silent) return this.loadUrl();
  },

  // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
  // but possibly useful for unit testing Routers.
  stop: function() {
    Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
    if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
    History.started = false;
  },

  // Add a route to be tested when the fragment changes. Routes added later
  // may override previous routes.
  route: function(route, callback) {
    this.handlers.unshift({route: route, callback: callback});
  },

  // Checks the current URL to see if it has changed, and if it has,
  // calls `loadUrl`, normalizing across the hidden iframe.
  checkUrl: function(e) {
    var current = this.getFragment();
    if (current === this.fragment && this.iframe) {
      current = this.getFragment(this.getHash(this.iframe));
    }
    if (current === this.fragment) return false;
    if (this.iframe) this.navigate(current);
    this.loadUrl();
  },

  // Attempt to load the current URL fragment. If a route succeeds with a
  // match, returns `true`. If no defined routes matches the fragment,
  // returns `false`.
  loadUrl: function(fragment) {
    fragment = this.fragment = this.getFragment(fragment);
    return _.any(this.handlers, function(handler) {
      if (handler.route.test(fragment)) {
        handler.callback(fragment);
        return true;
      }
    });
  },

  // Save a fragment into the hash history, or replace the URL state if the
  // 'replace' option is passed. You are responsible for properly URL-encoding
  // the fragment in advance.
  //
  // The options object can contain `trigger: true` if you wish to have the
  // route callback be fired (not usually desirable), or `replace: true`, if
  // you wish to modify the current URL without adding an entry to the history.
  navigate: function(fragment, options) {
    if (!History.started) return false;
    if (!options || options === true) options = {trigger: !!options};

    var url = this.root + (fragment = this.getFragment(fragment || ''));

    // Strip the hash for matching.
    fragment = fragment.replace(pathStripper, '');

    if (this.fragment === fragment) return;
    this.fragment = fragment;

    // Don't include a trailing slash on the root.
    if (fragment === '' && url !== '/') url = url.slice(0, -1);

    // If pushState is available, we use it to set the fragment as a real URL.
    if (this._hasPushState) {
      this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

    // If hash changes haven't been explicitly disabled, update the hash
    // fragment to store history.
    } else if (this._wantsHashChange) {
      this._updateHash(this.location, fragment, options.replace);
      if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
        // Opening and closing the iframe tricks IE7 and earlier to push a
        // history entry on hash-tag change.  When replace is true, we don't
        // want this.
        if(!options.replace) this.iframe.document.open().close();
        this._updateHash(this.iframe.location, fragment, options.replace);
      }

    // If you've told us that you explicitly don't want fallback hashchange-
    // based history, then `navigate` becomes a page refresh.
    } else {
      return this.location.assign(url);
    }
    if (options.trigger) return this.loadUrl(fragment);
  },

  // Update the hash location, either replacing the current entry, or adding
  // a new one to the browser history.
  _updateHash: function(location, fragment, replace) {
    if (replace) {
      var href = location.href.replace(/(javascript:|#).*$/, '');
      location.replace(href + '#' + fragment);
    } else {
      // Some browsers require that `hash` contains a leading #.
      location.hash = '#' + fragment;
    }
  }

});

// Create the default Backbone.history.
Backbone.history = new History;

// Helpers
// -------

// Helper function to correctly set up the prototype chain, for subclasses.
// Similar to `goog.inherits`, but uses a hash of prototype properties and
// class properties to be extended.
var extend = function(protoProps, staticProps) {
  var parent = this;
  var child;

  // The constructor function for the new subclass is either defined by you
  // (the "constructor" property in your `extend` definition), or defaulted
  // by us to simply call the parent's constructor.
  if (protoProps && _.has(protoProps, 'constructor')) {
    child = protoProps.constructor;
  } else {
    child = function(){ return parent.apply(this, arguments); };
  }

  // Add static properties to the constructor function, if supplied.
  _.extend(child, parent, staticProps);

  // Set the prototype chain to inherit from `parent`, without calling
  // `parent`'s constructor function.
  var Surrogate = function(){ this.constructor = child; };
  Surrogate.prototype = parent.prototype;
  child.prototype = new Surrogate;

  // Add prototype properties (instance properties) to the subclass,
  // if supplied.
  if (protoProps) _.extend(child.prototype, protoProps);

  // Set a convenience property in case the parent's prototype is needed
  // later.
  child.__super__ = parent.prototype;

  return child;
};

// Set up inheritance for the model, collection, router, view and history.
Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

// Throw an error when a URL is needed, and none is supplied.
var urlError = function() {
  throw new Error('A "url" property or function must be specified');
};
// Wrap an optional error callback with a fallback error event.
var wrapError = function(model, options) {
  var error = options.error;
  options.error = function(resp) {
    if (error) error(model, resp, options);
    model.trigger('error', model, resp, options);
  };
};
*/


module.exports = Backbone;

},{"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/typeof":24,"jquery":"jquery","underscore":"underscore"}],"charts-controller":[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var $ = require('jquery');

var RSVP = require('rsvp');

var ChartData = require('../models/chart-data');

var ChartDataExtractor = require('../models/chart-data-extractor');

var SelectionMediator = require('../models/selection-mediator');

var ChartHeaderView = require('../views/chart-header-view');

var ChartFooterView = require('../views/chart-footer-view');

var ChartView = require('../views/chart-view');
/** @typedef {import('../types/types').RawChartData} RawChartData */
// Creates and returns chart views for the current page


var ChartsController = /*#__PURE__*/function () {
  function ChartsController() {
    (0, _classCallCheck2.default)(this, ChartsController);
  }

  (0, _createClass2.default)(ChartsController, [{
    key: "create",
    value: // Finds chart configurations (<div class="ddp-chart">) in the DOM and
    // transforms them into interactive charts.
    // Returns { chartViews: Array, renderPromise: Promise }
    // The promise is resolved when all charts been rendered.
    function create() {
      var _this = this;

      /** @type {ChartView[]} */
      var chartViews = [];
      /** @type {RSVP.Promise<RawChartData>[]} */

      var renderPromises = []; // Regular charts

      $(this.chartSelector).each(function (index, el) {
        var result = _this.createChart(el);

        if (!result) {
          return;
        }

        var model = result.model,
            view = result.view; // Fetch data

        var renderPromise = model.fetchInitially();
        renderPromises.push(renderPromise);
        chartViews.push(view);
      }); // Custom charts

      $(this.customChartSelector).each(function (index, el) {
        _this.createCustomChart(el);
      }); // Create a Promise for successful rendering of regular charts

      var renderPromise = RSVP.all(renderPromises);
      return {
        chartViews: chartViews,
        renderPromise: renderPromise
      };
    }
    /**
     * Creates a regular chart for a given element with HTML configuration.
     *
     * @param {HTMLElement} el
     */

  }, {
    key: "createChart",
    value: function createChart(el) {
      var model = ChartDataExtractor.fromElement(el);

      if (!model.isValid()) {
        return false;
      } // Restore user selection


      SelectionMediator.apply(model); // Observe changes

      SelectionMediator.observe(model);
      var view = this.createChartView(el, model);
      return {
        model: model,
        view: view
      };
    }
    /**
     * Creates a chart view with headers and footers
     * for the given element and model.
     * Returns a ChartView.
     *
     * @param {HTMLElement} el
     * @param {ChartData} model
     */

  }, {
    key: "createChartView",
    value: function createChartView(el, model) {
      // External header
      var headerId = model.get('externalHeaderId');

      if (headerId) {
        var header = document.getElementById(headerId);

        if (header) {
          new ChartHeaderView({
            model: model,
            el: header,
            chartEl: el
          });
        }
      } // External footer


      var footerId = model.get('externalFooterId');

      if (footerId) {
        var footer = document.getElementById(footerId);

        if (footer) {
          new ChartFooterView({
            model: model,
            el: footer,
            chartEl: el
          });
        }
      } // The chart itself


      return new ChartView({
        el: el,
        model: model
      });
    }
    /**
     * Creates a custom chart without header and fetches the data.
     * A custom chart does not have headers or footers.
     *
     * @param {HTMLElement} el
     */

  }, {
    key: "createCustomChart",
    value: function createCustomChart(el) {
      var model = ChartDataExtractor.fromElement(el);
      var view = new ChartView({
        el: el,
        model: model,
        header: false
      });
      var renderPromise = model.fetchInitially();
      return {
        model: model,
        view: view,
        renderPromise: renderPromise
      };
    }
    /**
     * Creates a chart for a given element and given configuration.
     * Fetches the data.
     *
     * @param {HTMLElement} el
     * @param {ChartDataSchema} configuration
     */

  }, {
    key: "createChartForConfiguration",
    value: function createChartForConfiguration(el, configuration) {
      var model = new ChartData(configuration);
      var view = this.createChartView(el, model);
      var renderPromise = model.fetchInitially();
      return {
        model: model,
        view: view,
        renderPromise: renderPromise
      };
    }
  }]);
  return ChartsController;
}();

ChartsController.prototype.chartSelector = '.ddp-chart';
ChartsController.prototype.customChartSelector = '.ddp-custom-chart';
module.exports = ChartsController;

},{"../models/chart-data":92,"../models/chart-data-extractor":90,"../models/selection-mediator":112,"../views/chart-footer-view":153,"../views/chart-header-view":154,"../views/chart-view":156,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":11,"jquery":"jquery","rsvp":32}],"env-api":[function(require,module,exports){
module.exports={}

},{}],"jquery.nouislider":[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/*

$.Link (part of noUiSlider) - WTFPL */
(function (c) {
  function m(a, c, d) {
    if ((a[c] || a[d]) && a[c] === a[d]) throw Error("(Link) '" + c + "' can't match '" + d + "'.'");
  }

  function r(a) {
    void 0 === a && (a = {});
    if ("object" !== (0, _typeof2.default)(a)) throw Error("(Format) 'format' option must be an object.");
    var h = {};
    c(u).each(function (c, n) {
      if (void 0 === a[n]) h[n] = A[c];else if ((0, _typeof2.default)(a[n]) === (0, _typeof2.default)(A[c])) {
        if ("decimals" === n && (0 > a[n] || 7 < a[n])) throw Error("(Format) 'format.decimals' option must be between 0 and 7.");
        h[n] = a[n];
      } else throw Error("(Format) 'format." + n + "' must be a " + (0, _typeof2.default)(A[c]) + ".");
    });
    m(h, "mark", "thousand");
    m(h, "prefix", "negative");
    m(h, "prefix", "negativeBefore");
    this.r = h;
  }

  function k(a, h) {
    "object" !== (0, _typeof2.default)(a) && c.error("(Link) Initialize with an object.");
    return new k.prototype.p(a.target || function () {}, a.method, a.format || {}, h);
  }

  var u = "decimals mark thousand prefix postfix encoder decoder negative negativeBefore to from".split(" "),
      A = [2, ".", "", "", "", function (a) {
    return a;
  }, function (a) {
    return a;
  }, "-", "", function (a) {
    return a;
  }, function (a) {
    return a;
  }];

  r.prototype.a = function (a) {
    return this.r[a];
  };

  r.prototype.L = function (a) {
    function c(a) {
      return a.split("").reverse().join("");
    }

    a = this.a("encoder")(a);
    var d = this.a("decimals"),
        n = "",
        k = "",
        m = "",
        r = "";
    0 === parseFloat(a.toFixed(d)) && (a = "0");
    0 > a && (n = this.a("negative"), k = this.a("negativeBefore"));
    a = Math.abs(a).toFixed(d).toString();
    a = a.split(".");
    this.a("thousand") ? (m = c(a[0]).match(/.{1,3}/g), m = c(m.join(c(this.a("thousand"))))) : m = a[0];
    this.a("mark") && 1 < a.length && (r = this.a("mark") + a[1]);
    return this.a("to")(k + this.a("prefix") + n + m + r + this.a("postfix"));
  };

  r.prototype.w = function (a) {
    function c(a) {
      return a.replace(/[\-\/\\\^$*+?.()|\[\]{}]/g, "\\$&");
    }

    var d;
    if (null === a || void 0 === a) return !1;
    a = this.a("from")(a);
    a = a.toString();
    d = a.replace(RegExp("^" + c(this.a("negativeBefore"))), "");
    a !== d ? (a = d, d = "-") : d = "";
    a = a.replace(RegExp("^" + c(this.a("prefix"))), "");
    this.a("negative") && (d = "", a = a.replace(RegExp("^" + c(this.a("negative"))), "-"));
    a = a.replace(RegExp(c(this.a("postfix")) + "$"), "").replace(RegExp(c(this.a("thousand")), "g"), "").replace(this.a("mark"), ".");
    a = this.a("decoder")(parseFloat(d + a));
    return isNaN(a) ? !1 : a;
  };

  k.prototype.K = function (a, h) {
    this.method = h || "html";
    this.j = c(a.replace("-tooltip-", "") || "<div/>")[0];
  };

  k.prototype.H = function (a) {
    this.method = "val";
    this.j = document.createElement("input");
    this.j.name = a;
    this.j.type = "hidden";
  };

  k.prototype.G = function (a) {
    function h(a, c) {
      return [c ? null : a, c ? a : null];
    }

    var d = this;
    this.method = "val";
    this.target = a.on("change", function (a) {
      d.B.val(h(c(a.target).val(), d.t), {
        link: d,
        set: !0
      });
    });
  };

  k.prototype.p = function (a, h, d, k) {
    this.g = d;
    this.update = !k;
    if ("string" === typeof a && 0 === a.indexOf("-tooltip-")) this.K(a, h);else if ("string" === typeof a && 0 !== a.indexOf("-")) this.H(a);else if ("function" === typeof a) this.target = !1, this.method = a;else {
      if (a instanceof c || c.zepto && c.zepto.isZ(a)) {
        if (!h) {
          if (a.is("input, select, textarea")) {
            this.G(a);
            return;
          }

          h = "html";
        }

        if ("function" === typeof h || "string" === typeof h && a[h]) {
          this.method = h;
          this.target = a;
          return;
        }
      }

      throw new RangeError("(Link) Invalid Link.");
    }
  };

  k.prototype.write = function (a, c, d, k) {
    if (!this.update || !1 !== k) if (this.u = a, this.F = a = this.format(a), "function" === typeof this.method) this.method.call(this.target[0] || d[0], a, c, d);else this.target[this.method](a, c, d);
  };

  k.prototype.q = function (a) {
    this.g = new r(c.extend({}, a, this.g instanceof r ? this.g.r : this.g));
  };

  k.prototype.J = function (a) {
    this.B = a;
  };

  k.prototype.I = function (a) {
    this.t = a;
  };

  k.prototype.format = function (a) {
    return this.g.L(a);
  };

  k.prototype.A = function (a) {
    return this.g.w(a);
  };

  k.prototype.p.prototype = k.prototype;
  c.Link = k;
})(require('jquery'));
/*
$.fn.noUiSlider - WTFPL - refreshless.com/nouislider/ */


(function (c) {
  function m(e) {
    return "number" === typeof e && !isNaN(e) && isFinite(e);
  }

  function r(e) {
    return c.isArray(e) ? e : [e];
  }

  function k(e, b) {
    e.addClass(b);
    setTimeout(function () {
      e.removeClass(b);
    }, 300);
  }

  function u(e, b) {
    return 100 * b / (e[1] - e[0]);
  }

  function A(e, b) {
    if (b >= e.d.slice(-1)[0]) return 100;

    for (var a = 1, c, f, d; b >= e.d[a];) {
      a++;
    }

    c = e.d[a - 1];
    f = e.d[a];
    d = e.c[a - 1];
    c = [c, f];
    return d + u(c, 0 > c[0] ? b + Math.abs(c[0]) : b - c[0]) / (100 / (e.c[a] - d));
  }

  function a(e, b) {
    if (100 <= b) return e.d.slice(-1)[0];

    for (var a = 1, c, f, d; b >= e.c[a];) {
      a++;
    }

    c = e.d[a - 1];
    f = e.d[a];
    d = e.c[a - 1];
    c = [c, f];
    return 100 / (e.c[a] - d) * (b - d) * (c[1] - c[0]) / 100 + c[0];
  }

  function h(a, b) {
    for (var c = 1, g; (a.dir ? 100 - b : b) >= a.c[c];) {
      c++;
    }

    if (a.m) return g = a.c[c - 1], c = a.c[c], b - g > (c - g) / 2 ? c : g;
    a.h[c - 1] ? (g = a.h[c - 1], c = a.c[c - 1] + Math.round((b - a.c[c - 1]) / g) * g) : c = b;
    return c;
  }

  function d(a, b) {
    if (!m(b)) throw Error("noUiSlider: 'step' is not numeric.");
    a.h[0] = b;
  }

  function n(a, b) {
    if ("object" !== (0, _typeof2.default)(b) || c.isArray(b)) throw Error("noUiSlider: 'range' is not an object.");
    if (void 0 === b.min || void 0 === b.max) throw Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
    c.each(b, function (b, g) {
      var d;
      "number" === typeof g && (g = [g]);
      if (!c.isArray(g)) throw Error("noUiSlider: 'range' contains invalid value.");
      d = "min" === b ? 0 : "max" === b ? 100 : parseFloat(b);
      if (!m(d) || !m(g[0])) throw Error("noUiSlider: 'range' value isn't numeric.");
      a.c.push(d);
      a.d.push(g[0]);
      d ? a.h.push(isNaN(g[1]) ? !1 : g[1]) : isNaN(g[1]) || (a.h[0] = g[1]);
    });
    c.each(a.h, function (b, c) {
      if (!c) return !0;
      a.h[b] = u([a.d[b], a.d[b + 1]], c) / (100 / (a.c[b + 1] - a.c[b]));
    });
  }

  function E(a, b) {
    "number" === typeof b && (b = [b]);
    if (!c.isArray(b) || !b.length || 2 < b.length) throw Error("noUiSlider: 'start' option is incorrect.");
    a.b = b.length;
    a.start = b;
  }

  function I(a, b) {
    a.m = b;
    if ("boolean" !== typeof b) throw Error("noUiSlider: 'snap' option must be a boolean.");
  }

  function J(a, b) {
    if ("lower" === b && 1 === a.b) a.i = 1;else if ("upper" === b && 1 === a.b) a.i = 2;else if (!0 === b && 2 === a.b) a.i = 3;else if (!1 === b) a.i = 0;else throw Error("noUiSlider: 'connect' option doesn't match handle count.");
  }

  function D(a, b) {
    switch (b) {
      case "horizontal":
        a.k = 0;
        break;

      case "vertical":
        a.k = 1;
        break;

      default:
        throw Error("noUiSlider: 'orientation' option is invalid.");
    }
  }

  function K(a, b) {
    if (2 < a.c.length) throw Error("noUiSlider: 'margin' option is only supported on linear sliders.");
    a.margin = u(a.d, b);
    if (!m(b)) throw Error("noUiSlider: 'margin' option must be numeric.");
  }

  function L(a, b) {
    switch (b) {
      case "ltr":
        a.dir = 0;
        break;

      case "rtl":
        a.dir = 1;
        a.i = [0, 2, 1, 3][a.i];
        break;

      default:
        throw Error("noUiSlider: 'direction' option was not recognized.");
    }
  }

  function M(a, b) {
    if ("string" !== typeof b) throw Error("noUiSlider: 'behaviour' must be a string containing options.");
    var c = 0 <= b.indexOf("snap");
    a.n = {
      s: 0 <= b.indexOf("tap") || c,
      extend: 0 <= b.indexOf("extend"),
      v: 0 <= b.indexOf("drag"),
      fixed: 0 <= b.indexOf("fixed"),
      m: c
    };
  }

  function N(a, b, d) {
    a.o = [b.lower, b.upper];
    a.g = b.format;
    c.each(a.o, function (a, e) {
      if (!c.isArray(e)) throw Error("noUiSlider: 'serialization." + (a ? "upper" : "lower") + "' must be an array.");
      c.each(e, function () {
        if (!(this instanceof c.Link)) throw Error("noUiSlider: 'serialization." + (a ? "upper" : "lower") + "' can only contain Link instances.");
        this.I(a);
        this.J(d);
        this.q(b.format);
      });
    });
    a.dir && 1 < a.b && a.o.reverse();
  }

  function O(a, b) {
    var f = {
      c: [],
      d: [],
      h: [!1],
      margin: 0
    },
        g;
    g = {
      step: {
        e: !1,
        f: d
      },
      start: {
        e: !0,
        f: E
      },
      connect: {
        e: !0,
        f: J
      },
      direction: {
        e: !0,
        f: L
      },
      range: {
        e: !0,
        f: n
      },
      snap: {
        e: !1,
        f: I
      },
      orientation: {
        e: !1,
        f: D
      },
      margin: {
        e: !1,
        f: K
      },
      behaviour: {
        e: !0,
        f: M
      },
      serialization: {
        e: !0,
        f: N
      }
    };
    a = c.extend({
      connect: !1,
      direction: "ltr",
      behaviour: "tap",
      orientation: "horizontal"
    }, a);
    a.serialization = c.extend({
      lower: [],
      upper: [],
      format: {}
    }, a.serialization);
    c.each(g, function (c, d) {
      if (void 0 === a[c]) {
        if (d.e) throw Error("noUiSlider: '" + c + "' is required.");
        return !0;
      }

      d.f(f, a[c], b);
    });
    f.style = f.k ? "top" : "left";
    return f;
  }

  function P(a, b) {
    var d = c("<div><div/></div>").addClass(f[2]),
        g = ["-lower", "-upper"];
    a.dir && g.reverse();
    d.children().addClass(f[3] + " " + f[3] + g[b]);
    return d;
  }

  function Q(a, b) {
    b.j && (b = new c.Link({
      target: c(b.j).clone().appendTo(a),
      method: b.method,
      format: b.g
    }, !0));
    return b;
  }

  function R(a, b) {
    var d,
        f = [];

    for (d = 0; d < a.b; d++) {
      var k = f,
          h = d,
          m = a.o[d],
          n = b[d].children(),
          r = a.g,
          s = void 0,
          v = [],
          s = new c.Link({}, !0);
      s.q(r);
      v.push(s);

      for (s = 0; s < m.length; s++) {
        v.push(Q(n, m[s]));
      }

      k[h] = v;
    }

    return f;
  }

  function S(a, b, c) {
    switch (a) {
      case 1:
        b.addClass(f[7]);
        c[0].addClass(f[6]);
        break;

      case 3:
        c[1].addClass(f[6]);

      case 2:
        c[0].addClass(f[7]);

      case 0:
        b.addClass(f[6]);
    }
  }

  function T(a, b) {
    var c,
        d = [];

    for (c = 0; c < a.b; c++) {
      d.push(P(a, c).appendTo(b));
    }

    return d;
  }

  function U(a, b) {
    b.addClass([f[0], f[8 + a.dir], f[4 + a.k]].join(" "));
    return c("<div/>").appendTo(b).addClass(f[1]);
  }

  function V(d, b, m) {
    function g() {
      return t[["width", "height"][b.k]]();
    }

    function n(a) {
      var b,
          c = [q.val()];

      for (b = 0; b < a.length; b++) {
        q.trigger(a[b], c);
      }
    }

    function u(d, p, e) {
      var g = d[0] !== l[0][0] ? 1 : 0,
          H = x[0] + b.margin,
          k = x[1] - b.margin;
      e && 1 < l.length && (p = g ? Math.max(p, H) : Math.min(p, k));
      100 > p && (p = h(b, p));
      p = Math.max(Math.min(parseFloat(p.toFixed(7)), 100), 0);
      if (p === x[g]) return 1 === l.length ? !1 : p === H || p === k ? 0 : !1;
      d.css(b.style, p + "%");
      d.is(":first-child") && d.toggleClass(f[17], 50 < p);
      x[g] = p;
      b.dir && (p = 100 - p);
      c(y[g]).each(function () {
        this.write(a(b, p), d.children(), q);
      });
      return !0;
    }

    function B(a, b, c) {
      c || k(q, f[14]);
      u(a, b, !1);
      n(["slide", "set", "change"]);
    }

    function w(a, c, d, e) {
      a = a.replace(/\s/g, ".nui ") + ".nui";
      c.on(a, function (a) {
        var c = q.attr("disabled");
        if (q.hasClass(f[14]) || void 0 !== c && null !== c) return !1;
        a.preventDefault();
        var c = 0 === a.type.indexOf("touch"),
            p = 0 === a.type.indexOf("mouse"),
            F = 0 === a.type.indexOf("pointer"),
            g,
            k,
            l = a;
        0 === a.type.indexOf("MSPointer") && (F = !0);
        a.originalEvent && (a = a.originalEvent);
        c && (g = a.changedTouches[0].pageX, k = a.changedTouches[0].pageY);
        if (p || F) F || void 0 !== window.pageXOffset || (window.pageXOffset = document.documentElement.scrollLeft, window.pageYOffset = document.documentElement.scrollTop), g = a.clientX + window.pageXOffset, k = a.clientY + window.pageYOffset;
        l.C = [g, k];
        l.cursor = p;
        a = l;
        a.l = a.C[b.k];
        d(a, e);
      });
    }

    function C(a, c) {
      var b = c.b || l,
          d,
          e = !1,
          e = 100 * (a.l - c.start) / g(),
          f = b[0][0] !== l[0][0] ? 1 : 0;
      var k = c.D;
      d = e + k[0];
      e += k[1];
      1 < b.length ? (0 > d && (e += Math.abs(d)), 100 < e && (d -= e - 100), d = [Math.max(Math.min(d, 100), 0), Math.max(Math.min(e, 100), 0)]) : d = [d, e];
      e = u(b[0], d[f], 1 === b.length);
      1 < b.length && (e = u(b[1], d[f ? 0 : 1], !1) || e);
      e && n(["slide"]);
    }

    function s(a) {
      c("." + f[15]).removeClass(f[15]);
      a.cursor && c("body").css("cursor", "").off(".nui");
      G.off(".nui");
      q.removeClass(f[12]);
      n(["set", "change"]);
    }

    function v(a, b) {
      1 === b.b.length && b.b[0].children().addClass(f[15]);
      a.stopPropagation();
      w(z.move, G, C, {
        start: a.l,
        b: b.b,
        D: [x[0], x[l.length - 1]]
      });
      w(z.end, G, s, null);
      a.cursor && (c("body").css("cursor", c(a.target).css("cursor")), 1 < l.length && q.addClass(f[12]), c("body").on("selectstart.nui", !1));
    }

    function D(a) {
      var d = a.l,
          e = 0;
      a.stopPropagation();
      c.each(l, function () {
        e += this.offset()[b.style];
      });
      e = d < e / 2 || 1 === l.length ? 0 : 1;
      d -= t.offset()[b.style];
      d = 100 * d / g();
      B(l[e], d, b.n.m);
      b.n.m && v(a, {
        b: [l[e]]
      });
    }

    function E(a) {
      var c = (a = a.l < t.offset()[b.style]) ? 0 : 100;
      a = a ? 0 : l.length - 1;
      B(l[a], c, !1);
    }

    var q = c(d),
        x = [-1, -1],
        t,
        y,
        l;
    if (q.hasClass(f[0])) throw Error("Slider was already initialized.");
    t = U(b, q);
    l = T(b, t);
    y = R(b, l);
    S(b.i, q, l);

    (function (a) {
      var b;
      if (!a.fixed) for (b = 0; b < l.length; b++) {
        w(z.start, l[b].children(), v, {
          b: [l[b]]
        });
      }
      a.s && w(z.start, t, D, {
        b: l
      });
      a.extend && (q.addClass(f[16]), a.s && w(z.start, q, E, {
        b: l
      }));
      a.v && (b = t.find("." + f[7]).addClass(f[10]), a.fixed && (b = b.add(t.children().not(b).children())), w(z.start, b, v, {
        b: l
      }));
    })(b.n);

    d.vSet = function () {
      var a = Array.prototype.slice.call(arguments, 0),
          d,
          e,
          g,
          h,
          m,
          s,
          t = r(a[0]);
      "object" === (0, _typeof2.default)(a[1]) ? (d = a[1].set, e = a[1].link, g = a[1].update, h = a[1].animate) : !0 === a[1] && (d = !0);
      b.dir && 1 < b.b && t.reverse();
      h && k(q, f[14]);
      a = 1 < l.length ? 3 : 1;
      1 === t.length && (a = 1);

      for (m = 0; m < a; m++) {
        h = e || y[m % 2][0], h = h.A(t[m % 2]), !1 !== h && (h = A(b, h), b.dir && (h = 100 - h), !0 !== u(l[m % 2], h, !0) && c(y[m % 2]).each(function (a) {
          if (!a) return s = this.u, !0;
          this.write(s, l[m % 2].children(), q, g);
        }));
      }

      !0 === d && n(["set"]);
      return this;
    };

    d.vGet = function () {
      var a,
          c = [];

      for (a = 0; a < b.b; a++) {
        c[a] = y[a][0].F;
      }

      return 1 === c.length ? c[0] : b.dir ? c.reverse() : c;
    };

    d.destroy = function () {
      c.each(y, function () {
        c.each(this, function () {
          this.target && this.target.off(".nui");
        });
      });
      c(this).off(".nui").removeClass(f.join(" ")).empty();
      return m;
    };

    q.val(b.start);
  }

  function W(a) {
    if (!this.length) throw Error("noUiSlider: Can't initialize slider on empty selection.");
    var b = O(a, this);
    return this.each(function () {
      V(this, b, a);
    });
  }

  function X(a) {
    return this.each(function () {
      var b = c(this).val(),
          d = this.destroy(),
          f = c.extend({}, d, a);
      c(this).noUiSlider(f);
      d.start === f.start && c(this).val(b);
    });
  }

  function B() {
    return this[0][arguments.length ? "vSet" : "vGet"].apply(this[0], arguments);
  }

  var G = c(document),
      C = c.fn.val,
      z = window.navigator.pointerEnabled ? {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup"
  } : window.navigator.msPointerEnabled ? {
    start: "MSPointerDown",
    move: "MSPointerMove",
    end: "MSPointerUp"
  } : {
    start: "mousedown touchstart",
    move: "mousemove touchmove",
    end: "mouseup touchend"
  },
      f = "noUi-target noUi-base noUi-origin noUi-handle noUi-horizontal noUi-vertical noUi-background noUi-connect noUi-ltr noUi-rtl noUi-dragable  noUi-state-drag  noUi-state-tap noUi-active noUi-extended noUi-stacking".split(" ");

  c.fn.val = function () {
    var a = arguments,
        b = c(this[0]);
    return arguments.length ? this.each(function () {
      (c(this).hasClass(f[0]) ? B : C).apply(c(this), a);
    }) : (b.hasClass(f[0]) ? B : C).call(b);
  };

  c.noUiSlider = {
    Link: c.Link
  };

  c.fn.noUiSlider = function (a, b) {
    return (b ? X : W).call(this, a);
  };
})(require('jquery'));

},{"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/typeof":24,"jquery":"jquery"}],"jquery":[function(require,module,exports){
"use strict";

module.exports = window.$;

},{}],"lodash":[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash --development --output ./src/scripts/vendor/lodash.custom.js exports="node" include="assign,capitalize,chain,clone,compact,concat,create,debounce,defaults,escape,escapeRegExp,every,filter,find,findIndex,findLast,identity,isArray,isEqual,keys,last,map,mapValues,merge,omit,orderBy,partial,pick,pickBy,reduce,reject,result,size,sortBy,take,takeRight,toArray,uniq,uniqueId,value,without,clone,defaults,each,escape,extend,has,isEmpty,isEqual,keys,once,result,uniqueId"`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;
(function () {
  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;
  /** Used as the semantic version number. */

  var VERSION = '4.17.5';
  /** Used as the size to enable large array optimizations. */

  var LARGE_ARRAY_SIZE = 200;
  /** Error message constants. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used as the maximum memoize cache size. */

  var MAX_MEMOIZE_SIZE = 500;
  /** Used as the internal argument placeholder. */

  var PLACEHOLDER = '__lodash_placeholder__';
  /** Used to compose bitmasks for cloning. */

  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  /** Used to compose bitmasks for function metadata. */

  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;
  /** Used to detect hot functions by number of calls within a span of milliseconds. */

  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  /** Used to indicate the type of lazy iteratees. */

  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;
  /** Used as references for various `Number` constants. */

  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;
  /** Used as references for the maximum length and index of an array. */

  var MAX_ARRAY_LENGTH = 4294967295;
  /** Used to associate wrap methods with their bit flags. */

  var wrapFlags = [['ary', WRAP_ARY_FLAG], ['bind', WRAP_BIND_FLAG], ['bindKey', WRAP_BIND_KEY_FLAG], ['curry', WRAP_CURRY_FLAG], ['curryRight', WRAP_CURRY_RIGHT_FLAG], ['flip', WRAP_FLIP_FLAG], ['partial', WRAP_PARTIAL_FLAG], ['partialRight', WRAP_PARTIAL_RIGHT_FLAG], ['rearg', WRAP_REARG_FLAG]];
  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  /** Used to match HTML entities and HTML characters. */

  var reUnescapedHtml = /[&<>"']/g,
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  /** Used to match property names within property paths. */

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);
  /** Used to match leading and trailing whitespace. */

  var reTrim = /^\s+|\s+$/g;
  /** Used to match wrap detail comments. */

  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;
  /** Used to match backslashes in property paths. */

  var reEscapeChar = /\\(\\)?/g;
  /** Used to match `RegExp` flags from their coerced string values. */

  var reFlags = /\w*$/;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /** Used to compose unicode character classes. */

  var rsAstralRange = "\\ud800-\\udfff",
      rsComboMarksRange = "\\u0300-\\u036f",
      reComboHalfMarksRange = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange = "\\u20d0-\\u20ff",
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsAstral = '[' + rsAstralRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsFitz = "\\ud83c[\\udffb-\\udfff]",
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsZWJ = "\\u200d";
  /** Used to compose unicode regexes. */

  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
  /** Used to identify `toStringTag` values of typed arrays. */

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  /** Used to identify `toStringTag` values supported by `_.clone`. */

  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  /** Used to map characters to HTML entities. */

  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = (typeof global === "undefined" ? "undefined" : (0, _typeof2.default)(global)) == 'object' && global && global.Object === Object && global;
  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : (0, _typeof2.default)(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();
  /** Detect free variable `exports`. */

  var freeExports = (typeof exports === "undefined" ? "undefined" : (0, _typeof2.default)(exports)) == 'object' && exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && (typeof module === "undefined" ? "undefined" : (0, _typeof2.default)(module)) == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Detect free variable `process` from Node.js. */

  var freeProcess = moduleExports && freeGlobal.process;
  /** Used to access faster Node.js helpers. */

  var nodeUtil = function () {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();
  /* Node.js helper references. */


  var nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */

  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }
  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */


  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }
  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */


  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }

    return true;
  }
  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */


  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }
  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */


  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */


  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }

    return false;
  }
  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */


  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }
  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */


  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }
  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */


  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }

    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }

    return accumulator;
  }
  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */


  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }
  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */


  var asciiSize = baseProperty('length');
  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function asciiToArray(string) {
    return string.split('');
  }
  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }

    return -1;
  }
  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */


  function baseIsNaN(value) {
    return value !== value;
  }
  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */


  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }
  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */


  function basePropertyOf(object) {
    return function (key) {
      return object == null ? undefined : object[key];
    };
  }
  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */


  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function (value, index, collection) {
      accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }
  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */


  function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);

    while (length--) {
      array[length] = array[length].value;
    }

    return array;
  }
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */


  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }
  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */


  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }
  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */


  function baseValues(object, props) {
    return arrayMap(props, function (key) {
      return object[key];
    });
  }
  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function cacheHas(cache, key) {
    return cache.has(key);
  }
  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */


  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }

    return result;
  }
  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */


  var escapeHtmlChar = basePropertyOf(htmlEscapes);
  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */


  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */


  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }

    return result;
  }
  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */


  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */


  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */


  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }

    return result;
  }
  /**
   * Gets the value at `key`, unless `key` is "__proto__".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */


  function safeGet(object, key) {
    return key == '__proto__' ? undefined : object[key];
  }
  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */


  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }
  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }
  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */


  function stringSize(string) {
    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
  }
  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */


  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */


  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;

    while (reUnicode.test(string)) {
      ++result;
    }

    return result;
  }
  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */


  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }
  /*--------------------------------------------------------------------------*/

  /** Used for built-in method references. */


  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;
  /** Used to detect overreaching core-js shims. */

  var coreJsData = root['__core-js_shared__'];
  /** Used to resolve the decompiled source of functions. */

  var funcToString = funcProto.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /** Used to generate unique IDs. */

  var idCounter = 0;
  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */


  var nativeObjectToString = objectProto.toString;
  /** Used to infer the `Object` constructor. */

  var objectCtorString = funcToString.call(Object);
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined,
      _Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice,
      spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined,
      symIterator = _Symbol ? _Symbol.iterator : undefined,
      symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  var defineProperty = function () {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();
  /* Built-in method references for those with the same name as other `lodash` methods. */


  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object),
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeNow = Date.now,
      nativeReverse = arrayProto.reverse;
  /* Built-in method references that are verified to be native. */

  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');
  /** Used to store function metadata. */

  var metaMap = WeakMap && new WeakMap();
  /** Used to lookup unminified function names. */

  var realNames = {};
  /** Used to detect maps, sets, and weakmaps. */

  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);
  /** Used to convert symbols to primitives and strings. */

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;
  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps `value` to enable implicit method
   * chain sequences. Methods that operate on and return arrays, collections,
   * and functions can be chained together. Methods that retrieve a single value
   * or may return a primitive value will automatically end the chain sequence
   * and return the unwrapped value. Otherwise, the value must be unwrapped
   * with `_#value`.
   *
   * Explicit chain sequences, which must be unwrapped with `_#value`, may be
   * enabled using `_.chain`.
   *
   * The execution of chained methods is lazy, that is, it's deferred until
   * `_#value` is implicitly or explicitly called.
   *
   * Lazy evaluation allows several methods to support shortcut fusion.
   * Shortcut fusion is an optimization to merge iteratee calls; this avoids
   * the creation of intermediate arrays and can greatly reduce the number of
   * iteratee executions. Sections of a chain sequence qualify for shortcut
   * fusion if the section is applied to an array and iteratees accept only
   * one argument. The heuristic for whether a section qualifies for shortcut
   * fusion is subject to change.
   *
   * Chaining is supported in custom builds as long as the `_#value` method is
   * directly or indirectly included in the build.
   *
   * In addition to lodash methods, wrappers have `Array` and `String` methods.
   *
   * The wrapper `Array` methods are:
   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
   *
   * The wrapper `String` methods are:
   * `replace` and `split`
   *
   * The wrapper methods that support shortcut fusion are:
   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
   *
   * The chainable wrapper methods are:
   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
   * `zipObject`, `zipObjectDeep`, and `zipWith`
   *
   * The wrapper methods that are **not** chainable by default are:
   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
   * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
   * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
   * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
   * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
   * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
   * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
   * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
   * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
   * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
   * `upperFirst`, `value`, and `words`
   *
   * @name _
   * @constructor
   * @category Seq
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // Returns an unwrapped value.
   * wrapped.reduce(_.add);
   * // => 6
   *
   * // Returns a wrapped value.
   * var squares = wrapped.map(square);
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */

  function lodash(value) {
    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
      if (value instanceof LodashWrapper) {
        return value;
      }

      if (hasOwnProperty.call(value, '__wrapped__')) {
        return wrapperClone(value);
      }
    }

    return new LodashWrapper(value);
  }
  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */


  var baseCreate = function () {
    function object() {}

    return function (proto) {
      if (!isObject(proto)) {
        return {};
      }

      if (objectCreate) {
        return objectCreate(proto);
      }

      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }();
  /**
   * The function whose prototype chain sequence wrappers inherit from.
   *
   * @private
   */


  function baseLodash() {// No operation performed.
  }
  /**
   * The base constructor for creating `lodash` wrapper objects.
   *
   * @private
   * @param {*} value The value to wrap.
   * @param {boolean} [chainAll] Enable explicit method chain sequences.
   */


  function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
    this.__index__ = 0;
    this.__values__ = undefined;
  } // Ensure wrappers are instances of `baseLodash`.


  lodash.prototype = baseLodash.prototype;
  lodash.prototype.constructor = lodash;
  LodashWrapper.prototype = baseCreate(baseLodash.prototype);
  LodashWrapper.prototype.constructor = LodashWrapper;
  /*------------------------------------------------------------------------*/

  /**
   * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
   *
   * @private
   * @constructor
   * @param {*} value The value to wrap.
   */

  function LazyWrapper(value) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__dir__ = 1;
    this.__filtered__ = false;
    this.__iteratees__ = [];
    this.__takeCount__ = MAX_ARRAY_LENGTH;
    this.__views__ = [];
  }
  /**
   * Creates a clone of the lazy wrapper object.
   *
   * @private
   * @name clone
   * @memberOf LazyWrapper
   * @returns {Object} Returns the cloned `LazyWrapper` object.
   */


  function lazyClone() {
    var result = new LazyWrapper(this.__wrapped__);
    result.__actions__ = copyArray(this.__actions__);
    result.__dir__ = this.__dir__;
    result.__filtered__ = this.__filtered__;
    result.__iteratees__ = copyArray(this.__iteratees__);
    result.__takeCount__ = this.__takeCount__;
    result.__views__ = copyArray(this.__views__);
    return result;
  }
  /**
   * Reverses the direction of lazy iteration.
   *
   * @private
   * @name reverse
   * @memberOf LazyWrapper
   * @returns {Object} Returns the new reversed `LazyWrapper` object.
   */


  function lazyReverse() {
    if (this.__filtered__) {
      var result = new LazyWrapper(this);
      result.__dir__ = -1;
      result.__filtered__ = true;
    } else {
      result = this.clone();
      result.__dir__ *= -1;
    }

    return result;
  }
  /**
   * Extracts the unwrapped value from its lazy wrapper.
   *
   * @private
   * @name value
   * @memberOf LazyWrapper
   * @returns {*} Returns the unwrapped value.
   */


  function lazyValue() {
    var array = this.__wrapped__.value(),
        dir = this.__dir__,
        isArr = isArray(array),
        isRight = dir < 0,
        arrLength = isArr ? array.length : 0,
        view = getView(0, arrLength, this.__views__),
        start = view.start,
        end = view.end,
        length = end - start,
        index = isRight ? end : start - 1,
        iteratees = this.__iteratees__,
        iterLength = iteratees.length,
        resIndex = 0,
        takeCount = nativeMin(length, this.__takeCount__);

    if (!isArr || !isRight && arrLength == length && takeCount == length) {
      return baseWrapperValue(array, this.__actions__);
    }

    var result = [];

    outer: while (length-- && resIndex < takeCount) {
      index += dir;
      var iterIndex = -1,
          value = array[index];

      while (++iterIndex < iterLength) {
        var data = iteratees[iterIndex],
            iteratee = data.iteratee,
            type = data.type,
            computed = iteratee(value);

        if (type == LAZY_MAP_FLAG) {
          value = computed;
        } else if (!computed) {
          if (type == LAZY_FILTER_FLAG) {
            continue outer;
          } else {
            break outer;
          }
        }
      }

      result[resIndex++] = value;
    }

    return result;
  } // Ensure `LazyWrapper` is an instance of `baseLodash`.


  LazyWrapper.prototype = baseCreate(baseLodash.prototype);
  LazyWrapper.prototype.constructor = LazyWrapper;
  /*------------------------------------------------------------------------*/

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */


  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */


  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  } // Add methods to `Hash`.


  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  /*------------------------------------------------------------------------*/

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */


  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }
  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */


  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  /*------------------------------------------------------------------------*/

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */


  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }
  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */


  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  /*------------------------------------------------------------------------*/

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  }
  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */


  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);

    return this;
  }
  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */


  function setCacheHas(value) {
    return this.__data__.has(value);
  } // Add methods to `SetCache`.


  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  /*------------------------------------------------------------------------*/

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */


  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }
  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function stackGet(key) {
    return this.__data__.get(key);
  }
  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function stackHas(key) {
    return this.__data__.has(key);
  }
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */


  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof ListCache) {
      var pairs = data.__data__;

      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  } // Add methods to `Stack`.


  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  /*------------------------------------------------------------------------*/

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */


  function assignMergeValue(object, key, value) {
    if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */


  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }
  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */


  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */


  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }
  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */


  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }
  /**
   * The base implementation of `_.at` without support for individual paths.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {string[]} paths The property paths to pick.
   * @returns {Array} Returns the picked elements.
   */


  function baseAt(object, paths) {
    var index = -1,
        length = paths.length,
        result = Array(length),
        skip = object == null;

    while (++index < length) {
      result[index] = skip ? undefined : get(object, paths[index]);
    }

    return result;
  }
  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */


  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }

    if (result !== undefined) {
      return result;
    }

    if (!isObject(value)) {
      return value;
    }

    var isArr = isArray(value);

    if (isArr) {
      result = initCloneArray(value);

      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }

      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);

        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }

        result = initCloneByTag(value, tag, isDeep);
      }
    } // Check for circular references and return its corresponding clone.


    stack || (stack = new Stack());
    var stacked = stack.get(value);

    if (stacked) {
      return stacked;
    }

    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
      return result;
    }

    if (isMap(value)) {
      value.forEach(function (subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      } // Recursively populate clone (susceptible to call stack limits).


      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }
  /**
   * The base implementation of methods like `_.difference` without support
   * for excluding multiple arrays or iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Array} values The values to exclude.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   */


  function baseDifference(array, values, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        isCommon = true,
        length = array.length,
        result = [],
        valuesLength = values.length;

    if (!length) {
      return result;
    }

    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }

    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }

    outer: while (++index < length) {
      var value = array[index],
          computed = iteratee == null ? value : iteratee(value);
      value = comparator || value !== 0 ? value : 0;

      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;

        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }

        result.push(value);
      } else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */


  var baseEach = createBaseEach(baseForOwn);
  /**
   * The base implementation of `_.every` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`
   */

  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function (value, index, collection) {
      result = !!predicate(value, index, collection);
      return result;
    });
    return result;
  }
  /**
   * The base implementation of `_.filter` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */


  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function (value, index, collection) {
      if (predicate(value, index, collection)) {
        result.push(value);
      }
    });
    return result;
  }
  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */


  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }
  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */


  var baseFor = createBaseFor();
  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */

  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }
  /**
   * The base implementation of `_.functions` which creates an array of
   * `object` function property names filtered from `props`.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Array} props The property names to filter.
   * @returns {Array} Returns the function names.
   */


  function baseFunctions(object, props) {
    return arrayFilter(props, function (key) {
      return isFunction(object[key]);
    });
  }
  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */


  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }
  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */


  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  /**
   * The base implementation of `_.has` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */


  function baseHas(object, key) {
    return object != null && hasOwnProperty.call(object, key);
  }
  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */


  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  /**
   * The base implementation of `_.invoke` without support for individual
   * method arguments.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the method to invoke.
   * @param {Array} args The arguments to invoke the method with.
   * @returns {*} Returns the result of the invoked method.
   */


  function baseInvoke(object, path, args) {
    path = castPath(path, object);
    object = parent(object, path);
    var func = object == null ? object : object[toKey(last(path))];
    return func == null ? undefined : apply(func, object, args);
  }
  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */


  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */


  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }

    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */


  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : getTag(object),
        othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */


  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }
  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */


  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }

    object = Object(object);

    while (index--) {
      var data = matchData[index];

      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }

    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();

        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }

        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }

    return true;
  }
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */


  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */


  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }
  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */


  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */


  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }

    if (value == null) {
      return identity;
    }

    if ((0, _typeof2.default)(value) == 'object') {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }

    return property(value);
  }
  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }

    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */


  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function (value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }
  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */


  function baseMatches(source) {
    var matchData = getMatchData(source);

    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }

    return function (object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */


  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }

    return function (object) {
      var objValue = get(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */


  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }

    baseFor(source, function (srcValue, key) {
      if (isObject(srcValue)) {
        stack || (stack = new Stack());
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }

        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */


  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key),
        srcValue = safeGet(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }

    var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray(srcValue),
          isBuff = !isArr && isBuffer(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;

      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;

        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }

    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }

    assignMergeValue(object, key, newValue);
  }
  /**
   * The base implementation of `_.orderBy` without param guards.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
   * @param {string[]} orders The sort orders of `iteratees`.
   * @returns {Array} Returns the new sorted array.
   */


  function baseOrderBy(collection, iteratees, orders) {
    var index = -1;
    iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
    var result = baseMap(collection, function (value, key, collection) {
      var criteria = arrayMap(iteratees, function (iteratee) {
        return iteratee(value);
      });
      return {
        'criteria': criteria,
        'index': ++index,
        'value': value
      };
    });
    return baseSortBy(result, function (object, other) {
      return compareMultiple(object, other, orders);
    });
  }
  /**
   * The base implementation of `_.pick` without support for individual
   * property identifiers.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @returns {Object} Returns the new object.
   */


  function basePick(object, paths) {
    return basePickBy(object, paths, function (value, path) {
      return hasIn(object, path);
    });
  }
  /**
   * The base implementation of  `_.pickBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @param {Function} predicate The function invoked per property.
   * @returns {Object} Returns the new object.
   */


  function basePickBy(object, paths, predicate) {
    var index = -1,
        length = paths.length,
        result = {};

    while (++index < length) {
      var path = paths[index],
          value = baseGet(object, path);

      if (predicate(value, path)) {
        baseSet(result, castPath(path, object), value);
      }
    }

    return result;
  }
  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */


  function basePropertyDeep(path) {
    return function (object) {
      return baseGet(object, path);
    };
  }
  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */


  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
  }
  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */


  function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
      return object;
    }

    path = castPath(path, object);
    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;

        if (newValue === undefined) {
          newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
      }

      assignValue(nested, key, newValue);
      nested = nested[key];
    }

    return object;
  }
  /**
   * The base implementation of `setData` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to associate metadata with.
   * @param {*} data The metadata.
   * @returns {Function} Returns `func`.
   */


  var baseSetData = !metaMap ? identity : function (func, data) {
    metaMap.set(func, data);
    return func;
  };
  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var baseSetToString = !defineProperty ? identity : function (func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };
  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */

  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }
  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */


  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }

    if (isArray(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  /**
   * The base implementation of `_.uniqBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   */


  function baseUniq(array, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        length = array.length,
        isCommon = true,
        result = [],
        seen = result;

    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);

      if (set) {
        return setToArray(set);
      }

      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }

    outer: while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;

      if (isCommon && computed === computed) {
        var seenIndex = seen.length;

        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }

        if (iteratee) {
          seen.push(computed);
        }

        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }

        result.push(value);
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.unset`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The property path to unset.
   * @returns {boolean} Returns `true` if the property is deleted, else `false`.
   */


  function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent(object, path);
    return object == null || delete object[toKey(last(path))];
  }
  /**
   * The base implementation of `wrapperValue` which returns the result of
   * performing a sequence of actions on the unwrapped `value`, where each
   * successive action is supplied the return value of the previous.
   *
   * @private
   * @param {*} value The unwrapped value.
   * @param {Array} actions Actions to perform to resolve the unwrapped value.
   * @returns {*} Returns the resolved value.
   */


  function baseWrapperValue(value, actions) {
    var result = value;

    if (result instanceof LazyWrapper) {
      result = result.value();
    }

    return arrayReduce(actions, function (result, action) {
      return action.func.apply(action.thisArg, arrayPush([result], action.args));
    }, result);
  }
  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */


  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }

    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }
  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */


  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }
  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */


  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */


  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }
  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */


  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */


  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */


  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */


  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  /**
   * Compares values to sort them in ascending order.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */


  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = isSymbol(value);
      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = isSymbol(other);

      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }

      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }

    return 0;
  }
  /**
   * Used by `_.orderBy` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
   * specify an order of "desc" for descending or "asc" for ascending sort order
   * of corresponding values.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]|string[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */


  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = compareAscending(objCriteria[index], othCriteria[index]);

      if (result) {
        if (index >= ordersLength) {
          return result;
        }

        var order = orders[index];
        return result * (order == 'desc' ? -1 : 1);
      }
    } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


    return object.index - other.index;
  }
  /**
   * Creates an array that is the composition of partially applied arguments,
   * placeholders, and provided arguments into a single array of arguments.
   *
   * @private
   * @param {Array} args The provided arguments.
   * @param {Array} partials The arguments to prepend to those provided.
   * @param {Array} holders The `partials` placeholder indexes.
   * @params {boolean} [isCurried] Specify composing for a curried function.
   * @returns {Array} Returns the new array of composed arguments.
   */


  function composeArgs(args, partials, holders, isCurried) {
    var argsIndex = -1,
        argsLength = args.length,
        holdersLength = holders.length,
        leftIndex = -1,
        leftLength = partials.length,
        rangeLength = nativeMax(argsLength - holdersLength, 0),
        result = Array(leftLength + rangeLength),
        isUncurried = !isCurried;

    while (++leftIndex < leftLength) {
      result[leftIndex] = partials[leftIndex];
    }

    while (++argsIndex < holdersLength) {
      if (isUncurried || argsIndex < argsLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
    }

    while (rangeLength--) {
      result[leftIndex++] = args[argsIndex++];
    }

    return result;
  }
  /**
   * This function is like `composeArgs` except that the arguments composition
   * is tailored for `_.partialRight`.
   *
   * @private
   * @param {Array} args The provided arguments.
   * @param {Array} partials The arguments to append to those provided.
   * @param {Array} holders The `partials` placeholder indexes.
   * @params {boolean} [isCurried] Specify composing for a curried function.
   * @returns {Array} Returns the new array of composed arguments.
   */


  function composeArgsRight(args, partials, holders, isCurried) {
    var argsIndex = -1,
        argsLength = args.length,
        holdersIndex = -1,
        holdersLength = holders.length,
        rightIndex = -1,
        rightLength = partials.length,
        rangeLength = nativeMax(argsLength - holdersLength, 0),
        result = Array(rangeLength + rightLength),
        isUncurried = !isCurried;

    while (++argsIndex < rangeLength) {
      result[argsIndex] = args[argsIndex];
    }

    var offset = argsIndex;

    while (++rightIndex < rightLength) {
      result[offset + rightIndex] = partials[rightIndex];
    }

    while (++holdersIndex < holdersLength) {
      if (isUncurried || argsIndex < argsLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
    }

    return result;
  }
  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */


  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }
  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */


  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }

    return object;
  }
  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */


  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */


  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }
  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */


  function createAssigner(assigner) {
    return baseRest(function (object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }

      object = Object(object);

      while (++index < length) {
        var source = sources[index];

        if (source) {
          assigner(object, source, index, customizer);
        }
      }

      return object;
    });
  }
  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */


  function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
      if (collection == null) {
        return collection;
      }

      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }

      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }

      return collection;
    };
  }
  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */


  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }
  /**
   * Creates a function that wraps `func` to invoke it with the optional `this`
   * binding of `thisArg`.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @returns {Function} Returns the new wrapped function.
   */


  function createBind(func, bitmask, thisArg) {
    var isBind = bitmask & WRAP_BIND_FLAG,
        Ctor = createCtor(func);

    function wrapper() {
      var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
      return fn.apply(isBind ? thisArg : this, arguments);
    }

    return wrapper;
  }
  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */


  function createCaseFirst(methodName) {
    return function (string) {
      string = toString(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  /**
   * Creates a function that produces an instance of `Ctor` regardless of
   * whether it was invoked as part of a `new` expression or by `call` or `apply`.
   *
   * @private
   * @param {Function} Ctor The constructor to wrap.
   * @returns {Function} Returns the new wrapped function.
   */


  function createCtor(Ctor) {
    return function () {
      // Use a `switch` statement to work with class constructors. See
      // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
      // for more details.
      var args = arguments;

      switch (args.length) {
        case 0:
          return new Ctor();

        case 1:
          return new Ctor(args[0]);

        case 2:
          return new Ctor(args[0], args[1]);

        case 3:
          return new Ctor(args[0], args[1], args[2]);

        case 4:
          return new Ctor(args[0], args[1], args[2], args[3]);

        case 5:
          return new Ctor(args[0], args[1], args[2], args[3], args[4]);

        case 6:
          return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

        case 7:
          return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
      }

      var thisBinding = baseCreate(Ctor.prototype),
          result = Ctor.apply(thisBinding, args); // Mimic the constructor's `return` behavior.
      // See https://es5.github.io/#x13.2.2 for more details.

      return isObject(result) ? result : thisBinding;
    };
  }
  /**
   * Creates a function that wraps `func` to enable currying.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {number} arity The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */


  function createCurry(func, bitmask, arity) {
    var Ctor = createCtor(func);

    function wrapper() {
      var length = arguments.length,
          args = Array(length),
          index = length,
          placeholder = getHolder(wrapper);

      while (index--) {
        args[index] = arguments[index];
      }

      var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
      length -= holders.length;

      if (length < arity) {
        return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
      }

      var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
      return apply(fn, this, args);
    }

    return wrapper;
  }
  /**
   * Creates a `_.find` or `_.findLast` function.
   *
   * @private
   * @param {Function} findIndexFunc The function to find the collection index.
   * @returns {Function} Returns the new find function.
   */


  function createFind(findIndexFunc) {
    return function (collection, predicate, fromIndex) {
      var iterable = Object(collection);

      if (!isArrayLike(collection)) {
        var iteratee = getIteratee(predicate, 3);
        collection = keys(collection);

        predicate = function predicate(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }

      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
  }
  /**
   * Creates a function that wraps `func` to invoke it with optional `this`
   * binding of `thisArg`, partial application, and currying.
   *
   * @private
   * @param {Function|string} func The function or method name to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to prepend to those provided to
   *  the new function.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [partialsRight] The arguments to append to those provided
   *  to the new function.
   * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */


  function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & WRAP_ARY_FLAG,
        isBind = bitmask & WRAP_BIND_FLAG,
        isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
        isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
        isFlip = bitmask & WRAP_FLIP_FLAG,
        Ctor = isBindKey ? undefined : createCtor(func);

    function wrapper() {
      var length = arguments.length,
          args = Array(length),
          index = length;

      while (index--) {
        args[index] = arguments[index];
      }

      if (isCurried) {
        var placeholder = getHolder(wrapper),
            holdersCount = countHolders(args, placeholder);
      }

      if (partials) {
        args = composeArgs(args, partials, holders, isCurried);
      }

      if (partialsRight) {
        args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
      }

      length -= holdersCount;

      if (isCurried && length < arity) {
        var newHolders = replaceHolders(args, placeholder);
        return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
      }

      var thisBinding = isBind ? thisArg : this,
          fn = isBindKey ? thisBinding[func] : func;
      length = args.length;

      if (argPos) {
        args = reorder(args, argPos);
      } else if (isFlip && length > 1) {
        args.reverse();
      }

      if (isAry && ary < length) {
        args.length = ary;
      }

      if (this && this !== root && this instanceof wrapper) {
        fn = Ctor || createCtor(fn);
      }

      return fn.apply(thisBinding, args);
    }

    return wrapper;
  }
  /**
   * Creates a function that wraps `func` to invoke it with the `this` binding
   * of `thisArg` and `partials` prepended to the arguments it receives.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} partials The arguments to prepend to those provided to
   *  the new function.
   * @returns {Function} Returns the new wrapped function.
   */


  function createPartial(func, bitmask, thisArg, partials) {
    var isBind = bitmask & WRAP_BIND_FLAG,
        Ctor = createCtor(func);

    function wrapper() {
      var argsIndex = -1,
          argsLength = arguments.length,
          leftIndex = -1,
          leftLength = partials.length,
          args = Array(leftLength + argsLength),
          fn = this && this !== root && this instanceof wrapper ? Ctor : func;

      while (++leftIndex < leftLength) {
        args[leftIndex] = partials[leftIndex];
      }

      while (argsLength--) {
        args[leftIndex++] = arguments[++argsIndex];
      }

      return apply(fn, isBind ? thisArg : this, args);
    }

    return wrapper;
  }
  /**
   * Creates a function that wraps `func` to continue currying.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {Function} wrapFunc The function to create the `func` wrapper.
   * @param {*} placeholder The placeholder value.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to prepend to those provided to
   *  the new function.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */


  function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
    var isCurry = bitmask & WRAP_CURRY_FLAG,
        newHolders = isCurry ? holders : undefined,
        newHoldersRight = isCurry ? undefined : holders,
        newPartials = isCurry ? partials : undefined,
        newPartialsRight = isCurry ? undefined : partials;
    bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

    if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
      bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
    }

    var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];
    var result = wrapFunc.apply(undefined, newData);

    if (isLaziable(func)) {
      setData(result, newData);
    }

    result.placeholder = placeholder;
    return setWrapToString(result, func, bitmask);
  }
  /**
   * Creates a set object of `values`.
   *
   * @private
   * @param {Array} values The values to add to the set.
   * @returns {Object} Returns the new set.
   */


  var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
    return new Set(values);
  };
  /**
   * Creates a function that either curries or invokes `func` with optional
   * `this` binding and partially applied arguments.
   *
   * @private
   * @param {Function|string} func The function or method name to wrap.
   * @param {number} bitmask The bitmask flags.
   *    1 - `_.bind`
   *    2 - `_.bindKey`
   *    4 - `_.curry` or `_.curryRight` of a bound function
   *    8 - `_.curry`
   *   16 - `_.curryRight`
   *   32 - `_.partial`
   *   64 - `_.partialRight`
   *  128 - `_.rearg`
   *  256 - `_.ary`
   *  512 - `_.flip`
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to be partially applied.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */

  function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;

    if (!isBindKey && typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var length = partials ? partials.length : 0;

    if (!length) {
      bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
      partials = holders = undefined;
    }

    ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
    arity = arity === undefined ? arity : toInteger(arity);
    length -= holders ? holders.length : 0;

    if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
      var partialsRight = partials,
          holdersRight = holders;
      partials = holders = undefined;
    }

    var data = isBindKey ? undefined : getData(func);
    var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

    if (data) {
      mergeData(newData, data);
    }

    func = newData[0];
    bitmask = newData[1];
    thisArg = newData[2];
    partials = newData[3];
    holders = newData[4];
    arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);

    if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
      bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
    }

    if (!bitmask || bitmask == WRAP_BIND_FLAG) {
      var result = createBind(func, bitmask, thisArg);
    } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
      result = createCurry(func, bitmask, arity);
    } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
      result = createPartial(func, bitmask, thisArg, partials);
    } else {
      result = createHybrid.apply(undefined, newData);
    }

    var setter = data ? baseSetData : setData;
    return setWrapToString(setter(result, newData), func, bitmask);
  }
  /**
   * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
   * objects.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {string} key The key of the property to inspect.
   * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
   */


  function customOmitClone(value) {
    return isPlainObject(value) ? undefined : value;
  }
  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */


  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    } // Assume cyclic values are equal.


    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array); // Ignore non-index properties.

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      } // Recursively compare arrays (susceptible to call stack limits).


      if (seen) {
        if (!arraySome(other, function (othValue, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }
  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */


  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        } // Assume cyclic values are equal.


        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }
  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */


  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    } // Assume cyclic values are equal.


    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      } // Recursively compare objects (susceptible to call stack limits).


      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }
  /**
   * A specialized version of `baseRest` which flattens the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @returns {Function} Returns the new function.
   */


  function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + '');
  }
  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }
  /**
   * Gets metadata for `func`.
   *
   * @private
   * @param {Function} func The function to query.
   * @returns {*} Returns the metadata for `func`.
   */


  var getData = !metaMap ? noop : function (func) {
    return metaMap.get(func);
  };
  /**
   * Gets the name of `func`.
   *
   * @private
   * @param {Function} func The function to query.
   * @returns {string} Returns the function name.
   */

  function getFuncName(func) {
    var result = func.name + '',
        array = realNames[result],
        length = hasOwnProperty.call(realNames, result) ? array.length : 0;

    while (length--) {
      var data = array[length],
          otherFunc = data.func;

      if (otherFunc == null || otherFunc == func) {
        return data.name;
      }
    }

    return result;
  }
  /**
   * Gets the argument placeholder value for `func`.
   *
   * @private
   * @param {Function} func The function to inspect.
   * @returns {*} Returns the placeholder value.
   */


  function getHolder(func) {
    var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
    return object.placeholder;
  }
  /**
   * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
   * this function returns the custom method, otherwise it returns `baseIteratee`.
   * If arguments are provided, the chosen function is invoked with them and
   * its result is returned.
   *
   * @private
   * @param {*} [value] The value to convert to an iteratee.
   * @param {number} [arity] The arity of the created iteratee.
   * @returns {Function} Returns the chosen function or its result.
   */


  function getIteratee() {
    var result = lodash.iteratee || iteratee;
    result = result === iteratee ? baseIteratee : result;
    return arguments.length ? result(arguments[0], arguments[1]) : result;
  }
  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */


  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }
  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */


  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }

    return result;
  }
  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */


  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */


  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }
  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */


  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];

    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }

    return result;
  };
  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;

          case mapCtorString:
            return mapTag;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag;

          case weakMapCtorString:
            return weakMapTag;
        }
      }

      return result;
    };
  }
  /**
   * Gets the view, applying any `transforms` to the `start` and `end` positions.
   *
   * @private
   * @param {number} start The start of the view.
   * @param {number} end The end of the view.
   * @param {Array} transforms The transformations to apply to the view.
   * @returns {Object} Returns an object containing the `start` and `end`
   *  positions of the view.
   */


  function getView(start, end, transforms) {
    var index = -1,
        length = transforms.length;

    while (++index < length) {
      var data = transforms[index],
          size = data.size;

      switch (data.type) {
        case 'drop':
          start += size;
          break;

        case 'dropRight':
          end -= size;
          break;

        case 'take':
          end = nativeMin(end, start + size);
          break;

        case 'takeRight':
          start = nativeMax(start, end - size);
          break;
      }
    }

    return {
      'start': start,
      'end': end
    };
  }
  /**
   * Extracts wrapper details from the `source` body comment.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {Array} Returns the wrapper details.
   */


  function getWrapDetails(source) {
    var match = source.match(reWrapDetails);
    return match ? match[1].split(reSplitDetails) : [];
  }
  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */


  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }
  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */


  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }

    return result;
  }
  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */


  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */


  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;

    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return new Ctor();

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return new Ctor();

      case symbolTag:
        return cloneSymbol(object);
    }
  }
  /**
   * Inserts wrapper `details` in a comment at the top of the `source` body.
   *
   * @private
   * @param {string} source The source to modify.
   * @returns {Array} details The details to insert.
   * @returns {string} Returns the modified source.
   */


  function insertWrapDetails(source, details) {
    var length = details.length;

    if (!length) {
      return source;
    }

    var lastIndex = length - 1;
    details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
    details = details.join(length > 2 ? ', ' : ' ');
    return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
  }
  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */


  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */


  function isIndex(value, length) {
    var type = (0, _typeof2.default)(value);
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }
  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */


  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }

    var type = (0, _typeof2.default)(index);

    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
      return eq(object[index], value);
    }

    return false;
  }
  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */


  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }

    var type = (0, _typeof2.default)(value);

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */


  function isKeyable(value) {
    var type = (0, _typeof2.default)(value);
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }
  /**
   * Checks if `func` has a lazy counterpart.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
   *  else `false`.
   */


  function isLaziable(func) {
    var funcName = getFuncName(func),
        other = lodash[funcName];

    if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
      return false;
    }

    if (func === other) {
      return true;
    }

    var data = getData(other);
    return !!data && func === data[0];
  }
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */


  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }
  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */


  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */


  function matchesStrictComparable(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }

      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }
  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */


  function memoizeCapped(func) {
    var result = memoize(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }
  /**
   * Merges the function metadata of `source` into `data`.
   *
   * Merging metadata reduces the number of wrappers used to invoke a function.
   * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
   * may be applied regardless of execution order. Methods like `_.ary` and
   * `_.rearg` modify function arguments, making the order in which they are
   * executed important, preventing the merging of metadata. However, we make
   * an exception for a safe combined case where curried functions have `_.ary`
   * and or `_.rearg` applied.
   *
   * @private
   * @param {Array} data The destination metadata.
   * @param {Array} source The source metadata.
   * @returns {Array} Returns `data`.
   */


  function mergeData(data, source) {
    var bitmask = data[1],
        srcBitmask = source[1],
        newBitmask = bitmask | srcBitmask,
        isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
    var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG; // Exit early if metadata can't be merged.

    if (!(isCommon || isCombo)) {
      return data;
    } // Use source `thisArg` if available.


    if (srcBitmask & WRAP_BIND_FLAG) {
      data[2] = source[2]; // Set when currying a bound function.

      newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
    } // Compose partial arguments.


    var value = source[3];

    if (value) {
      var partials = data[3];
      data[3] = partials ? composeArgs(partials, value, source[4]) : value;
      data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
    } // Compose partial right arguments.


    value = source[5];

    if (value) {
      partials = data[5];
      data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
      data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
    } // Use source `argPos` if available.


    value = source[7];

    if (value) {
      data[7] = value;
    } // Use source `ary` if it's smaller.


    if (srcBitmask & WRAP_ARY_FLAG) {
      data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
    } // Use source `arity` if one is not provided.


    if (data[9] == null) {
      data[9] = source[9];
    } // Use source `func` and merge bitmasks.


    data[0] = source[0];
    data[1] = newBitmask;
    return data;
  }
  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */


  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */


  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  /**
   * Gets the parent value at `path` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} path The path to get the parent value of.
   * @returns {*} Returns the parent value.
   */


  function parent(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }
  /**
   * Reorder `array` according to the specified indexes where the element at
   * the first index is assigned as the first element, the element at
   * the second index is assigned as the second element, and so on.
   *
   * @private
   * @param {Array} array The array to reorder.
   * @param {Array} indexes The arranged array indexes.
   * @returns {Array} Returns `array`.
   */


  function reorder(array, indexes) {
    var arrLength = array.length,
        length = nativeMin(indexes.length, arrLength),
        oldArray = copyArray(array);

    while (length--) {
      var index = indexes[length];
      array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
    }

    return array;
  }
  /**
   * Sets metadata for `func`.
   *
   * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
   * period of time, it will trip its breaker and transition to an identity
   * function to avoid garbage collection pauses in V8. See
   * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
   * for more details.
   *
   * @private
   * @param {Function} func The function to associate metadata with.
   * @param {*} data The metadata.
   * @returns {Function} Returns `func`.
   */


  var setData = shortOut(baseSetData);
  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var setToString = shortOut(baseSetToString);
  /**
   * Sets the `toString` method of `wrapper` to mimic the source of `reference`
   * with wrapper details in a comment at the top of the source body.
   *
   * @private
   * @param {Function} wrapper The function to modify.
   * @param {Function} reference The reference function.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @returns {Function} Returns `wrapper`.
   */

  function setWrapToString(wrapper, reference, bitmask) {
    var source = reference + '';
    return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
  }
  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */


  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }
  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */


  var stringToPath = memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46
    /* . */
    ) {
      result.push('');
    }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });
  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */

  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */


  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }
  /**
   * Updates wrapper `details` based on `bitmask` flags.
   *
   * @private
   * @returns {Array} details The details to modify.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @returns {Array} Returns `details`.
   */


  function updateWrapDetails(details, bitmask) {
    arrayEach(wrapFlags, function (pair) {
      var value = '_.' + pair[0];

      if (bitmask & pair[1] && !arrayIncludes(details, value)) {
        details.push(value);
      }
    });
    return details.sort();
  }
  /**
   * Creates a clone of `wrapper`.
   *
   * @private
   * @param {Object} wrapper The wrapper to clone.
   * @returns {Object} Returns the cloned wrapper.
   */


  function wrapperClone(wrapper) {
    if (wrapper instanceof LazyWrapper) {
      return wrapper.clone();
    }

    var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
    result.__actions__ = copyArray(wrapper.__actions__);
    result.__index__ = wrapper.__index__;
    result.__values__ = wrapper.__values__;
    return result;
  }
  /*------------------------------------------------------------------------*/

  /**
   * Creates an array with all falsey values removed. The values `false`, `null`,
   * `0`, `""`, `undefined`, and `NaN` are falsey.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to compact.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.compact([0, 1, false, 2, '', 3]);
   * // => [1, 2, 3]
   */


  function compact(array) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (value) {
        result[resIndex++] = value;
      }
    }

    return result;
  }
  /**
   * Creates a new array concatenating `array` with any additional arrays
   * and/or values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to concatenate.
   * @param {...*} [values] The values to concatenate.
   * @returns {Array} Returns the new concatenated array.
   * @example
   *
   * var array = [1];
   * var other = _.concat(array, 2, [3], [[4]]);
   *
   * console.log(other);
   * // => [1, 2, 3, [4]]
   *
   * console.log(array);
   * // => [1]
   */


  function concat() {
    var length = arguments.length;

    if (!length) {
      return [];
    }

    var args = Array(length - 1),
        array = arguments[0],
        index = length;

    while (index--) {
      args[index - 1] = arguments[index];
    }

    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
  }
  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */


  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;

    if (!length) {
      return -1;
    }

    var index = fromIndex == null ? 0 : toInteger(fromIndex);

    if (index < 0) {
      index = nativeMax(length + index, 0);
    }

    return baseFindIndex(array, getIteratee(predicate, 3), index);
  }
  /**
   * This method is like `_.findIndex` except that it iterates over elements
   * of `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=array.length-1] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': true },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': false }
   * ];
   *
   * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
   * // => 2
   *
   * // The `_.matches` iteratee shorthand.
   * _.findLastIndex(users, { 'user': 'barney', 'active': true });
   * // => 0
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findLastIndex(users, ['active', false]);
   * // => 2
   *
   * // The `_.property` iteratee shorthand.
   * _.findLastIndex(users, 'active');
   * // => 0
   */


  function findLastIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;

    if (!length) {
      return -1;
    }

    var index = length - 1;

    if (fromIndex !== undefined) {
      index = toInteger(fromIndex);
      index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
    }

    return baseFindIndex(array, getIteratee(predicate, 3), index, true);
  }
  /**
   * Flattens `array` a single level deep.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flatten([1, [2, [3, [4]], 5]]);
   * // => [1, 2, [3, [4]], 5]
   */


  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }
  /**
   * Gets the last element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the last element of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   */


  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }
  /**
   * Reverses `array` so that the first element becomes the last, the second
   * element becomes the second to last, and so on.
   *
   * **Note:** This method mutates `array` and is based on
   * [`Array#reverse`](https://mdn.io/Array/reverse).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @returns {Array} Returns `array`.
   * @example
   *
   * var array = [1, 2, 3];
   *
   * _.reverse(array);
   * // => [3, 2, 1]
   *
   * console.log(array);
   * // => [3, 2, 1]
   */


  function reverse(array) {
    return array == null ? array : nativeReverse.call(array);
  }
  /**
   * Creates a slice of `array` with `n` elements taken from the beginning.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {number} [n=1] The number of elements to take.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.take([1, 2, 3]);
   * // => [1]
   *
   * _.take([1, 2, 3], 2);
   * // => [1, 2]
   *
   * _.take([1, 2, 3], 5);
   * // => [1, 2, 3]
   *
   * _.take([1, 2, 3], 0);
   * // => []
   */


  function take(array, n, guard) {
    if (!(array && array.length)) {
      return [];
    }

    n = guard || n === undefined ? 1 : toInteger(n);
    return baseSlice(array, 0, n < 0 ? 0 : n);
  }
  /**
   * Creates a slice of `array` with `n` elements taken from the end.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {number} [n=1] The number of elements to take.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.takeRight([1, 2, 3]);
   * // => [3]
   *
   * _.takeRight([1, 2, 3], 2);
   * // => [2, 3]
   *
   * _.takeRight([1, 2, 3], 5);
   * // => [1, 2, 3]
   *
   * _.takeRight([1, 2, 3], 0);
   * // => []
   */


  function takeRight(array, n, guard) {
    var length = array == null ? 0 : array.length;

    if (!length) {
      return [];
    }

    n = guard || n === undefined ? 1 : toInteger(n);
    n = length - n;
    return baseSlice(array, n < 0 ? 0 : n, length);
  }
  /**
   * Creates a duplicate-free version of an array, using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons, in which only the first occurrence of each element
   * is kept. The order of result values is determined by the order they occur
   * in the array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @returns {Array} Returns the new duplicate free array.
   * @example
   *
   * _.uniq([2, 1, 2]);
   * // => [2, 1]
   */


  function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
  }
  /**
   * Creates an array excluding all given values using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * **Note:** Unlike `_.pull`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...*} [values] The values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.difference, _.xor
   * @example
   *
   * _.without([2, 1, 2, 3], 1, 2);
   * // => [3]
   */


  var without = baseRest(function (array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, values) : [];
  });
  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` wrapper instance that wraps `value` with explicit method
   * chain sequences enabled. The result of such sequences must be unwrapped
   * with `_#value`.
   *
   * @static
   * @memberOf _
   * @since 1.3.0
   * @category Seq
   * @param {*} value The value to wrap.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36 },
   *   { 'user': 'fred',    'age': 40 },
   *   { 'user': 'pebbles', 'age': 1 }
   * ];
   *
   * var youngest = _
   *   .chain(users)
   *   .sortBy('age')
   *   .map(function(o) {
   *     return o.user + ' is ' + o.age;
   *   })
   *   .head()
   *   .value();
   * // => 'pebbles is 1'
   */

  function chain(value) {
    var result = lodash(value);
    result.__chain__ = true;
    return result;
  }
  /**
   * This method invokes `interceptor` and returns `value`. The interceptor
   * is invoked with one argument; (value). The purpose of this method is to
   * "tap into" a method chain sequence in order to modify intermediate results.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Seq
   * @param {*} value The value to provide to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {*} Returns `value`.
   * @example
   *
   * _([1, 2, 3])
   *  .tap(function(array) {
   *    // Mutate input array.
   *    array.pop();
   *  })
   *  .reverse()
   *  .value();
   * // => [2, 1]
   */


  function tap(value, interceptor) {
    interceptor(value);
    return value;
  }
  /**
   * This method is like `_.tap` except that it returns the result of `interceptor`.
   * The purpose of this method is to "pass thru" values replacing intermediate
   * results in a method chain sequence.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Seq
   * @param {*} value The value to provide to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {*} Returns the result of `interceptor`.
   * @example
   *
   * _('  abc  ')
   *  .chain()
   *  .trim()
   *  .thru(function(value) {
   *    return [value];
   *  })
   *  .value();
   * // => ['abc']
   */


  function thru(value, interceptor) {
    return interceptor(value);
  }
  /**
   * This method is the wrapper version of `_.at`.
   *
   * @name at
   * @memberOf _
   * @since 1.0.0
   * @category Seq
   * @param {...(string|string[])} [paths] The property paths to pick.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
   *
   * _(object).at(['a[0].b.c', 'a[1]']).value();
   * // => [3, 4]
   */


  var wrapperAt = flatRest(function (paths) {
    var length = paths.length,
        start = length ? paths[0] : 0,
        value = this.__wrapped__,
        interceptor = function interceptor(object) {
      return baseAt(object, paths);
    };

    if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
      return this.thru(interceptor);
    }

    value = value.slice(start, +start + (length ? 1 : 0));

    value.__actions__.push({
      'func': thru,
      'args': [interceptor],
      'thisArg': undefined
    });

    return new LodashWrapper(value, this.__chain__).thru(function (array) {
      if (length && !array.length) {
        array.push(undefined);
      }

      return array;
    });
  });
  /**
   * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
   *
   * @name chain
   * @memberOf _
   * @since 0.1.0
   * @category Seq
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 }
   * ];
   *
   * // A sequence without explicit chaining.
   * _(users).head();
   * // => { 'user': 'barney', 'age': 36 }
   *
   * // A sequence with explicit chaining.
   * _(users)
   *   .chain()
   *   .head()
   *   .pick('user')
   *   .value();
   * // => { 'user': 'barney' }
   */

  function wrapperChain() {
    return chain(this);
  }
  /**
   * Executes the chain sequence and returns the wrapped result.
   *
   * @name commit
   * @memberOf _
   * @since 3.2.0
   * @category Seq
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var array = [1, 2];
   * var wrapped = _(array).push(3);
   *
   * console.log(array);
   * // => [1, 2]
   *
   * wrapped = wrapped.commit();
   * console.log(array);
   * // => [1, 2, 3]
   *
   * wrapped.last();
   * // => 3
   *
   * console.log(array);
   * // => [1, 2, 3]
   */


  function wrapperCommit() {
    return new LodashWrapper(this.value(), this.__chain__);
  }
  /**
   * Gets the next value on a wrapped object following the
   * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
   *
   * @name next
   * @memberOf _
   * @since 4.0.0
   * @category Seq
   * @returns {Object} Returns the next iterator value.
   * @example
   *
   * var wrapped = _([1, 2]);
   *
   * wrapped.next();
   * // => { 'done': false, 'value': 1 }
   *
   * wrapped.next();
   * // => { 'done': false, 'value': 2 }
   *
   * wrapped.next();
   * // => { 'done': true, 'value': undefined }
   */


  function wrapperNext() {
    if (this.__values__ === undefined) {
      this.__values__ = toArray(this.value());
    }

    var done = this.__index__ >= this.__values__.length,
        value = done ? undefined : this.__values__[this.__index__++];
    return {
      'done': done,
      'value': value
    };
  }
  /**
   * Enables the wrapper to be iterable.
   *
   * @name Symbol.iterator
   * @memberOf _
   * @since 4.0.0
   * @category Seq
   * @returns {Object} Returns the wrapper object.
   * @example
   *
   * var wrapped = _([1, 2]);
   *
   * wrapped[Symbol.iterator]() === wrapped;
   * // => true
   *
   * Array.from(wrapped);
   * // => [1, 2]
   */


  function wrapperToIterator() {
    return this;
  }
  /**
   * Creates a clone of the chain sequence planting `value` as the wrapped value.
   *
   * @name plant
   * @memberOf _
   * @since 3.2.0
   * @category Seq
   * @param {*} value The value to plant.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * var wrapped = _([1, 2]).map(square);
   * var other = wrapped.plant([3, 4]);
   *
   * other.value();
   * // => [9, 16]
   *
   * wrapped.value();
   * // => [1, 4]
   */


  function wrapperPlant(value) {
    var result,
        parent = this;

    while (parent instanceof baseLodash) {
      var clone = wrapperClone(parent);
      clone.__index__ = 0;
      clone.__values__ = undefined;

      if (result) {
        previous.__wrapped__ = clone;
      } else {
        result = clone;
      }

      var previous = clone;
      parent = parent.__wrapped__;
    }

    previous.__wrapped__ = value;
    return result;
  }
  /**
   * This method is the wrapper version of `_.reverse`.
   *
   * **Note:** This method mutates the wrapped array.
   *
   * @name reverse
   * @memberOf _
   * @since 0.1.0
   * @category Seq
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var array = [1, 2, 3];
   *
   * _(array).reverse().value()
   * // => [3, 2, 1]
   *
   * console.log(array);
   * // => [3, 2, 1]
   */


  function wrapperReverse() {
    var value = this.__wrapped__;

    if (value instanceof LazyWrapper) {
      var wrapped = value;

      if (this.__actions__.length) {
        wrapped = new LazyWrapper(this);
      }

      wrapped = wrapped.reverse();

      wrapped.__actions__.push({
        'func': thru,
        'args': [reverse],
        'thisArg': undefined
      });

      return new LodashWrapper(wrapped, this.__chain__);
    }

    return this.thru(reverse);
  }
  /**
   * Executes the chain sequence to resolve the unwrapped value.
   *
   * @name value
   * @memberOf _
   * @since 0.1.0
   * @alias toJSON, valueOf
   * @category Seq
   * @returns {*} Returns the resolved unwrapped value.
   * @example
   *
   * _([1, 2, 3]).value();
   * // => [1, 2, 3]
   */


  function wrapperValue() {
    return baseWrapperValue(this.__wrapped__, this.__actions__);
  }
  /*------------------------------------------------------------------------*/

  /**
   * Checks if `predicate` returns truthy for **all** elements of `collection`.
   * Iteration is stopped once `predicate` returns falsey. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * **Note:** This method returns `true` for
   * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
   * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
   * elements of empty collections.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes'], Boolean);
   * // => false
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': false },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.every(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.every(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.every(users, 'active');
   * // => false
   */


  function every(collection, predicate, guard) {
    var func = isArray(collection) ? arrayEvery : baseEvery;

    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = undefined;
    }

    return func(collection, getIteratee(predicate, 3));
  }
  /**
   * Iterates over elements of `collection`, returning an array of all elements
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * **Note:** Unlike `_.remove`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   * @see _.reject
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * _.filter(users, function(o) { return !o.active; });
   * // => objects for ['fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, { 'age': 36, 'active': true });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, ['active', false]);
   * // => objects for ['fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.filter(users, 'active');
   * // => objects for ['barney']
   */


  function filter(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, getIteratee(predicate, 3));
  }
  /**
   * Iterates over elements of `collection`, returning the first element
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36, 'active': true },
   *   { 'user': 'fred',    'age': 40, 'active': false },
   *   { 'user': 'pebbles', 'age': 1,  'active': true }
   * ];
   *
   * _.find(users, function(o) { return o.age < 40; });
   * // => object for 'barney'
   *
   * // The `_.matches` iteratee shorthand.
   * _.find(users, { 'age': 1, 'active': true });
   * // => object for 'pebbles'
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.find(users, ['active', false]);
   * // => object for 'fred'
   *
   * // The `_.property` iteratee shorthand.
   * _.find(users, 'active');
   * // => object for 'barney'
   */


  var find = createFind(findIndex);
  /**
   * This method is like `_.find` except that it iterates over elements of
   * `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=collection.length-1] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * _.findLast([1, 2, 3, 4], function(n) {
   *   return n % 2 == 1;
   * });
   * // => 3
   */

  var findLast = createFind(findLastIndex);
  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */

  function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, getIteratee(iteratee, 3));
  }
  /**
   * Creates an array of values by running each element in `collection` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * _.map([4, 8], square);
   * // => [16, 64]
   *
   * _.map({ 'a': 4, 'b': 8 }, square);
   * // => [16, 64] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */


  function map(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, getIteratee(iteratee, 3));
  }
  /**
   * This method is like `_.sortBy` except that it allows specifying the sort
   * orders of the iteratees to sort by. If `orders` is unspecified, all values
   * are sorted in ascending order. Otherwise, specify an order of "desc" for
   * descending or "asc" for ascending sort order of corresponding values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @param {string[]} [orders] The sort orders of `iteratees`.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 34 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 36 }
   * ];
   *
   * // Sort by `user` in ascending order and by `age` in descending order.
   * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   */


  function orderBy(collection, iteratees, orders, guard) {
    if (collection == null) {
      return [];
    }

    if (!isArray(iteratees)) {
      iteratees = iteratees == null ? [] : [iteratees];
    }

    orders = guard ? undefined : orders;

    if (!isArray(orders)) {
      orders = orders == null ? [] : [orders];
    }

    return baseOrderBy(collection, iteratees, orders);
  }
  /**
   * Reduces `collection` to a value which is the accumulated result of running
   * each element in `collection` thru `iteratee`, where each successive
   * invocation is supplied the return value of the previous. If `accumulator`
   * is not given, the first element of `collection` is used as the initial
   * value. The iteratee is invoked with four arguments:
   * (accumulator, value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.reduce`, `_.reduceRight`, and `_.transform`.
   *
   * The guarded methods are:
   * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
   * and `sortBy`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @returns {*} Returns the accumulated value.
   * @see _.reduceRight
   * @example
   *
   * _.reduce([1, 2], function(sum, n) {
   *   return sum + n;
   * }, 0);
   * // => 3
   *
   * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
   *   (result[value] || (result[value] = [])).push(key);
   *   return result;
   * }, {});
   * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
   */


  function reduce(collection, iteratee, accumulator) {
    var func = isArray(collection) ? arrayReduce : baseReduce,
        initAccum = arguments.length < 3;
    return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
  }
  /**
   * The opposite of `_.filter`; this method returns the elements of `collection`
   * that `predicate` does **not** return truthy for.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   * @see _.filter
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': false },
   *   { 'user': 'fred',   'age': 40, 'active': true }
   * ];
   *
   * _.reject(users, function(o) { return !o.active; });
   * // => objects for ['fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.reject(users, { 'age': 40, 'active': true });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.reject(users, ['active', false]);
   * // => objects for ['fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.reject(users, 'active');
   * // => objects for ['barney']
   */


  function reject(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, negate(getIteratee(predicate, 3)));
  }
  /**
   * Gets the size of `collection` by returning its length for array-like
   * values or the number of own enumerable string keyed properties for objects.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns the collection size.
   * @example
   *
   * _.size([1, 2, 3]);
   * // => 3
   *
   * _.size({ 'a': 1, 'b': 2 });
   * // => 2
   *
   * _.size('pebbles');
   * // => 7
   */


  function size(collection) {
    if (collection == null) {
      return 0;
    }

    if (isArrayLike(collection)) {
      return isString(collection) ? stringSize(collection) : collection.length;
    }

    var tag = getTag(collection);

    if (tag == mapTag || tag == setTag) {
      return collection.size;
    }

    return baseKeys(collection).length;
  }
  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection thru each iteratee. This method
   * performs a stable sort, that is, it preserves the original sort order of
   * equal elements. The iteratees are invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {...(Function|Function[])} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 34 }
   * ];
   *
   * _.sortBy(users, [function(o) { return o.user; }]);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   *
   * _.sortBy(users, ['user', 'age']);
   * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
   */


  var sortBy = baseRest(function (collection, iteratees) {
    if (collection == null) {
      return [];
    }

    var length = iteratees.length;

    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }

    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });
  /*------------------------------------------------------------------------*/

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */

  var now = function now() {
    return root.Date.now();
  };
  /*------------------------------------------------------------------------*/

  /**
   * Creates a function that invokes `func`, with the `this` binding and arguments
   * of the created function, while it's called less than `n` times. Subsequent
   * calls to the created function return the result of the last `func` invocation.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Function
   * @param {number} n The number of calls at which `func` is no longer invoked.
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * jQuery(element).on('click', _.before(5, addContactToList));
   * // => Allows adding up to 4 contacts to the list.
   */


  function before(n, func) {
    var result;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    n = toInteger(n);
    return function () {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }

      if (n <= 1) {
        func = undefined;
      }

      return result;
    };
  }
  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */


  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    wait = toNumber(wait) || 0;

    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time; // Start the timer for the trailing edge.

      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.

      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }

    function timerExpired() {
      var time = now();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } // Restart the timer.


      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.

      if (trailing && lastArgs) {
        return invokeFunc(time);
      }

      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }

      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }

        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }

      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }

      return result;
    }

    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */


  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  } // Expose `MapCache`.


  memoize.Cache = MapCache;
  /**
   * Creates a function that negates the result of the predicate `func`. The
   * `func` predicate is invoked with the `this` binding and arguments of the
   * created function.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Function
   * @param {Function} predicate The predicate to negate.
   * @returns {Function} Returns the new negated function.
   * @example
   *
   * function isEven(n) {
   *   return n % 2 == 0;
   * }
   *
   * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
   * // => [1, 3, 5]
   */

  function negate(predicate) {
    if (typeof predicate != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    return function () {
      var args = arguments;

      switch (args.length) {
        case 0:
          return !predicate.call(this);

        case 1:
          return !predicate.call(this, args[0]);

        case 2:
          return !predicate.call(this, args[0], args[1]);

        case 3:
          return !predicate.call(this, args[0], args[1], args[2]);
      }

      return !predicate.apply(this, args);
    };
  }
  /**
   * Creates a function that is restricted to invoking `func` once. Repeat calls
   * to the function return the value of the first invocation. The `func` is
   * invoked with the `this` binding and arguments of the created function.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var initialize = _.once(createApplication);
   * initialize();
   * initialize();
   * // => `createApplication` is invoked once
   */


  function once(func) {
    return before(2, func);
  }
  /**
   * Creates a function that invokes `func` with `partials` prepended to the
   * arguments it receives. This method is like `_.bind` except it does **not**
   * alter the `this` binding.
   *
   * The `_.partial.placeholder` value, which defaults to `_` in monolithic
   * builds, may be used as a placeholder for partially applied arguments.
   *
   * **Note:** This method doesn't set the "length" property of partially
   * applied functions.
   *
   * @static
   * @memberOf _
   * @since 0.2.0
   * @category Function
   * @param {Function} func The function to partially apply arguments to.
   * @param {...*} [partials] The arguments to be partially applied.
   * @returns {Function} Returns the new partially applied function.
   * @example
   *
   * function greet(greeting, name) {
   *   return greeting + ' ' + name;
   * }
   *
   * var sayHelloTo = _.partial(greet, 'hello');
   * sayHelloTo('fred');
   * // => 'hello fred'
   *
   * // Partially applied with placeholders.
   * var greetFred = _.partial(greet, _, 'fred');
   * greetFred('hi');
   * // => 'hi fred'
   */


  var partial = baseRest(function (func, partials) {
    var holders = replaceHolders(partials, getHolder(partial));
    return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
  });
  /*------------------------------------------------------------------------*/

  /**
   * Creates a shallow clone of `value`.
   *
   * **Note:** This method is loosely based on the
   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
   * and supports cloning arrays, array buffers, booleans, date objects, maps,
   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
   * arrays. The own enumerable properties of `arguments` objects are cloned
   * as plain objects. An empty object is returned for uncloneable values such
   * as error objects, functions, DOM nodes, and WeakMaps.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to clone.
   * @returns {*} Returns the cloned value.
   * @see _.cloneDeep
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var shallow = _.clone(objects);
   * console.log(shallow[0] === objects[0]);
   * // => true
   */

  function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }
  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */


  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */


  var isArguments = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */

  var isArray = Array.isArray;
  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */


  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */


  var isBuffer = nativeIsBuffer || stubFalse;
  /**
   * Checks if `value` is an empty object, collection, map, or set.
   *
   * Objects are considered empty if they have no own enumerable string keyed
   * properties.
   *
   * Array-like values such as `arguments` objects, arrays, buffers, strings, or
   * jQuery-like collections are considered empty if they have a `length` of `0`.
   * Similarly, maps and sets are considered empty if they have a `size` of `0`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty(null);
   * // => true
   *
   * _.isEmpty(true);
   * // => true
   *
   * _.isEmpty(1);
   * // => true
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({ 'a': 1 });
   * // => false
   */

  function isEmpty(value) {
    if (value == null) {
      return true;
    }

    if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
      return !value.length;
    }

    var tag = getTag(value);

    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }

    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }

    for (var key in value) {
      if (hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  }
  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */


  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */


  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    } // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.


    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */


  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject(value) {
    var type = (0, _typeof2.default)(value);
    return value != null && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike(value) {
    return value != null && (0, _typeof2.default)(value) == 'object';
  }
  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */


  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */

  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }

    var proto = getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */


  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */

  function isString(value) {
    return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */


  function isSymbol(value) {
    return (0, _typeof2.default)(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */


  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  /**
   * Converts `value` to an array.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Array} Returns the converted array.
   * @example
   *
   * _.toArray({ 'a': 1, 'b': 2 });
   * // => [1, 2]
   *
   * _.toArray('abc');
   * // => ['a', 'b', 'c']
   *
   * _.toArray(1);
   * // => []
   *
   * _.toArray(null);
   * // => []
   */

  function toArray(value) {
    if (!value) {
      return [];
    }

    if (isArrayLike(value)) {
      return isString(value) ? stringToArray(value) : copyArray(value);
    }

    if (symIterator && value[symIterator]) {
      return iteratorToArray(value[symIterator]());
    }

    var tag = getTag(value),
        func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
    return func(value);
  }
  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */


  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber(value);

    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }
  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */


  function toInteger(value) {
    var result = toFinite(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */


  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol(value)) {
      return NAN;
    }

    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */


  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */


  function toString(value) {
    return value == null ? '' : baseToString(value);
  }
  /*------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable string keyed properties of source objects to the
   * destination object. Source objects are applied from left to right.
   * Subsequent sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object` and is loosely based on
   * [`Object.assign`](https://mdn.io/Object/assign).
   *
   * @static
   * @memberOf _
   * @since 0.10.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assignIn
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assign({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'c': 3 }
   */


  var assign = createAssigner(function (object, source) {
    if (isPrototype(source) || isArrayLike(source)) {
      copyObject(source, keys(source), object);
      return;
    }

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        assignValue(object, key, source[key]);
      }
    }
  });
  /**
   * This method is like `_.assign` except that it iterates over own and
   * inherited source properties.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @alias extend
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assign
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assignIn({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
   */

  var assignIn = createAssigner(function (object, source) {
    copyObject(source, keysIn(source), object);
  });
  /**
   * Creates an object that inherits from the `prototype` object. If a
   * `properties` object is given, its own enumerable string keyed properties
   * are assigned to the created object.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Object
   * @param {Object} prototype The object to inherit from.
   * @param {Object} [properties] The properties to assign to the object.
   * @returns {Object} Returns the new object.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * function Circle() {
   *   Shape.call(this);
   * }
   *
   * Circle.prototype = _.create(Shape.prototype, {
   *   'constructor': Circle
   * });
   *
   * var circle = new Circle;
   * circle instanceof Circle;
   * // => true
   *
   * circle instanceof Shape;
   * // => true
   */

  function create(prototype, properties) {
    var result = baseCreate(prototype);
    return properties == null ? result : baseAssign(result, properties);
  }
  /**
   * Assigns own and inherited enumerable string keyed properties of source
   * objects to the destination object for all destination properties that
   * resolve to `undefined`. Source objects are applied from left to right.
   * Once a property is set, additional values of the same property are ignored.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.defaultsDeep
   * @example
   *
   * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
   * // => { 'a': 1, 'b': 2 }
   */


  var defaults = baseRest(function (object, sources) {
    object = Object(object);
    var index = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length = 1;
    }

    while (++index < length) {
      var source = sources[index];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;

      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object[key];

        if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          object[key] = source[key];
        }
      }
    }

    return object;
  });
  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */

  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }
  /**
   * Checks if `path` is a direct property of `object`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = { 'a': { 'b': 2 } };
   * var other = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.has(object, 'a');
   * // => true
   *
   * _.has(object, 'a.b');
   * // => true
   *
   * _.has(object, ['a', 'b']);
   * // => true
   *
   * _.has(other, 'a');
   * // => false
   */


  function has(object, path) {
    return object != null && hasPath(object, path, baseHas);
  }
  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */


  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */


  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */


  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  /**
   * Creates an object with the same keys as `object` and values generated
   * by running each own enumerable string keyed property of `object` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, key, object).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Object
   * @param {Object} object The object to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Object} Returns the new mapped object.
   * @see _.mapKeys
   * @example
   *
   * var users = {
   *   'fred':    { 'user': 'fred',    'age': 40 },
   *   'pebbles': { 'user': 'pebbles', 'age': 1 }
   * };
   *
   * _.mapValues(users, function(o) { return o.age; });
   * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
   *
   * // The `_.property` iteratee shorthand.
   * _.mapValues(users, 'age');
   * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
   */


  function mapValues(object, iteratee) {
    var result = {};
    iteratee = getIteratee(iteratee, 3);
    baseForOwn(object, function (value, key, object) {
      baseAssignValue(result, key, iteratee(value, key, object));
    });
    return result;
  }
  /**
   * This method is like `_.assign` except that it recursively merges own and
   * inherited enumerable string keyed properties of source objects into the
   * destination object. Source properties that resolve to `undefined` are
   * skipped if a destination value exists. Array and plain object properties
   * are merged recursively. Other objects and value types are overridden by
   * assignment. Source objects are applied from left to right. Subsequent
   * sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = {
   *   'a': [{ 'b': 2 }, { 'd': 4 }]
   * };
   *
   * var other = {
   *   'a': [{ 'c': 3 }, { 'e': 5 }]
   * };
   *
   * _.merge(object, other);
   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
   */


  var merge = createAssigner(function (object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  /**
   * The opposite of `_.pick`; this method creates an object composed of the
   * own and inherited enumerable property paths of `object` that are not omitted.
   *
   * **Note:** This method is considerably slower than `_.pick`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {...(string|string[])} [paths] The property paths to omit.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.omit(object, ['a', 'c']);
   * // => { 'b': '2' }
   */

  var omit = flatRest(function (object, paths) {
    var result = {};

    if (object == null) {
      return result;
    }

    var isDeep = false;
    paths = arrayMap(paths, function (path) {
      path = castPath(path, object);
      isDeep || (isDeep = path.length > 1);
      return path;
    });
    copyObject(object, getAllKeysIn(object), result);

    if (isDeep) {
      result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    }

    var length = paths.length;

    while (length--) {
      baseUnset(result, paths[length]);
    }

    return result;
  });
  /**
   * Creates an object composed of the picked `object` properties.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {...(string|string[])} [paths] The property paths to pick.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pick(object, ['a', 'c']);
   * // => { 'a': 1, 'c': 3 }
   */

  var pick = flatRest(function (object, paths) {
    return object == null ? {} : basePick(object, paths);
  });
  /**
   * Creates an object composed of the `object` properties `predicate` returns
   * truthy for. The predicate is invoked with two arguments: (value, key).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The source object.
   * @param {Function} [predicate=_.identity] The function invoked per property.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pickBy(object, _.isNumber);
   * // => { 'a': 1, 'c': 3 }
   */

  function pickBy(object, predicate) {
    if (object == null) {
      return {};
    }

    var props = arrayMap(getAllKeysIn(object), function (prop) {
      return [prop];
    });
    predicate = getIteratee(predicate);
    return basePickBy(object, props, function (value, path) {
      return predicate(value, path[0]);
    });
  }
  /**
   * This method is like `_.get` except that if the resolved value is a
   * function it's invoked with the `this` binding of its parent object and
   * its result is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to resolve.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
   *
   * _.result(object, 'a[0].b.c1');
   * // => 3
   *
   * _.result(object, 'a[0].b.c2');
   * // => 4
   *
   * _.result(object, 'a[0].b.c3', 'default');
   * // => 'default'
   *
   * _.result(object, 'a[0].b.c3', _.constant('default'));
   * // => 'default'
   */


  function result(object, path, defaultValue) {
    path = castPath(path, object);
    var index = -1,
        length = path.length; // Ensure the loop is entered when path is empty.

    if (!length) {
      length = 1;
      object = undefined;
    }

    while (++index < length) {
      var value = object == null ? undefined : object[toKey(path[index])];

      if (value === undefined) {
        index = length;
        value = defaultValue;
      }

      object = isFunction(value) ? value.call(object) : value;
    }

    return object;
  }
  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */


  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }
  /*------------------------------------------------------------------------*/

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */


  function capitalize(string) {
    return upperFirst(toString(string).toLowerCase());
  }
  /**
   * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
   * corresponding HTML entities.
   *
   * **Note:** No other characters are escaped. To escape additional
   * characters use a third-party library like [_he_](https://mths.be/he).
   *
   * Though the ">" character is escaped for symmetry, characters like
   * ">" and "/" don't need escaping in HTML and have no special meaning
   * unless they're part of a tag or unquoted attribute value. See
   * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
   * (under "semi-related fun fact") for more details.
   *
   * When working with HTML you should always
   * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
   * XSS vectors.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escape('fred, barney, & pebbles');
   * // => 'fred, barney, &amp; pebbles'
   */


  function escape(string) {
    string = toString(string);
    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
  }
  /**
   * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
   * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escapeRegExp('[lodash](https://lodash.com/)');
   * // => '\[lodash\]\(https://lodash\.com/\)'
   */


  function escapeRegExp(string) {
    string = toString(string);
    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
  }
  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */


  var upperFirst = createCaseFirst('toUpperCase');
  /*------------------------------------------------------------------------*/

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */

  function constant(value) {
    return function () {
      return value;
    };
  }
  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */


  function identity(value) {
    return value;
  }
  /**
   * Creates a function that invokes `func` with the arguments of the created
   * function. If `func` is a property name, the created function returns the
   * property value for a given element. If `func` is an array or object, the
   * created function returns `true` for elements that contain the equivalent
   * source properties, otherwise it returns `false`.
   *
   * @static
   * @since 4.0.0
   * @memberOf _
   * @category Util
   * @param {*} [func=_.identity] The value to convert to a callback.
   * @returns {Function} Returns the callback.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
   * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, _.iteratee(['user', 'fred']));
   * // => [{ 'user': 'fred', 'age': 40 }]
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, _.iteratee('user'));
   * // => ['barney', 'fred']
   *
   * // Create custom iteratee shorthands.
   * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
   *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
   *     return func.test(string);
   *   };
   * });
   *
   * _.filter(['abc', 'def'], /ef/);
   * // => ['def']
   */


  function iteratee(func) {
    return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
  }
  /**
   * Adds all own enumerable string keyed function properties of a source
   * object to the destination object. If `object` is a function, then methods
   * are added to its prototype as well.
   *
   * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
   * avoid conflicts caused by modifying the original.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {Function|Object} [object=lodash] The destination object.
   * @param {Object} source The object of functions to add.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
   * @returns {Function|Object} Returns `object`.
   * @example
   *
   * function vowels(string) {
   *   return _.filter(string, function(v) {
   *     return /[aeiou]/i.test(v);
   *   });
   * }
   *
   * _.mixin({ 'vowels': vowels });
   * _.vowels('fred');
   * // => ['e']
   *
   * _('fred').vowels().value();
   * // => ['e']
   *
   * _.mixin({ 'vowels': vowels }, { 'chain': false });
   * _('fred').vowels();
   * // => ['e']
   */


  function mixin(object, source, options) {
    var props = keys(source),
        methodNames = baseFunctions(source, props);

    if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
      options = source;
      source = object;
      object = this;
      methodNames = baseFunctions(source, keys(source));
    }

    var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
        isFunc = isFunction(object);
    arrayEach(methodNames, function (methodName) {
      var func = source[methodName];
      object[methodName] = func;

      if (isFunc) {
        object.prototype[methodName] = function () {
          var chainAll = this.__chain__;

          if (chain || chainAll) {
            var result = object(this.__wrapped__),
                actions = result.__actions__ = copyArray(this.__actions__);
            actions.push({
              'func': func,
              'args': arguments,
              'thisArg': object
            });
            result.__chain__ = chainAll;
            return result;
          }

          return func.apply(object, arrayPush([this.value()], arguments));
        };
      }
    });
    return object;
  }
  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */


  function noop() {// No operation performed.
  }
  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */


  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */


  function stubArray() {
    return [];
  }
  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */


  function stubFalse() {
    return false;
  }
  /**
   * Generates a unique ID. If `prefix` is given, the ID is appended to it.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {string} [prefix=''] The value to prefix the ID with.
   * @returns {string} Returns the unique ID.
   * @example
   *
   * _.uniqueId('contact_');
   * // => 'contact_104'
   *
   * _.uniqueId();
   * // => '105'
   */


  function uniqueId(prefix) {
    var id = ++idCounter;
    return toString(prefix) + id;
  }
  /*------------------------------------------------------------------------*/
  // Add methods that return wrapped values in chain sequences.


  lodash.assign = assign;
  lodash.assignIn = assignIn;
  lodash.before = before;
  lodash.chain = chain;
  lodash.compact = compact;
  lodash.concat = concat;
  lodash.constant = constant;
  lodash.create = create;
  lodash.debounce = debounce;
  lodash.defaults = defaults;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.iteratee = iteratee;
  lodash.keys = keys;
  lodash.keysIn = keysIn;
  lodash.map = map;
  lodash.mapValues = mapValues;
  lodash.memoize = memoize;
  lodash.merge = merge;
  lodash.mixin = mixin;
  lodash.negate = negate;
  lodash.omit = omit;
  lodash.once = once;
  lodash.orderBy = orderBy;
  lodash.partial = partial;
  lodash.pick = pick;
  lodash.pickBy = pickBy;
  lodash.property = property;
  lodash.reject = reject;
  lodash.reverse = reverse;
  lodash.sortBy = sortBy;
  lodash.take = take;
  lodash.takeRight = takeRight;
  lodash.tap = tap;
  lodash.thru = thru;
  lodash.toArray = toArray;
  lodash.toPlainObject = toPlainObject;
  lodash.uniq = uniq;
  lodash.values = values;
  lodash.without = without; // Add aliases.

  lodash.extend = assignIn; // Add methods to `lodash.prototype`.

  mixin(lodash, lodash);
  /*------------------------------------------------------------------------*/
  // Add methods that return unwrapped values in chain sequences.

  lodash.capitalize = capitalize;
  lodash.clone = clone;
  lodash.eq = eq;
  lodash.escape = escape;
  lodash.escapeRegExp = escapeRegExp;
  lodash.every = every;
  lodash.find = find;
  lodash.findIndex = findIndex;
  lodash.findLast = findLast;
  lodash.findLastIndex = findLastIndex;
  lodash.forEach = forEach;
  lodash.get = get;
  lodash.has = has;
  lodash.hasIn = hasIn;
  lodash.identity = identity;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isArrayLike = isArrayLike;
  lodash.isArrayLikeObject = isArrayLikeObject;
  lodash.isBuffer = isBuffer;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isFunction = isFunction;
  lodash.isLength = isLength;
  lodash.isMap = isMap;
  lodash.isObject = isObject;
  lodash.isObjectLike = isObjectLike;
  lodash.isPlainObject = isPlainObject;
  lodash.isSet = isSet;
  lodash.isString = isString;
  lodash.isSymbol = isSymbol;
  lodash.isTypedArray = isTypedArray;
  lodash.last = last;
  lodash.stubArray = stubArray;
  lodash.stubFalse = stubFalse;
  lodash.noop = noop;
  lodash.now = now;
  lodash.reduce = reduce;
  lodash.result = result;
  lodash.size = size;
  lodash.toFinite = toFinite;
  lodash.toInteger = toInteger;
  lodash.toNumber = toNumber;
  lodash.toString = toString;
  lodash.uniqueId = uniqueId;
  lodash.upperFirst = upperFirst; // Add aliases.

  lodash.each = forEach;
  mixin(lodash, function () {
    var source = {};
    baseForOwn(lodash, function (func, methodName) {
      if (!hasOwnProperty.call(lodash.prototype, methodName)) {
        source[methodName] = func;
      }
    });
    return source;
  }(), {
    'chain': false
  });
  /*------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type {string}
   */

  lodash.VERSION = VERSION; // Assign default placeholders.

  partial.placeholder = lodash; // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.

  arrayEach(['drop', 'take'], function (methodName, index) {
    LazyWrapper.prototype[methodName] = function (n) {
      n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
      var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();

      if (result.__filtered__) {
        result.__takeCount__ = nativeMin(n, result.__takeCount__);
      } else {
        result.__views__.push({
          'size': nativeMin(n, MAX_ARRAY_LENGTH),
          'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
        });
      }

      return result;
    };

    LazyWrapper.prototype[methodName + 'Right'] = function (n) {
      return this.reverse()[methodName](n).reverse();
    };
  }); // Add `LazyWrapper` methods that accept an `iteratee` value.

  arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
    var type = index + 1,
        isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

    LazyWrapper.prototype[methodName] = function (iteratee) {
      var result = this.clone();

      result.__iteratees__.push({
        'iteratee': getIteratee(iteratee, 3),
        'type': type
      });

      result.__filtered__ = result.__filtered__ || isFilter;
      return result;
    };
  }); // Add `LazyWrapper` methods for `_.head` and `_.last`.

  arrayEach(['head', 'last'], function (methodName, index) {
    var takeName = 'take' + (index ? 'Right' : '');

    LazyWrapper.prototype[methodName] = function () {
      return this[takeName](1).value()[0];
    };
  }); // Add `LazyWrapper` methods for `_.initial` and `_.tail`.

  arrayEach(['initial', 'tail'], function (methodName, index) {
    var dropName = 'drop' + (index ? '' : 'Right');

    LazyWrapper.prototype[methodName] = function () {
      return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
    };
  });

  LazyWrapper.prototype.compact = function () {
    return this.filter(identity);
  };

  LazyWrapper.prototype.find = function (predicate) {
    return this.filter(predicate).head();
  };

  LazyWrapper.prototype.findLast = function (predicate) {
    return this.reverse().find(predicate);
  };

  LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
    if (typeof path == 'function') {
      return new LazyWrapper(this);
    }

    return this.map(function (value) {
      return baseInvoke(value, path, args);
    });
  });

  LazyWrapper.prototype.reject = function (predicate) {
    return this.filter(negate(getIteratee(predicate)));
  };

  LazyWrapper.prototype.slice = function (start, end) {
    start = toInteger(start);
    var result = this;

    if (result.__filtered__ && (start > 0 || end < 0)) {
      return new LazyWrapper(result);
    }

    if (start < 0) {
      result = result.takeRight(-start);
    } else if (start) {
      result = result.drop(start);
    }

    if (end !== undefined) {
      end = toInteger(end);
      result = end < 0 ? result.dropRight(-end) : result.take(end - start);
    }

    return result;
  };

  LazyWrapper.prototype.takeRightWhile = function (predicate) {
    return this.reverse().takeWhile(predicate).reverse();
  };

  LazyWrapper.prototype.toArray = function () {
    return this.take(MAX_ARRAY_LENGTH);
  }; // Add `LazyWrapper` methods to `lodash.prototype`.


  baseForOwn(LazyWrapper.prototype, function (func, methodName) {
    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
        isTaker = /^(?:head|last)$/.test(methodName),
        lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName],
        retUnwrapped = isTaker || /^find/.test(methodName);

    if (!lodashFunc) {
      return;
    }

    lodash.prototype[methodName] = function () {
      var value = this.__wrapped__,
          args = isTaker ? [1] : arguments,
          isLazy = value instanceof LazyWrapper,
          iteratee = args[0],
          useLazy = isLazy || isArray(value);

      var interceptor = function interceptor(value) {
        var result = lodashFunc.apply(lodash, arrayPush([value], args));
        return isTaker && chainAll ? result[0] : result;
      };

      if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
        // Avoid lazy use if the iteratee has a "length" value other than `1`.
        isLazy = useLazy = false;
      }

      var chainAll = this.__chain__,
          isHybrid = !!this.__actions__.length,
          isUnwrapped = retUnwrapped && !chainAll,
          onlyLazy = isLazy && !isHybrid;

      if (!retUnwrapped && useLazy) {
        value = onlyLazy ? value : new LazyWrapper(this);
        var result = func.apply(value, args);

        result.__actions__.push({
          'func': thru,
          'args': [interceptor],
          'thisArg': undefined
        });

        return new LodashWrapper(result, chainAll);
      }

      if (isUnwrapped && onlyLazy) {
        return func.apply(this, args);
      }

      result = this.thru(interceptor);
      return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
    };
  }); // Add `Array` methods to `lodash.prototype`.

  arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
    var func = arrayProto[methodName],
        chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
        retUnwrapped = /^(?:pop|shift)$/.test(methodName);

    lodash.prototype[methodName] = function () {
      var args = arguments;

      if (retUnwrapped && !this.__chain__) {
        var value = this.value();
        return func.apply(isArray(value) ? value : [], args);
      }

      return this[chainName](function (value) {
        return func.apply(isArray(value) ? value : [], args);
      });
    };
  }); // Map minified method names to their real names.

  baseForOwn(LazyWrapper.prototype, function (func, methodName) {
    var lodashFunc = lodash[methodName];

    if (lodashFunc) {
      var key = lodashFunc.name + '',
          names = realNames[key] || (realNames[key] = []);
      names.push({
        'name': methodName,
        'func': lodashFunc
      });
    }
  });
  realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
    'name': 'wrapper',
    'func': undefined
  }]; // Add methods to `LazyWrapper`.

  LazyWrapper.prototype.clone = lazyClone;
  LazyWrapper.prototype.reverse = lazyReverse;
  LazyWrapper.prototype.value = lazyValue; // Add chain sequence methods to the `lodash` wrapper.

  lodash.prototype.chain = wrapperChain;
  lodash.prototype.commit = wrapperCommit;
  lodash.prototype.next = wrapperNext;
  lodash.prototype.plant = wrapperPlant;
  lodash.prototype.reverse = wrapperReverse;
  lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue; // Add lazy aliases.

  lodash.prototype.first = lodash.prototype.head;

  if (symIterator) {
    lodash.prototype[symIterator] = wrapperToIterator;
  }
  /*--------------------------------------------------------------------------*/


  if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = lodash)._ = lodash; // Export for CommonJS support.

    freeExports._ = lodash;
  }
}).call(void 0);

},{"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/typeof":24}],"topojson":[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

!function () {
  var topojson = {
    version: "1.4.9",
    mesh: mesh,
    feature: featureOrCollection,
    neighbors: neighbors,
    presimplify: presimplify
  };

  function merge(topology, arcs) {
    var fragmentByStart = {},
        fragmentByEnd = {};
    arcs.forEach(function (i) {
      var e = ends(i),
          start = e[0],
          end = e[1],
          f,
          g;

      if (f = fragmentByEnd[start]) {
        delete fragmentByEnd[f.end];
        f.push(i);
        f.end = end;

        if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else if (g = fragmentByEnd[end]) {
          delete fragmentByStart[g.start];
          delete fragmentByEnd[g.end];
          var fg = f.concat(g.map(function (i) {
            return ~i;
          }).reverse());
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.start] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[end]) {
        delete fragmentByStart[f.start];
        f.unshift(i);
        f.start = start;

        if (g = fragmentByEnd[start]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else if (g = fragmentByStart[start]) {
          delete fragmentByStart[g.start];
          delete fragmentByEnd[g.end];
          var gf = g.map(function (i) {
            return ~i;
          }).reverse().concat(f);
          fragmentByStart[gf.start = g.end] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[start]) {
        delete fragmentByStart[f.start];
        f.unshift(~i);
        f.start = end;

        if (g = fragmentByEnd[end]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          delete fragmentByEnd[g.end];
          var gf = g.map(function (i) {
            return ~i;
          }).reverse().concat(f);
          fragmentByStart[gf.start = g.end] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByEnd[end]) {
        delete fragmentByEnd[f.end];
        f.push(~i);
        f.end = start;

        if (g = fragmentByEnd[start]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else if (g = fragmentByStart[start]) {
          delete fragmentByStart[g.start];
          delete fragmentByEnd[g.end];
          var fg = f.concat(g.map(function (i) {
            return ~i;
          }).reverse());
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.start] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else {
        f = [i];
        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
      }
    });

    function ends(i) {
      var arc = topology.arcs[i],
          p0 = arc[0],
          p1 = [0, 0];
      arc.forEach(function (dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });
      return [p0, p1];
    }

    var fragments = [];

    for (var k in fragmentByEnd) {
      fragments.push(fragmentByEnd[k]);
    }

    return fragments;
  }

  function mesh(topology, o, filter) {
    var arcs = [];

    if (arguments.length > 1) {
      var arc = function arc(i) {
        if (i < 0) i = ~i;
        (geomsByArc[i] || (geomsByArc[i] = [])).push(geom);
      };

      var line = function line(arcs) {
        arcs.forEach(arc);
      };

      var polygon = function polygon(arcs) {
        arcs.forEach(line);
      };

      var geometry = function geometry(o) {
        if (o.type === "GeometryCollection") o.geometries.forEach(geometry);else if (o.type in geometryType) {
          geom = o;
          geometryType[o.type](o.arcs);
        }
      };

      var geomsByArc = [],
          geom;
      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function MultiPolygon(arcs) {
          arcs.forEach(polygon);
        }
      };
      geometry(o);
      geomsByArc.forEach(arguments.length < 3 ? function (geoms, i) {
        arcs.push(i);
      } : function (geoms, i) {
        if (filter(geoms[0], geoms[geoms.length - 1])) arcs.push(i);
      });
    } else {
      for (var i = 0, n = topology.arcs.length; i < n; ++i) {
        arcs.push(i);
      }
    }

    return object(topology, {
      type: "MultiLineString",
      arcs: merge(topology, arcs)
    });
  }

  function featureOrCollection(topology, o) {
    return o.type === "GeometryCollection" ? {
      type: "FeatureCollection",
      features: o.geometries.map(function (o) {
        return feature(topology, o);
      })
    } : feature(topology, o);
  }

  function feature(topology, o) {
    var f = {
      type: "Feature",
      id: o.id,
      properties: o.properties || {},
      geometry: object(topology, o)
    };
    if (o.id == null) delete f.id;
    return f;
  }

  function object(topology, o) {
    var absolute = transformAbsolute(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();

      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
        points.push(p = a[k].slice());
        absolute(p, k);
      }

      if (i < 0) reverse(points, n);
    }

    function point(p) {
      p = p.slice();
      absolute(p, 0);
      return p;
    }

    function line(arcs) {
      var points = [];

      for (var i = 0, n = arcs.length; i < n; ++i) {
        arc(arcs[i], points);
      }

      if (points.length < 2) points.push(points[0].slice());
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);

      while (points.length < 4) {
        points.push(points[0].slice());
      }

      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var t = o.type;
      return t === "GeometryCollection" ? {
        type: t,
        geometries: o.geometries.map(geometry)
      } : t in geometryType ? {
        type: t,
        coordinates: geometryType[t](o)
      } : null;
    }

    var geometryType = {
      Point: function Point(o) {
        return point(o.coordinates);
      },
      MultiPoint: function MultiPoint(o) {
        return o.coordinates.map(point);
      },
      LineString: function LineString(o) {
        return line(o.arcs);
      },
      MultiLineString: function MultiLineString(o) {
        return o.arcs.map(line);
      },
      Polygon: function Polygon(o) {
        return polygon(o.arcs);
      },
      MultiPolygon: function MultiPolygon(o) {
        return o.arcs.map(polygon);
      }
    };
    return geometry(o);
  }

  function reverse(array, n) {
    var t,
        j = array.length,
        i = j - n;

    while (i < --j) {
      t = array[i], array[i++] = array[j], array[j] = t;
    }
  }

  function bisect(a, x) {
    var lo = 0,
        hi = a.length;

    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid] < x) lo = mid + 1;else hi = mid;
    }

    return lo;
  }

  function neighbors(objects) {
    var indexesByArc = {},
        // arc index -> array of object indexes
    neighbors = objects.map(function () {
      return [];
    });

    function line(arcs, i) {
      arcs.forEach(function (a) {
        if (a < 0) a = ~a;
        var o = indexesByArc[a];
        if (o) o.push(i);else indexesByArc[a] = [i];
      });
    }

    function polygon(arcs, i) {
      arcs.forEach(function (arc) {
        line(arc, i);
      });
    }

    function geometry(o, i) {
      if (o.type === "GeometryCollection") o.geometries.forEach(function (o) {
        geometry(o, i);
      });else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function MultiPolygon(arcs, i) {
        arcs.forEach(function (arc) {
          polygon(arc, i);
        });
      }
    };
    objects.forEach(geometry);

    for (var i in indexesByArc) {
      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
        for (var k = j + 1; k < m; ++k) {
          var ij = indexes[j],
              ik = indexes[k],
              n;
          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
        }
      }
    }

    return neighbors;
  }

  function presimplify(topology, triangleArea) {
    var absolute = transformAbsolute(topology.transform),
        relative = transformRelative(topology.transform),
        heap = minHeap(compareArea),
        maxArea = 0,
        triangle;
    if (!triangleArea) triangleArea = cartesianArea;
    topology.arcs.forEach(function (arc) {
      var triangles = [];
      arc.forEach(absolute);

      for (var i = 1, n = arc.length - 1; i < n; ++i) {
        triangle = arc.slice(i - 1, i + 2);
        triangle[1][2] = triangleArea(triangle);
        triangles.push(triangle);
        heap.push(triangle);
      } // Always keep the arc endpoints!


      arc[0][2] = arc[n][2] = Infinity;

      for (var i = 0, n = triangles.length; i < n; ++i) {
        triangle = triangles[i];
        triangle.previous = triangles[i - 1];
        triangle.next = triangles[i + 1];
      }
    });

    while (triangle = heap.pop()) {
      var previous = triangle.previous,
          next = triangle.next; // If the area of the current point is less than that of the previous point
      // to be eliminated, use the latter's area instead. This ensures that the
      // current point cannot be eliminated without eliminating previously-
      // eliminated points.

      if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;else maxArea = triangle[1][2];

      if (previous) {
        previous.next = next;
        previous[2] = triangle[2];
        update(previous);
      }

      if (next) {
        next.previous = previous;
        next[0] = triangle[0];
        update(next);
      }
    }

    topology.arcs.forEach(function (arc) {
      arc.forEach(relative);
    });

    function update(triangle) {
      heap.remove(triangle);
      triangle[1][2] = triangleArea(triangle);
      heap.push(triangle);
    }

    return topology;
  }

  ;

  function cartesianArea(triangle) {
    return Math.abs((triangle[0][0] - triangle[2][0]) * (triangle[1][1] - triangle[0][1]) - (triangle[0][0] - triangle[1][0]) * (triangle[2][1] - triangle[0][1]));
  }

  function compareArea(a, b) {
    return a[1][2] - b[1][2];
  }

  function minHeap(compare) {
    var heap = {},
        array = [];

    heap.push = function () {
      for (var i = 0, n = arguments.length; i < n; ++i) {
        var object = arguments[i];
        up(object.index = array.push(object) - 1);
      }

      return array.length;
    };

    heap.pop = function () {
      var removed = array[0],
          object = array.pop();

      if (array.length) {
        array[object.index = 0] = object;
        down(0);
      }

      return removed;
    };

    heap.remove = function (removed) {
      var i = removed.index,
          object = array.pop();

      if (i !== array.length) {
        array[object.index = i] = object;
        (compare(object, removed) < 0 ? up : down)(i);
      }

      return i;
    };

    function up(i) {
      var object = array[i];

      while (i > 0) {
        var up = (i + 1 >> 1) - 1,
            parent = array[up];
        if (compare(object, parent) >= 0) break;
        array[parent.index = i] = parent;
        array[object.index = i = up] = object;
      }
    }

    function down(i) {
      var object = array[i];

      while (true) {
        var right = i + 1 << 1,
            left = right - 1,
            down = i,
            child = array[down];
        if (left < array.length && compare(array[left], child) < 0) child = array[down = left];
        if (right < array.length && compare(array[right], child) < 0) child = array[down = right];
        if (down === i) break;
        array[child.index = i] = child;
        array[object.index = i = down] = object;
      }
    }

    return heap;
  }

  function transformAbsolute(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function (point, i) {
      if (!i) x0 = y0 = 0;
      point[0] = (x0 += point[0]) * kx + dx;
      point[1] = (y0 += point[1]) * ky + dy;
    };
  }

  function transformRelative(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function (point, i) {
      if (!i) x0 = y0 = 0;
      var x1 = (point[0] - dx) / kx | 0,
          y1 = (point[1] - dy) / ky | 0;
      point[0] = x1 - x0;
      point[1] = y1 - y0;
      x0 = x1;
      y0 = y1;
    };
  }

  function noop() {}

  if (typeof define === "function" && define.amd) define(topojson);else if ((typeof module === "undefined" ? "undefined" : (0, _typeof2.default)(module)) === "object" && module.exports) module.exports = topojson;else this.topojson = topojson;
}();

},{"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/typeof":24}],"underscore":[function(require,module,exports){
"use strict";

module.exports = require('lodash');

},{"lodash":"lodash"}]},{},[35]);
